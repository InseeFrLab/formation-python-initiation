{
  "hash": "9d8ff0ecfd94a7a86de2697881d25f05",
  "result": {
    "markdown": "---\ntitle: \"Types de base et variables\"\nabstract: \"Découverte des types de base (nombres et chaînes de caractères) et des variables.\"\nexecute:\n    echo: true\n    eval: false\n---\n\nDans ce premier TP, nous allons découvrir les objets les plus fondamentaux de Python : les **nombres** et les **chaînes de caractère**. Nous allons également voir comment l'on peut assigner des objets à des **variables**, afin de réaliser des opérations avec ces objets.\n\n## Nombres\n\n### Types de nombres\n\nPython propose différents objets de type numérique. Dans ce tutoriel, on va s'intéresser aux deux types principalement utilisés :\n- les entiers (type `int` pour *integer*)\n- les réels (type `float` pour nombres à virgule flottante)\n\nDe manière générale, on utilise la fonction `type` pour imprimer le type d'un objet Python.\n\n::: {#3a3a7a71 .cell execution_count=1}\n``` {.python .cell-code}\ntype(3)\n```\n:::\n\n\n::: {#bdec1ccb .cell execution_count=2}\n``` {.python .cell-code}\ntype(3.14)\n```\n:::\n\n\nLes fonctions `float` et `int` peuvent être utilisées pour passer d'un type à l'autre.\n\n::: {#4c243ab7 .cell execution_count=3}\n``` {.python .cell-code}\n# Conversion en float\nfloat(3)\n```\n:::\n\n\n::: {#288f19c7 .cell execution_count=4}\n``` {.python .cell-code}\n# Conversion en float\ntype(float(3))\n```\n:::\n\n\n::: {#1a5eea0f .cell execution_count=5}\n``` {.python .cell-code}\n# Conversion en int\nint(3.79)\n```\n:::\n\n\nAttention à la conversion *float* -> *int*, qui tronque la partie décimale.\n\nLes *floats* peuvent par ailleurs être écrits en notation scientifique :\n\n::: {#583ed56c .cell execution_count=6}\n``` {.python .cell-code}\n2e3\n```\n:::\n\n\n::: {#32e1b553 .cell execution_count=7}\n``` {.python .cell-code}\ntype(2e3)\n```\n:::\n\n\n### Opérations arithmétiques de base\n\n::: {#9691ad9e .cell execution_count=8}\n``` {.python .cell-code}\n# Addition\n8 + 9\n```\n:::\n\n\n::: {#d3396a9b .cell execution_count=9}\n``` {.python .cell-code}\n# Soustraction\n5 - 2\n```\n:::\n\n\n::: {#2fd078d3 .cell execution_count=10}\n``` {.python .cell-code}\n# Multiplication\n2 * 6\n```\n:::\n\n\n::: {#bcd1f4ae .cell execution_count=11}\n``` {.python .cell-code}\n# Division\n9 / 4\n```\n:::\n\n\n::: {#c133370e .cell execution_count=12}\n``` {.python .cell-code}\n# Division par 0\n3 / 0\n```\n:::\n\n\nC'était bien sûr prévisible. Mais il n'est pas rare d'avoir de telles erreurs dans le cadre de calculs statistiques, notamment avec *NumPy* ou *Pandas*, produisant une erreur similaire qu'il faut alors débugger.\n\n::: {#87b666dc .cell execution_count=13}\n``` {.python .cell-code}\n# Division euclidienne : quotient\n9 // 4\n```\n:::\n\n\n::: {#721d6cb4 .cell execution_count=14}\n``` {.python .cell-code}\n# Division euclidienne : reste\n9 % 4\n```\n:::\n\n\n::: {#4cb8b6d8 .cell execution_count=15}\n``` {.python .cell-code}\n# Puissance\n2 ** 5\n```\n:::\n\n\n::: {#b0b17c07 .cell execution_count=16}\n``` {.python .cell-code}\n# Racine carrée\n5 ** 0.5\n```\n:::\n\n\n::: {#1eb2a3ba .cell execution_count=17}\n``` {.python .cell-code}\n# Ordre des opérations : convention usuelle\n2 + 5 * (10 - 4)\n```\n:::\n\n\n## Chaînes de charactères\n\nLes chaînes de caractères (ou *strings*) sont utilisées pour stocker de l'information textuelle. Plus précisément, elles peuvent stocker tout caractère de type [Unicode](https://fr.wikipedia.org/wiki/Unicode), ce qui inclut les lettres des différentes langues, mais également la ponctuation, les chiffres, les smileys, etc.\n\nUn *string* se définit en mettant l'information entre apostrophes ou entre guillemets (anglais). \n\n### Définition\n\n::: {#33635229 .cell execution_count=18}\n``` {.python .cell-code}\n# Première manière \n'mot'\n```\n:::\n\n\n::: {#b3507ea2 .cell execution_count=19}\n``` {.python .cell-code}\n# Deuxième manière\n\"ça fonctionne aussi\"\n```\n:::\n\n\n::: {#fe516ed8 .cell execution_count=20}\n``` {.python .cell-code}\n# Mais attention au mélange des deux !\n'l'apostrophe, quelle catastrophe'\n```\n:::\n\n\nErreur de syntaxe : la seconde apostrophe est comprise comme la fin du *string*, et Python ne sait pas interpréter le reste de la séquence.\n\nIl faut donc varier en cas de besoin :\n\n::: {#2a7b4930 .cell execution_count=21}\n``` {.python .cell-code}\n\"l'apostrophe, aucun problème\"\n```\n:::\n\n\nMême chose en sens inverse :\n\n::: {#1fac2dbb .cell execution_count=22}\n``` {.python .cell-code}\n'les guillemets, \"aucun problème\"'\n```\n:::\n\n\n### La fonction `print`\n\nLe travail avec les *strings* est l'occasion de découvrir la très pratique et très utilisée fonction `print`. Elle affiche simplement l'argument qu'on lui passe entre parenthèses **et** un retour à la ligne par défaut.\n\n::: {#385a1aa8 .cell execution_count=23}\n``` {.python .cell-code}\n# Affichage de la chaîne \"moi\"\n\"moi\"\n```\n:::\n\n\n::: {#3e339409 .cell execution_count=24}\n``` {.python .cell-code}\n# Affichage de la chaîne \"moi\" avec print\nprint(\"moi\")\n```\n:::\n\n\nOn a vu jusqu'à maintenant que l'on pouvait simplement exécuter une cellule pour afficher le contenu d'un *string*. Mais est-ce cela marche avec plusieurs *strings* ?\n\n::: {#9fa47ff0 .cell execution_count=25}\n``` {.python .cell-code}\n# Qui va être affiché ?\n\"moi\"\n\"non moi\"\n```\n:::\n\n\nOn voit là un comportement caractéristique des notebooks Jupyter : seule la dernière valeur renvoyée dans une cellule est affichée. La fonction `print` permet de s'affranchir de cette limite.\n\n::: {#bf4d6403 .cell execution_count=26}\n``` {.python .cell-code}\n# Et cette fois ?\nprint(\"moi\")\nprint(\"moi aussi\")\n```\n:::\n\n\n### Longueur d'une chaîne\n\nLa fonction `len` permet de compter le nombre de caractères d'un *string*, tous caractères inclus (lettres, chiffres, espaces, ponctuation...).\n\n::: {#13ee5b6f .cell execution_count=27}\n``` {.python .cell-code}\nlen(\"J'ai 19 charactères\")\n```\n:::\n\n\nLe type \"caractère\" n'existe pas en Python : un caractère seul est défini comme un *string* de taille 1.\n\n::: {#00ed31c6 .cell execution_count=28}\n``` {.python .cell-code}\nprint(type(\"a\"))\nprint(len(\"a\"))\n```\n:::\n\n\n### Indexation\n\nEn Python, un *string* est une **séquence**, c'est à dire une suite de caractères dans un ordre spécifique. Par conséquent, chaque caractère d'un *string* est indexé (Python connaît sa position), et l'on peut utiliser cet index pour extraire des caractères particuliers, des sous-chaînes de caractères, etc.\n\nEn Python, on utilise les crochets `[]` pour appeler l'index d'une séquence. Plus précisément, l'index fonctionne sur le modèle suivant : `x[a:b:c]` renvoie un *sub-string* du *string* `x` où `a` est la position du caractère de départ, `b` la position du caractère d'arrivée plus 1, et `c` le pas de l'indexation. Tout cela sera plus clair avec les exemples suivants.\n\nNote importante : **l'indexation commence à 0 en Python**.\n\n::: {#77f6382d .cell execution_count=29}\n``` {.python .cell-code}\n\"une séquence que l'on va indexer\"\n```\n:::\n\n\n::: {#35960bdb .cell execution_count=30}\n``` {.python .cell-code}\n# Premier élémént\n\"une séquence que l'on va indexer\"[0]\n```\n:::\n\n\n::: {#80f54929 .cell execution_count=31}\n``` {.python .cell-code}\n# Deuxième élémént\n\"une séquence que l'on va indexer\"[1]\n```\n:::\n\n\n::: {#cbeedb97 .cell execution_count=32}\n``` {.python .cell-code}\n# Dernier élémént\n\"une séquence que l'on va indexer\"[-1]\n```\n:::\n\n\n::: {#188713ed .cell execution_count=33}\n``` {.python .cell-code}\n# Extraire tout à partir d'un certain caractère\n\"une séquence que l'on va indexer\"[4:]\n```\n:::\n\n\n::: {#ffb9bf1e .cell execution_count=34}\n``` {.python .cell-code}\n# Extraire tout jusqu'à un certain caractère\n\"une séquence que l'on va indexer\"[:12]\n```\n:::\n\n\n::: {#1c07c1ca .cell execution_count=35}\n``` {.python .cell-code}\n# Extraire un sub-string\n\"une séquence que l'on va indexer\"[4:12]\n```\n:::\n\n\n::: {#12d90b7e .cell execution_count=36}\n``` {.python .cell-code}\n# Extraire tous les 2 caractères, à partir de la 4 ème position\n\"une séquence que l'on va indexer\"[4::2]\n```\n:::\n\n\n::: {#80febdbb .cell execution_count=37}\n``` {.python .cell-code}\n# Inverser une séquence\n\"une séquence que l'on va indexer\"[::-1]\n```\n:::\n\n\nA retenir : c'est bien parce qu'un *string* est considéré comme une séquence par Python que l'on peut l'indexer. Par exemple, indexer un nombre n'a pas de sens, et renvoie donc une erreur.\n\n::: {#94f7250b .cell execution_count=38}\n``` {.python .cell-code}\n2[3]\n```\n:::\n\n\n### Quelques propriétés utiles\n\n::: {#d4915e9d .cell execution_count=39}\n``` {.python .cell-code}\n# Concaténation de strings\n\"mon adresse est : \" + \"10 rue des Peupliers\"\n```\n:::\n\n\n::: {#767ca2f7 .cell execution_count=40}\n``` {.python .cell-code}\n# Répétition\n\"echo - \" * 5\n```\n:::\n\n\n### Quelques méthodes utiles\n\nLes différents objets Python ont généralement des **méthodes** dites *built-in* (standard), qui permettent d'effectuer des opérations de base à partir de l'objet. \n\nNous verrons dans un prochain chapitre en quoi consistent précisément les méthodes en Python. Pour le moment, on peut retenir que les méthodes s'utilisent selon le format `objet.methode(parametres)` où les paramètres sont optionnels.\n\n::: {#1d5acb11 .cell execution_count=41}\n``` {.python .cell-code}\n# Mettre en majuscules\n\"sequence 850\".upper()\n```\n:::\n\n\n::: {#0aec13a8 .cell execution_count=42}\n``` {.python .cell-code}\n# Mettre en minuscules\n\"sequence 850\".lower()\n```\n:::\n\n\n::: {#1bbbbd07 .cell execution_count=43}\n``` {.python .cell-code}\n# Séparer les mots selon les espaces\n\"une séquence    à séparer\".split()\n```\n:::\n\n\n::: {#8a7481ee .cell execution_count=44}\n``` {.python .cell-code}\n# Séparer les mots selon un caractère arbitraire\n\"pratique pour faire des sous-séquences\".split(\"-\")\n```\n:::\n\n\n::: {#135e211a .cell execution_count=45}\n``` {.python .cell-code}\n# Utiliser les strings comme templates\n\"mon adresse est : {}\".format(\"10 rue des Peupliers\")\n```\n:::\n\n\nTout ceci n'est qu'un aperçu des innombrables opérations possibles sur les *strings*. La [documentation officielle](https://docs.python.org/3/library/stdtypes.html#string-methods) liste l'ensemble des méthodes *built-in* disponibles. Les exercices du chapitre et les mini-projets de fin de partie seront l'occasion de découvrir d'autres utilisations.\n\n## Variables\n\nJusqu'ici, nous avons dû définir à chaque fois notre objet avant de pouvoir lui appliquer une transformation. Comment faire si l'on veut réutiliser un objet et lui appliquer plusieurs transformations ? Ou faire des opérations à partir de différents objets ?\n\nPour cela, on va assigner les objets à des variables.\n\n### Assignation et opérations\n\nL'assignation se fait suivant le format : `nom_de_la_variable = objet`. Cela permet ensuite de réaliser des opérations à partir de ces variables.\n\n::: {#660aa6f7 .cell execution_count=46}\n``` {.python .cell-code}\nx = 5\nx\n```\n:::\n\n\n::: {#acc057fc .cell execution_count=47}\n``` {.python .cell-code}\ntype(x)\n```\n:::\n\n\n::: {#36ef8b9e .cell execution_count=48}\n``` {.python .cell-code}\nx + 5\n```\n:::\n\n\n::: {#dc7b102e .cell execution_count=49}\n``` {.python .cell-code}\ny = x + 2*x\ny\n```\n:::\n\n\nContrairement à d'autres langages de programmation, Python est dit *dynamiquement* typé : il est possible de réassigner une variable à un objet de type différent. Cela facilite la lecture et le développement, mais peut parfois générer des problèmes difficiles à débugger... Il faut donc toujours bien faire attention que le type de la variable est bien celui que l'on s'imagine manipuler.\n\n::: {#eff27a5f .cell execution_count=50}\n``` {.python .cell-code}\nx = 3\nx = \"blabla\"\ntype(x)\n```\n:::\n\n\nIl y a naturellement certaines contraintes sur les opérations selon les types des objets.\n\n::: {#9ce01722 .cell execution_count=51}\n``` {.python .cell-code}\nx = \"test\"\ny = 3\nx + y\n```\n:::\n\n\nIl est par contre possible d'harmoniser les types en amont :\n\n::: {#ed4c41c3 .cell execution_count=52}\n``` {.python .cell-code}\nx = \"test\"\ny = 3\nz = str(y)\nx + z\n```\n:::\n\n\n### Incrémentation\n\nIl est fréquent d'utiliser une variable comme un compteur, en l'incrémentant à chaque fois qu'un évènement donné apparaît par exemple.\n\n::: {#65c31863 .cell execution_count=53}\n``` {.python .cell-code}\na = 0\nprint(a)\na = a +1\nprint(a)\n```\n:::\n\n\nCette pratique est tellement fréquente qu'il existe des opérateurs spéciaux pour les opérations arithmétiques courantes.\n\n::: {#3dba13bd .cell execution_count=54}\n``` {.python .cell-code}\na = 0\na += 1\na\n```\n:::\n\n\n::: {#d35c866f .cell execution_count=55}\n``` {.python .cell-code}\nb = 5\nb *= 3\nb\n```\n:::\n\n\n## Exercices\n\n### Exercice 1\n\nAfficher le type de x lorsque : \n- x = 3\n- x = \"test\"\n- x = 3.5\n\n::: {#d18e52d8 .cell execution_count=56}\n``` {.python .cell-code}\n# Tapez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#26cdf307 .cell execution_count=57}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 2-9 solutions.py\n```\n:::\n\n\n### Exercice 2\n\n\n\nCalculer la somme des longueurs de chacune des chaînes de caractères suivantes : \n- \"une première chaîne\"\n- \"et une deuxième\"\n- \"jamais deux sans trois\"\n\n::: {#e3048900 .cell execution_count=58}\n``` {.python .cell-code}\n# Tapez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#5bd9ee0f .cell execution_count=59}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 12-16 solutions.py\n```\n:::\n\n\n### Exercice 3\n\nQuel est le type adapté pour définir un code postal ?\n\nEssayer de définir les codes postaux suivants au format `int` et au format `string` :\n- 92120\n- 02350\n\nQue concluez-vous ?\n\n::: {#84e57eee .cell execution_count=60}\n``` {.python .cell-code}\n# Tapez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#0c7da279 .cell execution_count=61}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 19-26 solutions.py\n```\n:::\n\n\n### Exercice 4\n\nCompter le nombre de fois où la lettre e est présente dans la chaîne suivante :\n\"Je fais un comptage des e.\"\n\n**Indice** : on peut utiliser la méthode *built-in* [count](https://docs.python.org/fr/3/library/stdtypes.html#str.count).\n\n::: {#194a6aea .cell execution_count=62}\n``` {.python .cell-code}\n# Tapez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#ea5ceb74 .cell execution_count=63}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 29-30 solutions.py\n```\n:::\n\n\n### Exercice 5\n\nRepérer la première position où la lettre e est présente dans la chaîne suivante : \"Je fais un comptage des e.\"\n\n**Indice** : on peut utiliser la méthode *built-in* [find](https://docs.python.org/fr/3/library/stdtypes.html#str.find).\n\n::: {#d8412a9e .cell execution_count=64}\n``` {.python .cell-code}\n# Tapez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#d09b193e .cell execution_count=65}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 33-34 solutions.py\n```\n:::\n\n\n### Exercice 6\n\nSupprimer les espaces superflus au début et à la fin de la chaîne suivante :\n\n**Indice** : on peut utiliser la méthode *built-in* [strip](https://docs.python.org/fr/3/library/stdtypes.html#str.strip).\n\n::: {#2299a598 .cell execution_count=66}\n``` {.python .cell-code}\n# Tapez votre réponse dans cette cellule\na = \"    Un string très mal formatté.         \"\n```\n:::\n\n\n::: {#09a0fadf .cell execution_count=67}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 37-38 solutions.py\n```\n:::\n\n\n### Exercice 7\n\nLe caractère `\\` permet d'échapper (neutraliser) un caractère spécial au sein d'une chaîne de caractères. Trouvez comment ce caractère permet de résoudre le problème lié à l'utilisation de guillemets (ou d'apostrophes) dans une chaîne définie par des guillemets (apostrophe).\n\n**Indice** : des exemples d'utilisation sont disponibles dans la [documentation officielle](https://docs.python.org/fr/3.8/reference/lexical_analysis.html#literals).\n\n::: {#d1605cba .cell execution_count=68}\n``` {.python .cell-code}\n# Tapez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#754ab675 .cell execution_count=69}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 41 solutions.py\n```\n:::\n\n\n### Exercice 8\n\nRéaliser la suite d'opérations suivantes à l'aide des opérateurs d'incrémentation, et imprimer la valeur finale :\n- initialiser une variable à 1\n- lui soustraire 5\n- la multiplier par 4\n- lui ajouter 22\n\n::: {#a240fe05 .cell execution_count=70}\n``` {.python .cell-code}\n# Tapez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#60f63346 .cell execution_count=71}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 44-48 solutions.py\n```\n:::\n\n\n### Exercice 9\n\nConsidérons les deux séquences suivantes :\n- \"nous sommes en\"\n- \"2022\"\n\nTrouvez à partir du tutoriel deux manières différentes de les utiliser pour composer la séquence \"nous sommes en 2022\".\n\n**Indice** : l'une des deux méthodes implique de modifier (légèrement) une des deux séquences.\n\n::: {#1c3c4e69 .cell execution_count=72}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 51-56 solutions.py\n```\n:::\n\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.11.4\n---\n",
    "supporting": [
      "tutorial_files"
    ],
    "filters": []
  }
}