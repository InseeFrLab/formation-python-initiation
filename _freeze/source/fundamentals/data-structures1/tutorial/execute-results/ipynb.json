{
  "hash": "07bae774789fdce14385bef2c6108ec0",
  "result": {
    "markdown": "---\ntitle: \"Structures de données 1 : listes et tuples\"\nabstract: \"Découverte des structures de données séquentielles : listes et tuples.\"\nexecute:\n    echo: true\n    eval: false\n---\n\nDans ce tutoriel, nous allons nous intéresser à des structures de données de base en Python : les **listes** et les **tuples**. Les structures de données peuvent être vues comme des conteneurs car ils permettent de stocker, d'organiser et d'accéder à des données. Les listes et les tuples sont des **conteneurs séquentiels** : les éléments qu'ils contiennent sont **ordonnés**, et leur position est enregistrée dans un **index**.\n\n## Listes\n\n### Définition\n\nDans le tutoriel précédent, nous avons vu que les chaînes de caractères étaient des **séquences** de caractères. Les listes sont également des séquences, c'est à dire des suites ordonnées d'éléments, mais plus générales : les éléments peuvent être de différente nature.\n\nLes listes sont construites avec des crochets **[]**, et les éléments de la liste sont séparés par des virgules.\n\nAssignons une première liste à une variable `a` :\n\n::: {#214dd10b .cell execution_count=1}\n``` {.python .cell-code}\na = [1, 2, 3]\nprint(a)\n```\n:::\n\n\nLa liste `a` est constituée d'entiers, mais une liste peut en pratique contenir des objets de tout type.\n\n::: {#7f95fc02 .cell execution_count=2}\n``` {.python .cell-code}\nb = [\"une séquence\", 56, \"d\"]\nprint(b)\n```\n:::\n\n\nIl est notamment possible de créer des listes de listes (et ainsi de suite), ce qui permet de créer des structures hiérarchiques de données.\n\n::: {#8090e540 .cell execution_count=3}\n``` {.python .cell-code}\nc = [\"une séquence\", 56, [\"cette liste est imbriquée\", 75, \"o\"]]\nprint(c)\n```\n:::\n\n\nUne liste imbriquée peut aussi être construite à partir de listes déjà définies.\n\n::: {#932546d2 .cell execution_count=4}\n``` {.python .cell-code}\nitem1 = [\"cafe\", \"500g\"]\nitem2 = [\"biscuits\", \"20\"]\nitem3 = [\"lait\", \"1L\"]\ninventaire = [item1, item2, item3]\nprint(inventaire)\n```\n:::\n\n\nOn verra cependant dans le prochain tutoriel que les dictionnaires sont généralement des structures de données souvent plus adaptées que les listes pour représenter des données sous forme hiérarchique.\n\n### Longueur d'une liste\n\nComme les chaînes de caractères, il est possible d'utiliser la fonction `len` pour compter le nombre d'éléments présents dans une liste.\n\n::: {#a151abf5 .cell execution_count=5}\n``` {.python .cell-code}\nd = [\"ceci\", \"est\", \"une\", \"liste\"]\nlen(d)\n```\n:::\n\n\n### Indexation\n\nLes listes étant des séquences, elles s'indexent de la même manière que les chaînes de caractères. Il est notamment important de se rappeler que la numérotation des positions commence à 0 en Python.\n\n::: {#e6e0d38d .cell execution_count=6}\n``` {.python .cell-code}\n# Troisième élément de la liste a\nprint(a[2])\n```\n:::\n\n\nBien entendu, il n'est pas possible de demander un élément qui n'existe pas. Python renvoie une erreur nous indiquant que l'index demandé est hors limites.\n\n::: {#8453c80a .cell execution_count=7}\n``` {.python .cell-code}\nprint(a[5])\n```\n:::\n\n\nPour indexer une liste contenue dans une autre liste, on utilise une double indexation.\n\n::: {#35bd497e .cell execution_count=8}\n``` {.python .cell-code}\n# Premier élément de la sous-liste qui est à la deuxième position de la liste c\nprint(c[2][0])\n```\n:::\n\n\nEn termes d'indexation, tout ce qui était possible sur les chaînes caractères l'est également avec les listes.\n\n::: {#79140aac .cell execution_count=9}\n``` {.python .cell-code}\n# Tous les éléments à partir de la 1ère position\nprint(b[1:])\n```\n:::\n\n\n::: {#62523f51 .cell execution_count=10}\n``` {.python .cell-code}\n# Inverser une liste\nprint(a[::-1])\n```\n:::\n\n\n### Modification d'éléments\n\nIl est possible de modifier les éléments d'une liste manuellement, avec une syntaxe similaire à l'assignation de variable.\n\n::: {#bc99731c .cell execution_count=11}\n``` {.python .cell-code}\n# Réassignation d'un élément\nd = [1, 2, \"toto\", 4]\nd[2] = 3\nprint(d)\n```\n:::\n\n\n::: {#61053bf4 .cell execution_count=12}\n``` {.python .cell-code}\n# Substitution d'un élément\na = [1, 2, 3]\nb = [\"do\", \"re\", \"mi\"]\nb[0] = a[2]\nprint(b)\n```\n:::\n\n\n### Suppression d'éléments\n\nL'instruction `del` permet de supprimer un élément par position. Les éléments qui se trouvaient après l'élément supprimé voient donc leur index réduit de 1.\n\n::: {#b77545bc .cell execution_count=13}\n``` {.python .cell-code}\ne = [1, \"do\", 6]\nprint(e)\nprint(e[2])\n\ndel e[1]\nprint(e)\nprint(e[1])\n```\n:::\n\n\n### Quelques propriétés utiles\n\nLà encore, on retrouve des propriétés inhérentes aux séquences.\n\n::: {#3f8bdba8 .cell execution_count=14}\n``` {.python .cell-code}\n# Concaténation\n[1, 2, 3] + [\"a\", 12]\n```\n:::\n\n\n::: {#c5125899 .cell execution_count=15}\n``` {.python .cell-code}\n# Réplication\n[\"a\", \"b\", \"c\"] * 3\n```\n:::\n\n\n### Quelques méthodes utiles\n\nA l'instar des chaînes de caractères, les listes ont de nombreuses méthodes *built-in*, qui s'utilisent selon le format `objet.methode(parametres)`. Les plus utiles sont présentées ci-dessous ; d'autres méthodes seront utilisées dans le cadre des exercices de fin de section.\n\n::: {#143f2133 .cell execution_count=16}\n``` {.python .cell-code}\n# Ajouter un élément\na = [1, 2, 3]\na.append(4)\nprint(a)\n```\n:::\n\n\n::: {#c5dc6172 .cell execution_count=17}\n``` {.python .cell-code}\n# Supprimer un élément par position\nb = [\"do\", \"re\", \"mi\"]\nb.pop(0)\nprint(b)\n```\n:::\n\n\n::: {#f4882dc7 .cell execution_count=18}\n``` {.python .cell-code}\n# Supprimer un élément par valeur\nb = [\"do\", \"re\", \"mi\"]\nb.remove(\"mi\")\nprint(b)\n```\n:::\n\n\n::: {#13ceed2c .cell execution_count=19}\n``` {.python .cell-code}\n# Inverser une liste\nl = [1, 2, 3, 4, 5]\nl.reverse()\nprint(l)\n```\n:::\n\n\n::: {#8997c540 .cell execution_count=20}\n``` {.python .cell-code}\n# Trouver la position d'un élément\nb = [\"a\", \"b\", \"c\", \"d\", \"e\"]\nb.index(\"d\")\n```\n:::\n\n\n## Tuples\n\n### Définition\n\nLes **tuples** sont une autre structure de données basique en Python, semblable à celle des listes dans leur fonctionnement. Il y a cependant une différence fondamentale : là où les éléments d'une liste peuvent être modifiés par position comme on l'a vu précédemment, les tuples sont **non-modifiables** (*immutable*). Ainsi, les éléments d'un tuple ne peuvent pas être modifiés sans redéfinir complètement le tuple. \n\nQuand est-il pertinent d'utiliser un tuple plutôt qu'une liste ? En pratique, les tuples sont beaucoup moins fréquemment utilisés que les listes. On utilise généralement les tuples pour **stocker des données qui n'ont pas vocation à être modifiées** lors de l'exécution de notre programme Python. Cela permet de se prémunir contre des problèmes d'intégrité de données, c'est à dire de modification non-voulue des données d'entrée. On s'évite ainsi parfois de longues et pénibles séances de debugging.\n\nUne autre différence, mineure celle-ci, est que les tuples s'écrivent avec des **parenthèses** au lieu des crochets. Les différents éléments sont toujours séparés par des virgules.\n\n::: {#6b74ccf3 .cell execution_count=21}\n``` {.python .cell-code}\nx = (1, 2, \"mi\", \"fa\", 5)\nx\n```\n:::\n\n\nAfin de bien faire la différence avec l'usage normal des parenthèses (dans les calculs ou pour délimiter les expressions), un tuple à un seul élément se définit avec une virgule après le premier élément.\n\n::: {#27696238 .cell execution_count=22}\n``` {.python .cell-code}\nx1 = (\"a\", )\nx1\n```\n:::\n\n\nVérifions qu'il est impossible de modifier ou d'ajouter un élément à un tuple.\n\n::: {#377c5562 .cell execution_count=23}\n``` {.python .cell-code}\nt = (\"do\", \"rez\", \"mi\")\nt[1] = \"re\"\n```\n:::\n\n\n::: {#3895e270 .cell execution_count=24}\n``` {.python .cell-code}\nt = (\"do\", \"re\", \"mi\")\nt.append(\"fa\")\n```\n:::\n\n\n### Fonctionnement\n\nLes tuples s'indexent comme les listes.\n\n::: {#6a266317 .cell execution_count=25}\n``` {.python .cell-code}\nprint(x[0])\nprint(x[3:5])\n```\n:::\n\n\nEt peuvent également s'utiliser de manière hiérarchique.\n\n::: {#fbd8a8d5 .cell execution_count=26}\n``` {.python .cell-code}\nt1 = (\"a\", \"b\", \"c\")\nt2 = (1, 2, 3)\nt3 = (t1, \"et\", t2)\n\nprint(t3)\nprint(t3[2][1])\n```\n:::\n\n\nLes tuples partagent certaines méthodes *built-in* avec les listes : celles qui ne provoquent pas de modification de l'objet.\n\n::: {#3ae2c156 .cell execution_count=27}\n``` {.python .cell-code}\nt = (\"do\", \"re\", \"mi\")\nt.index(\"do\")\n```\n:::\n\n\n::: {#3423da4d .cell execution_count=28}\n``` {.python .cell-code}\nt = (\"do\", \"re\", \"mi\", \"re\", \"do\")\nt.count(\"re\")\n```\n:::\n\n\n### Conversion\n\nLes fonctions `list` et `tuple` permettent de convertir une liste en tuple et inversement.\n\n::: {#7693a1c8 .cell execution_count=29}\n``` {.python .cell-code}\ntuple([\"do\", \"re\", \"mi\"])\n```\n:::\n\n\n::: {#efa82f32 .cell execution_count=30}\n``` {.python .cell-code}\nlist((1, 2, 3, 4, 5))\n```\n:::\n\n\nCes fonctions ont d'autres usages en pratique, que nous verrons en exercice.\n\n## Exercices\n\n### Questions de compréhension\n\n- Pourquoi dit-on des listes et des tuples que ce sont des conteneurs ?\n- Quel est le point commun entre les listes et les chaînes de caractères ?\n- Comment est enregistré l'ordre des éléments dans une séquence en Python ?\n- Quelle est la différence fondamentale entre une liste et un tuple ?\n- Dans quel cas aura-t-on plutôt intérêt à utiliser un tuple qu'une liste ?\n- Peut-on avoir des éléments de types différents (ex : `int` et `string`) dans une même liste ? Dans un même tuple ?\n\nSi les réponses à ces questions ne sont pas encore claires, n'hésitez pas à revenir au tutoriel, ou bien à tester par vous-même dans une cellule.\n\n### Exercice\n\nCréez 4 listes portant les noms des 4 saisons, contenant chacune les noms des mois associés (les mois de changement de saison seront attribués à la saison précédente). Puis créez une liste `saisons` contenant les 4 listes. Essayez de prévoir ce que vont renvoyer (type de l'objet, nombre d'éléments et contenu) les instructions suivantes, puis vérifiez le. \n\n- `saisons`\n- `saisons[0]`\n- `saisons[0][0]`\n- `saisons[1][-1]`\n- `saisons[2][:3]`\n- `saisons[1][1:2] + saisons[-1][3:]`\n- `saisons[2:]`\n- `saisons + saisons[0]`\n- `saisons[3][::]`\n- `saisons[3][::-1]`\n- `saisons * 3`\n\n::: {#ff68c40f .cell execution_count=31}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#b6b69960 .cell execution_count=32}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 3-41 solutions.py\n```\n:::\n\n\n### Exercice\n\nEn ajoutant, supprimant et modifiant des éléments, nettoyez la liste suivante pour qu'elle contienne les notes de musique \"do re mi fa sol la si\" dans le bon ordre.\n\n`l = [\"do\", \"re\", \"re\", \"re\", \"fa\", \"sol\", \"solsi\", \"la\"]`\n\n::: {#da8d0f3f .cell execution_count=33}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#f5d1410b .cell execution_count=34}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 45-56 solutions.py\n```\n:::\n\n\n### Exercice\n\nProposez deux méthodes pour inverser la liste `[\"une\", \"liste\", \"quelconque\"]`. Quelle est la différence majeure entre les deux méthodes ?\n\n::: {#f1d00671 .cell execution_count=35}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#0b8366a8 .cell execution_count=36}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 60-75 solutions.py\n```\n:::\n\n\n### Exercice\n\nNous avons vu que l'instruction `ma_liste.pop(i)` supprimait le i-ème élément de la liste `ma_liste`. A l'aide de la documentation Python ou d'une recherche sur Google, déterminez le comportement par défaut de cette méthode, c'est à dire ce qu'il se passe lorsqu'on ne donne aucun paramètre à la fonction `pop`. Vérifiez que vous observez bien ce comportement à l'aide d'un exemple de votre choix.\n\n::: {#93f05e0f .cell execution_count=37}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#51c656cb .cell execution_count=38}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 79-81 solutions.py\n```\n:::\n\n\n### Exercice\n\nIl existe beaucoup d'autres méthodes *built-in* pour les listes que celles que nous avons déjà vues. Par exemple : `min` et `max`. Vérifiez leur comportement : \n- sur une liste composée uniquement d'objets numériques (`int` et `float`) ;\n- sur une liste composée uniquement de chaînes de caractères ;\n- sur une liste composée d'un mélange d'objets numériques et textuels.\n\n::: {#b0dab264 .cell execution_count=39}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#93fc6305 .cell execution_count=40}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 85-91 solutions.py\n```\n:::\n\n\n### Exercice\n\nEssayer de créer une liste vide. Vérifiez son type. Quel intérêt cela pourrait-il avoir ?\n\n::: {#f4c68c88 .cell execution_count=41}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#50d0ce23 .cell execution_count=42}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 95-107 solutions.py\n```\n:::\n\n\n### Exercice\n\nDans le tutoriel, nous avons vu les fonctions `list` et `tuple` qui permettent de passer d'un type à l'autre. En réalité, le fonctionnement de ces fonctions est plus subtil : le code `list(mon_objet)` renvoie la \"version liste\" de cet objet, de la même manière par exemple que `str(3)` renvoie `'3'`, c'est à dire la version *string* de l'entier `3`.\n\nA l'aide de la fonction `list`, trouver les \"versions liste\" des objets suivants :\n- le tuple `a = (1, 2, 3)` ;\n- la chaîne de caractères `b = \"bonjour\"` ;\n- l'entier `c = 5`\n\n::: {#098c0bb6 .cell execution_count=43}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#11e6972c .cell execution_count=44}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 111-125 solutions.py\n```\n:::\n\n\n### Exercice\n\nNous avons vu que les tuples avaient la particularité d'être non-modifiables. Mais est-ce que cette propriété se transfère de manière récursive ? Par exemple, est-ce qu'une liste contenue dans un tuple est-elle même non-modifiable ? Vérifiez à l'aide d'un exemple de votre choix.\n\n::: {#94b5836e .cell execution_count=45}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#8aa12707 .cell execution_count=46}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 129-134 solutions.py\n```\n:::\n\n\n### Exercice\n\nLisez la partie concernant l'agrégation et la dissociation de séquences dans la [documentation Python](https://docs.python.org/fr/3/tutorial/datastructures.html#tuples-and-sequences). La dissociation est une propriété souvent utilisée en pratique. Vérifiez qu'elle fonctionne sur les différents objets séquentiels que nous avons vus jusqu'à maintenant (chaînes de caractères, listes et tuples).\n\n::: {#fb4f3322 .cell execution_count=47}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#5c7bab4b .cell execution_count=48}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 138-145 solutions.py\n```\n:::\n\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.10.12\n---\n",
    "supporting": [
      "tutorial_files"
    ],
    "filters": []
  }
}