{
  "hash": "782872990e8ea071285a97d81b62b448",
  "result": {
    "markdown": "---\ntitle: \"Structures de données 2 : dictionnaires et sets\"\nabstract: \"Découverte des structures de données non-ordonnées : dictionnaires et sets.\"\nexecute:\n    echo: true\n    eval: false\n---\n\nDans le tutoriel précédent, nous avons manipulé des structures de données de type séquentielles : les listes et les tuples. A présent, nous allons découvrir les dictionnaires et les sets, qui sont des structures de données non-ordonnées : les objets ne sont plus stockés par position (ou index) mais par **clé**, c'est à dire un identifiant unique.\n\n## Dictionnaires\n\n### Définition\n\nLes dictionnaires sont des **collections non-ordonnées de couples clé-valeur**. Un dictionnaire se définit selon la syntaxe suivante : `d = {'cle1': 'valeur1', 'cle2': 'valeur2'}`.\n\n::: {#88de19b2 .cell execution_count=1}\n``` {.python .cell-code}\ninventaire = {'cafe': '500g', 'lait': '1,5L'}\ninventaire\n```\n:::\n\n\n::: {#5f6559c9 .cell execution_count=2}\n``` {.python .cell-code}\ntype(inventaire)\n```\n:::\n\n\nIl est possible de mettre autant de clés que l'on souhaite dans un dictionnaire. En revanche, **les clés sont uniques**, afin d'identifier de manière certaine la valeur associée. Si l'on essaye de définir un dictionnaire avec une clé dupliquée, Python ne renvoie pas d'erreur, mais seule la dernière clé dupliquée est prise en compte.\n\n::: {#385a546a .cell execution_count=3}\n``` {.python .cell-code}\ninventaire = {'cafe': '500g', 'lait': '1,5L', 'cafe': '300g'}\ninventaire\n```\n:::\n\n\nQue peut contenir un dictionnaire ? Les clés peuvent être de différents types, mais on n'utilise en général que les chaînes de caractères ou bien les entiers. Les valeurs d'un dictionnaire peuvent quant à elles être n'importe quel type d'objet Python.\n\n### Utilisation\n\nComme les dictionnaires sont **non-ordonnés**, il n'y a pas de notion de position : on accède à une valeur par sa clé associée. Par exemple, pour récupérer la valeur (`'1,5L'`) associée à la clé `'lait'` : \n\n::: {#a2fc6266 .cell execution_count=4}\n``` {.python .cell-code}\ninventaire['lait']\n```\n:::\n\n\nDes couples clé-valeur supplémentaires peuvent être ajoutés à un dictionnaire déjà existant, en utilisant la syntaxe de l'assignation de variable.\n\n::: {#d9aaf50d .cell execution_count=5}\n``` {.python .cell-code}\ninventaire[\"céréales\"] = \"250g\"\ninventaire\n```\n:::\n\n\nA l'inverse des listes, les clés ne doivent pas nécessairement commencer à 0 et peuvent être n'importe quel nombre.\n\n::: {#342c2d4d .cell execution_count=6}\n``` {.python .cell-code}\ndic1 = {12: \"Averyon\", 33: \"Gironde\"}\n\nprint(\"Le département 33 est la \" + dic1[33])  # Concaténation de strings !\n```\n:::\n\n\nDe même, les valeurs peuvent être de différentes natures, y compris des conteneurs de données.\n\n::: {#2cfd4278 .cell execution_count=7}\n``` {.python .cell-code}\ndic2 = {\"gamme\" : \"do majeur\",\n        \"notes\": [\"do\", \"re\", \"mi\", \"fa\", \"sol\", \"la\", \"si\"]}\n\ndic2[\"notes\"]\n```\n:::\n\n\nLes dictionnaires peuvent notamment contenir d'autres dictionnaires. Cela les rend particulièrement adaptés pour représenter des structures hiérarchiques de données.\n\n::: {#70368bbe .cell execution_count=8}\n``` {.python .cell-code}\ncv = {\n    \"marc\": {\"poste\": \"manager\", \"experience\": 7, \"hobbies\": [\"couture\", \"frisbee\"]},\n    \"mirande\": {\"poste\": \"ingénieure\", \"experience\": 5, \"hobbies\": [\"trekking\"]}\n}\n\nprint(cv[\"marc\"])\nprint(cv[\"marc\"][\"hobbies\"][0])\n```\n:::\n\n\nRépétons-le : les dictionnaires n'ont pas de notion d'ordre. Ainsi, il n'y a pas de sens à requêter l'élément de position `0` d'un dictionnaire (sauf si la clé `0` existe..). Requêter une clé inexistante renvoie une erreur.\n\n::: {#66f30196 .cell execution_count=9}\n``` {.python .cell-code}\ndic1 = {12: \"Averyon\", 33: \"Gironde\"}\n\ndic1[0]\n```\n:::\n\n\n### Modification d'éléments\n\nIl est possible de modifier une valeur associée à une clé existante dans le dictionnaire. La nouvelle valeur peut être de type différent de l'originale.\n\n::: {#b8b83d30 .cell execution_count=10}\n``` {.python .cell-code}\ninventaire = {'cafe': '500g', 'lait': '1,5L'}\ninventaire['cafe'] = {'arabica': '250g', 'robusta': '400g'}\ninventaire\n```\n:::\n\n\n### Suppression d'éléments\n\nPour supprimer une clé (et la valeur associée), les mêmes opérations que celles qui permettent de supprimer des éléments dans une liste peuvent être utilisées.\n\n::: {#2648061a .cell execution_count=11}\n``` {.python .cell-code}\n# Avec l'opérateur `del`\ninventaire = {'cafe': '500g', 'lait': '1,5L'}\ndel inventaire['lait']\ninventaire\n```\n:::\n\n\n::: {#a2e78d54 .cell execution_count=12}\n``` {.python .cell-code}\n# Avec la méthode `pop`\ninventaire = {'cafe': '500g', 'lait': '1,5L'}\ninventaire.pop('lait')\ninventaire\n```\n:::\n\n\n### Quelques méthodes utiles\n\nNous avons vu précédemment que le fait de requêter une clé qui n'existe pas renvoyait une erreur. La méthode `.get()` permet de requêter une clé sans être sûr de son existence, puisqu'elle ne renvoie aucune erreur dans ce cas, mais l'objet `None`, que nous verrons dans un prochain tutoriel.\n\n::: {#da46397f .cell execution_count=13}\n``` {.python .cell-code}\ninventaire = {'cafe': '500g', 'lait': '1,5L'}\ninventaire.get('miel')\n```\n:::\n\n\nOn peut d'ailleurs spécifier une valeur par défaut lorsque la clé n'existe pas.\n\n::: {#848d24f7 .cell execution_count=14}\n``` {.python .cell-code}\ninventaire.get('miel', 'introuvable')\n```\n:::\n\n\nLes méthodes `.keys()`, `.values()` et `.items()` renvoient respectivement les clés, les valeurs, et les couples clés-valeurs d'un dictionnaire. Les objets retournés par ces méthodes sont un peu complexes, mais il est possible de les transformer en liste avec la fonction `list` pour pouvoir les requêter par position.\n\n::: {#f694196f .cell execution_count=15}\n``` {.python .cell-code}\ncv = {\n    \"marc\": {\"poste\": \"manager\", \"experience\": 7, \"hobbies\": [\"couture\", \"frisbee\"]},\n    \"mirande\": {\"poste\": \"ingénieure\", \"experience\": 5, \"hobbies\": [\"triathlon\"]}\n}\n\nlist(cv.keys())\n```\n:::\n\n\n::: {#8d0c4ea8 .cell execution_count=16}\n``` {.python .cell-code}\nlist(cv.values())\n```\n:::\n\n\n::: {#e737e1b0 .cell execution_count=17}\n``` {.python .cell-code}\nlist(cv.items())\n```\n:::\n\n\n## Sets\n\n### Définition\n\nLes sets sont des **collections non-ordonnées d'éléments uniques**. En cela, ils peuvent être vus comme des dictionnaires sans valeurs, dont on n'aurait conservé que les clés (uniques par définition dans un dictionnaire). Une autre analogie est celle des ensembles mathématiques, dont les éléments sont également non-ordonnés et uniques.\n\nDu fait de leur proximité avec les dictionnaires, les sets sont également définis par des accolades `{}`.\n\n::: {#653b809b .cell execution_count=18}\n``` {.python .cell-code}\nx = {3, 2, 1}\nx\n```\n:::\n\n\n::: {#1281c27a .cell execution_count=19}\n``` {.python .cell-code}\ntype(x)\n```\n:::\n\n\nDe la même manière que les dictionnaires, les sets sont **non-ordonnés**, il n'y a donc pas de notion de position. Demander l'élément de position `i`, comme dans une liste, renvoie une erreur.\n\n::: {#719926f5 .cell execution_count=20}\n``` {.python .cell-code}\nx = {3, 2, 1}\nx[0]\n```\n:::\n\n\n### Modification d'éléments\n\nIl est possible d'ajouter un élément à un set via la méthode `add`.\n\n::: {#06ae910f .cell execution_count=21}\n``` {.python .cell-code}\nx = {3, 2, 1}\nx.add(\"4\")\nx\n```\n:::\n\n\nAjouter un élément déjà existant ne change rien par définition.\n\n::: {#aba98956 .cell execution_count=22}\n``` {.python .cell-code}\nx = {3, 2, 1}\nx.add(2)\nx\n```\n:::\n\n\nIl est possible de retirer un élément d'un set via la méthode `remove`.\n\n::: {#43a0ccba .cell execution_count=23}\n``` {.python .cell-code}\nx = {3, 2, 1}\nx.remove(2)\nx\n```\n:::\n\n\n### Utilisation\n\nLes sets ne sont pas très souvent utilisés en pratique, mais ils s'avèrent bien utiles dans certaines situations précises. Du fait de l'unicité des éléments qu'ils contiennent, les sets permettent simplement et efficacement de supprimer les doublons dans un conteneur séquentiel, comme une liste.\n\n**Déduplication**\n\nSupposons que l'on veut supprimer les doublons dans une liste donnée. Par définition, le fait de transformer une liste en set supprime les doublons. Cependant, on a généralement envie de revenir à une liste, dans la mesure où les sets n'offrent pas la même flexibilité que les listes (par exemple, la possibilité de trouver un élément par position). Il est donc fréquent de faire la chaîne d'opération `list -> set -> list` pour dédupliquer une liste.\n\n::: {#05d898b2 .cell execution_count=24}\n``` {.python .cell-code}\nl = [1, 2, 3, 3, 2, 1]\nl_dedup = list(set(l))\nl_dedup\n```\n:::\n\n\n**Opérations ensemblistes**\n\nComme les sets représentent programmatiquement les ensembles mathématiques, il n'est pas étonnant qu'ils permettent de réaliser des opérations ensemblistes élémentaires. Par exemple, l'union et l'intersection.\n\n::: {#9800e5d6 .cell execution_count=25}\n``` {.python .cell-code}\nl1 = [5, 3, 2, 3, 3, 5, 8, 9]\nl2 = [3, 7, 0, 0, 1, 9, 4, 6]\n```\n:::\n\n\n::: {#312d1143 .cell execution_count=26}\n``` {.python .cell-code}\n# Union : éléments soit dans l1, soit dans l2, soit dans les deux\nl_union = list(set(l1) | set(l2))\nl_union\n```\n:::\n\n\n::: {#b608f3c2 .cell execution_count=27}\n``` {.python .cell-code}\n# Intersection : éléments à la fois dans l1 et dans l2\nl_inter = list(set(l1) & set(l2))\nl_inter\n```\n:::\n\n\n**Tests d'appartenance**\n\nLes sets sont également très utilisés pour réaliser des tests d'appartenance, dans la mesure où ils offrent de bien meilleures performances que les listes pour ce type de test.\n\nLa notion de test fera l'objet d'un prochain tutoriel. Pour l'heure, retenons qu'un test d'appartenance du type \"est-ce que l'élément `a` est dans la liste `l`\" s'écrit en Python `a in l` et renvoie `True` ou `False` selon que `a` est effectivement présent dans la liste `l` ou non.\n\n::: {#699fcc85 .cell execution_count=28}\n``` {.python .cell-code}\nl = [1, 2, 3]\n2 in l\n```\n:::\n\n\n::: {#c8644b89 .cell execution_count=29}\n``` {.python .cell-code}\n4 in l\n```\n:::\n\n\nMaintenant, imaginons que nous réalisions ce test sur une liste contenant des millions d'éléments. En exagérant, l'interpréteur Python devrait alors parcourir tous les éléments de la liste un à un jusqu'à trouver l'élément en question, ce qui peut prendre très longtemps. \n\nA l'inverse, comme les éléments d'un set sont uniques, Python peut facilement garder en mémoire la liste des éléments uniques contenus dans le set, et donc conclure très rapidement le test. Nous verrons une comparaison des performances dans un exercice de fin de tutoriel.\n\nNB : l'implémentation informatique des notions évoquées ci-dessus s'appelle une \"table de hachage\" (*hash table*). Le lecteur intéressé pourra trouver plus d'informations à propos de cette structure de données [ici](http://mpechaud.fr/scripts/donnees/tablesdehachage.html).\n\n## Exercices\n\n### Questions de compréhension\n\n- 1/ Peut-on accéder au `i`ième élément d'un dictionnaire ? d'un set ?\n- 2/ Quels types d'objets peuvent être utilisés comme clés d'un dictionnaire ? Comme valeurs ?\n- 3/ Pour quels types de données a-t-on intérêt à utiliser un dictionnaire ?\n- 4/ Un dictionnaire peut-il avoir des doublons dans ses clés ?\n- 5/ Pourquoi peut-on dire qu'un set est un dictionnaire particulier ?\n- 6/ Pourquoi les sets sont-ils utilisés pour dédupliquer des listes ?\n- 7/ Pourquoi les sets sont-ils plus pertinents que les listes pour réaliser des tests d'appartenance ?\n\n::: {#0f7f93dd .cell execution_count=30}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#e34f25f7 .cell execution_count=31}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 3-20 solutions.py\n```\n:::\n\n\n### Exercice\n\nSoit le dictionnaire défini dans la cellule ci-dessous.\n\nAffichez à l'aide d'opérations `print` : \n- la liste des noms des différentes classes\n- la note de Miranda en histoire\n- la liste des notes obtenues par Hypolyte\n- la liste des noms des élèves de la 6emeB\n- la liste des matières enseignées en 6eme A\n- la liste de toutes les matières enseignées\n- la liste des notes obtenues par les filles des deux classes\n\n::: {#4ed6132f .cell execution_count=32}\n``` {.python .cell-code}\nresultats = {\n    \"6emeA\": {\"Miranda\" : {\"notes\": {\"physique\": 16, \"histoire\": 12}},\n              \"Celestin\": {\"notes\": {\"physique\": \"absent\", \"histoire\": 18}}\n             },\n    \"6emeB\": {\"Hypolyte\": {\"notes\": {\"maths\": 11, \"anglais\": 0}},\n              \"Josephine\": {\"notes\": {\"maths\": 16, \"anglais\": 20}}\n             }\n}\n```\n:::\n\n\n::: {#06f54423 .cell execution_count=33}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#8147b304 .cell execution_count=34}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 24-38 solutions.py\n```\n:::\n\n\n### Exercice\n\nDans les tutoriels précédents, nous avons vu la fonction `len`, qui permet de compter le nombre d'éléments d'une séquence. Est-ce que cette fonction fonctionne avec les dictionnaires ? Que compte-t-elle alors ?\n\n::: {#28facf0a .cell execution_count=35}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#3c134c94 .cell execution_count=36}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 42-50 solutions.py\n```\n:::\n\n\n### Exercice\n\nNous avons vu qu'on pouvait supprimer une clé d'un dictionnaire de deux manières différentes :\n- avec l'opérateur `del` : `del mon_dict[clé]`\n- avec la méthode `pop` : `mon_dict.pop(clé)`\n\nAu-delà de la syntaxe, quelles sont les deux différences majeures entre ces deux manières de supprimer une clé d'un dictionnaire ? N'hésitez pas à expérimenter avec des exemples de votre choix.\n\n::: {#2bf8636c .cell execution_count=37}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#5f3e0ca2 .cell execution_count=38}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 54-65 solutions.py\n```\n:::\n\n\n### Exercice\n\nEn exploitant le fait que la méthode `pop` utilisée pour supprimer une clé d'un dictionnaire renvoie la valeur associée à cette clé, proposez une méthode pour renommer une clé d'un dictionnaire en une seule opération.\n\n::: {#e42b22a1 .cell execution_count=39}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#1cc935b8 .cell execution_count=40}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 69-73 solutions.py\n```\n:::\n\n\n### Exercice\n\nSoit le dictionnaire suivant :\n\n`animaux = {'chats': 5, 'chiens': 12}`\n\nQue vont retourner les tests d'appartenance suivants ? Vérifiez vos prédictions.\n\n- `'chats' in animaux.keys()`\n\n- `'chats' in animaux.values()`\n\n- `'chats' in animaux`\n\n::: {#ff996009 .cell execution_count=41}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#2f52f0e5 .cell execution_count=42}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 77-91 solutions.py\n```\n:::\n\n\n### Exercice\n\nNous avons vu que l'opération `del` renvoyait une erreur lorsqu'on l'utilisait pour supprimer une clé inexistante d'un dictionnaire. A l'aide de vos nouvelles connaissances sur les tests d'appartenance, pouvez-vous imaginer une méthode (sans nécessairement l'implémenter) qui permettrait de traiter ce cas sans erreur ?\n\n::: {#46a36202 .cell execution_count=43}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#c7e99cfa .cell execution_count=44}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 95-104 solutions.py\n```\n:::\n\n\n### Exercice\n\nSoit la chaîne de caractères avec répétition suivante :\n\n`x = \"cdabcdabcdabcdabcdabcdabcdabcdabcdab\"`\n\nConstruisez une liste des caractères uniques se trouvant dans cette chaîne, classée par ordre alphabétique, soit :\n\n`l = ['a', 'b', 'c', 'd']`\n\nIndice : la procédure est semblable au fait de supprimer les doublons d'une liste.\n\n::: {#1b186f1c .cell execution_count=45}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#af30f795 .cell execution_count=46}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 108-111 solutions.py\n```\n:::\n\n\n### Exercice\n\nSoit les deux chaînes de caractères suivantes.\n\n`cyrano1 = 'C’est un roc ! … c’est un pic ! … c’est un cap !'`\n\n`cyrano2 = 'Que dis-je, c’est un cap ? … C’est une péninsule !'`\n\nQuestion 1 : trouvez les caractères qui apparaissent à la fois dans les deux chaînes.\n\nQuestion 2 : trouvez les caractères qui apparaissent dans au moins un des deux textes.\n\n::: {#86f0144f .cell execution_count=47}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#0221d681 .cell execution_count=48}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 115-126 solutions.py\n```\n:::\n\n\n### Exercice\n\nLe code ci-dessous génère une liste avec les lettres a, b, c et d répétées 1 million de fois. Ensuite, il réalise un test d'appartenance d'une lettre qui n'existe pas dans la liste, et calcule le temps mis par l'interpréteur Python pour réaliser le test.\n\nEn reprenant cette syntaxe, comparez le temps mis par le même test d'appartenance lorsqu'on transforme la liste en set au préalable.\n\n::: {#0d8b6526 .cell execution_count=49}\n``` {.python .cell-code}\nx = ['a', 'b', 'c', 'd'] * 1000000\nprint(x[:10])\n\n%time 'e' in x\n```\n:::\n\n\n::: {#83686fcd .cell execution_count=50}\n``` {.python .cell-code}\n# Testez votre réponse dans cette cellule\n```\n:::\n\n\n::: {#bb72bc97 .cell execution_count=51}\n``` {.python .cell-code}\n# Exécuter cette cellule pour afficher la solution\n%load -r 130-141 solutions.py\n```\n:::\n\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.11.4\n---\n",
    "supporting": [
      "tutorial_files"
    ],
    "filters": []
  }
}