{
  "hash": "0fcc616f980544a5ff764091ebe6b081",
  "result": {
    "markdown": "---\ntitle: \"Fonctions\"\nabstract: \"Rendre son code mieux structuré et plus lisible avec les fonctions.\"\nexecute:\n    echo: true\n    eval: false\n---\n\nDans les précédents tutoriels, nous avons étudié le fonctionnement des tests et des boucles, qui permettent de rédiger des programmes Python qui prennent des décisions automatisées. En pratique, un programme va généralement être constitué de différents blocs, qui exécutent chacun une action ou un groupe d'actions (ex : import des données, nettoyage des données, modélisation statistique, etc.). Par ailleurs, certaines de ces actions sont amenées à être répétées avec une légère différence au fil d'un programme (ex : importer plusieurs jeux de données différents). Il va être utile de modéliser chacune de ces actions par une **fonction**, sorte de mini-programme au sein du programme global. Utiliser des fonctions est une **bonne pratique** de programmation, dans la mesure où elles rendent plus explicite la structure logique du code et permettent de réduire la duplication de code.\n\n\n## Définition\n\n\nUne **fonction** peut être définie comme un bloc de code structuré qui : \n- prend un ensemble d'**arguments** (des objets Python) en entrée\n- effectue une **action spécifique** via un ensemble d'instructions\n- **renvoie** un résultat (un objet Python) en sortie\n\nNous avons déjà vu et utilisé un certains nombres de fonctions dans les tutoriels précédents (`range`, `len`, etc.). Nous avons également utilisé des **méthodes**, qui sont simplement des fonctions *attachées* à un type d'objet particulier. Utilisons une fonction bien connue pour illustrer leur fonctionnement général.\n\n::: {#fc9cd711 .cell execution_count=1}\n``` {.python .cell-code}\nlen('do re mi fa sol')\n```\n:::\n\n\nDans cet exemple, la fonction `len` :\n- prend un argument en entrée (une chaîne de caractères)\n- calcule le nombre de caractères présent dans cette chaîne\n- renvoie ce nombre en sortie\n\nL'\"ensemble d'instructions\" qui permettent de calculer la longueur de la chaîne n'est pas connu. En tant qu'utilisateur, on a seulement besoin de savoir ce que prend la fonction en entrée et ce qu'elle renvoie en sortie. Cela vaut pour les cas dans lesquels on utilise des fonctions natives de Python ou bien des fonctions issus de librairies Python auxquelles on fait confiance. On parle de \"boîtes noires\" pour caractériser de telles fonctions.\n\nEn pratique, on va vouloir définir ses propres fonctions pour structurer son code et le réutiliser dans les analyses. \n\n\n## Syntaxe\n\n\nL'instruction `def` permet de définir une fonction.\n\n::: {#ca3c75e9 .cell execution_count=2}\n``` {.python .cell-code}\ndef accueil(prenom):\n    msg = \"Salutations \" + prenom + \" !\"\n    return msg\n```\n:::\n\n\nAnalysons la syntaxe de la definition d'une fonction : \n- une instruction `def` qui :\n    - spécifie le nom de la fonction (ici, `accueil`)\n    - spécifie les arguments attendus entre parenthèse (ici, un seul argument : `prenom`)\n    - se termine par `:` comme les différentes instructions que nous avons vues\n- un ensemble d'opérations qui seront effectuées par la fonction, qui doivent être indentées d'un niveau par rapport à l'instruction `def`\n- une instruction `return`, qui spécifie ce que la fonction va renvoyer lorsqu'elle sera appelée (ici, le contenu de la variable `msg`).\n\n\nLe fait de **définir** une fonction comme ci-dessus revient à rendre disponible dans l'environnement Python le code de la fonction. Ce n'est que lorsque celle-ci est **appelée** dans le code, avec des arguments, que le code contenu est exécuté et produit un résultat.\n\n::: {#059fe642 .cell execution_count=3}\n``` {.python .cell-code}\naccueil(\"Miranda\")\n```\n:::\n\n\nComme expliqué en introduction, tout l'intérêt d'une fonction est de pouvoir réutiliser du code sans avoir à le dupliquer dans le programme.\n\n::: {#272b8ab0 .cell execution_count=4}\n``` {.python .cell-code}\naccueil(\"Romuald\")\n```\n:::\n\n\n## Passage d'arguments\n\n\n### Principe\n\n\nLorsqu'on appelle une fonction en lui spécifiant des arguments, on dit qu'on lui \"passe\" des arguments. Ces arguments deviennent alors des variables qui peuvent être utilisées dans le contexte de la fonction. A l'inverse d'une boucle `for` par exemple, les variables créées ne persistent pas après l'appel de la fonction\n\n::: {#60ec54f0 .cell execution_count=5}\n``` {.python .cell-code}\ndef addition(x, y):\n    return x + y\n```\n:::\n\n\n::: {#be0da5ff .cell execution_count=6}\n``` {.python .cell-code}\naddition(5, 3)\n```\n:::\n\n\n::: {#3208c48a .cell execution_count=7}\n``` {.python .cell-code}\nx  # La variable ne persiste pas en mémoire après l'appel de la fonction\n```\n:::\n\n\nNB : on verra plus en détails ce comportement plus loin dans le tutoriel, à travers les concepts de variables globales et de variables locales.\n\n\n### Nombre d'arguments\n\n\nLe nombre d'arguments que l'on peut passer à une fonction est variable. En toute rigueur, il est possible de définir une fonction qui n'a besoin d'aucun argument, même si c'est rarement utile en pratique.\n\n```{python} tags=[]\ndef neuf():\n    return 9\n```\n\n```{python} tags=[]\na = neuf()\na\n```\n\n### Passage par position et passage par mot-clé\n\n\nEn Python, les fonctions admettent deux modes de passage des arguments : \n- le **passage par position**, qui correspond à celui que nous avons vu dans tous les exemples précédents : les arguments sont passés à la fonction dans l'ordre dans lequel ils ont été définis, sans avoir à préciser le nom du paramètre.\n- le **passage par mot-clé** : on précise le nom du paramètre lors du passage de l'argument, ce qui permet de ne pas avoir à suivre l'ordre indiqué lors de la définition.\n\nIllustrons cette différence à partir d'une fonction qui réalise simplement une division.\n\n::: {#67ad6053 .cell execution_count=8}\n``` {.python .cell-code}\ndef division(x, y):\n    return x / y\n```\n:::\n\n\n::: {#1afa4c20 .cell execution_count=9}\n``` {.python .cell-code}\ndivision(4, 2)  # Passage par position\n```\n:::\n\n\n::: {#947f679a .cell execution_count=10}\n``` {.python .cell-code}\ndivision(x=4, y=2)  # Passage par mot-clé\n```\n:::\n\n\nDans le cas du passage par position, le respect de l'ordre est impératif.\n\n::: {#c1bf9d28 .cell execution_count=11}\n``` {.python .cell-code}\nprint(division(0, 5))\nprint(division(5, 0))\n```\n:::\n\n\nDans le cas du passage par mot-clé, l'ordre n'a plus d'importance.\n\n::: {#556ff8ed .cell execution_count=12}\n``` {.python .cell-code}\nprint(division(x=0, y=5))\nprint(division(y=5, x=0))\n```\n:::\n\n\n### Arguments obligatoires et arguments optionnels\n\n\nLorsqu'on définit une fonction, il est fréquent de vouloir faire cohabiter des arguments que doit absolument spécifier l'utilisateur, et des arguments optionnels qui spécifient un comportement par défaut de la fonction, mais peuvent également être modifiés si nécessaire. \n\nRegardons par exemple comment on peut modifier le comportement de la fonction `print` à l'aide d'un argument optionnel.\n\n::: {#23759021 .cell execution_count=13}\n``` {.python .cell-code}\nprint(\"bonjour\")\nprint(\"bonjour\")\n```\n:::\n\n\n::: {#acc33a9c .cell execution_count=14}\n``` {.python .cell-code}\nprint(\"bonjour\", end=' ')\nprint(\"bonjour\")\n```\n:::\n\n\nOn a modifié le comportement du premier appel à `print` via le paramètre optionnel `end`. Par défaut, cette valeur est fixée à `'\\n'`, soit un retour à la ligne. On l'a modifié dans la deuxième cellule à un espace, d'où la différence de résultat.\n\nCet exemple illustre également le lien entre le caractère obligatoire ou non d'un argument et sa modalité de passage :\n- en général, les **arguments obligatoires** sont **passés par position**. Ils peuvent également être passés par mot-clé, mais dans la mesure où ils sont \"attendus\", on les passe généralement par position pour être plus concis\n- les **arguments optionnels** doivent être **passés par mot-clé**, afin de bien marquer qu'on modifie le comportement par défaut de la fonction\n\n\nComment spécifier qu'un argument est optionnel lorsqu'on définit une fonction soi-même ? Simplement en spécifiant une valeur par défaut de l'argument. Par exemple, construisons une fonction qui concatène deux chaînes de caractères, et laisse à l'utilisateur l'option de spécifier un séparateur.\n\n::: {#64a7029f .cell execution_count=15}\n``` {.python .cell-code}\ndef concat_string(str1, str2, sep=''):\n    return str1 + sep + str2\n```\n:::\n\n\n::: {#ccd7803f .cell execution_count=16}\n``` {.python .cell-code}\nconcat_string('bonjour', 'bonjour')  # Comportement par défaut\n```\n:::\n\n\n::: {#20bf358d .cell execution_count=17}\n``` {.python .cell-code}\nconcat_string('bonjour', 'bonjour', sep=', ')  # Comportement modifié\n```\n:::\n\n\nCet exemple illustre également la règle lorsqu'on a un mélange d'arguments positionnels et par mot-clé : **les arguments positionnels doivent toujours être placés avant les arguments par mot-clé**.\n\n\n## Renvoi de résultats\n\n\n### Principe\n\n\nOn a vu :\n- que toute fonction renvoie un résultat en sortie\n- que l'instruction `return` permet de spécifier ce résultat\n\nLorsque la fonction est appelée, elle est évaluée à la valeur spécifiée par `return`, et cette valeur peut alors être récupérée dans une variable et utilisée dans des calculs ultérieurs, et ainsi de suite.\n\n::: {#4a676e99 .cell execution_count=18}\n``` {.python .cell-code}\ndef division(x, y):\n    return x / y\n```\n:::\n\n\n::: {#9728bea9 .cell execution_count=19}\n``` {.python .cell-code}\na = division(4, 2)\nb = division(9, 3)\ndivision(a, b)  # 2 / 3\n```\n:::\n\n\nRemarque importante : **lorsqu'une instruction return est atteinte dans une fonction, le reste de la fonction n'est pas exécuté**.\n\n::: {#b1e65d8b .cell execution_count=20}\n``` {.python .cell-code}\ndef test(x):\n    return x\n    print(\"vais-je être affiché ?\")\n    \ntest(3)\n```\n:::\n\n\n### La valeur `None`\n\n\nUne fonction renvoie nécessairement un résultat lorsqu'elle est appelée... mais que se passe-t-il si l'on ne spécifie pas d'instruction `return` ?\n\n::: {#fc6ca803 .cell execution_count=21}\n``` {.python .cell-code}\ndef accueil(prenom):\n    print(\"Salutations \" + prenom + \" !\")\n    \nx = accueil(\"Léontine\")\nprint(x)\nprint(type(x))\n```\n:::\n\n\nComme attendu, la fonction a imprimé un message de bienvenue dans la console. Mais on n'a pas spécifié de valeur à retourner. Comme un objet doit malgré tout être retourné par définition, Python renvoie la valeur `None`, qui est un objet particulier, de type `NoneType`, et qui représente l'absence de valeur. Son seul intérêt est de bien marquer la différence entre une valeur réelle et l'absence de valeur.\n\nPour tester si un objet a pour valeur `None`, on utilise une syntaxe particulière : \n\n::: {#f299cc4b .cell execution_count=22}\n``` {.python .cell-code}\nx is None  # et non pas x == None\n```\n:::\n\n\n### Renvoyer plusieurs résultats\n\n\nUne fonction renvoie par définition **un** résultat, qui peut être tout objet Python. Comment faire si l'on souhaite renvoyer plusieurs résultats ? On peut simplement enregistrer les différents résultats dans un conteneur (liste, tuple, dictionnaire, etc.), qui peut lui contenir un grand nombre d'objets.\n\nEn pratique, il est très fréquent de renvoyer un *tuple* lorsque l'on souhaite renvoyer plusieurs objets. En effet, les *tuples* ont la propriété de *tuple unpacking*, que nous avons vues à plusieurs reprises dans les précédents tutoriels. Cette propriété rend possible une syntaxe très pratique et élégante pour l'assignation des résultats d'une fonction à des variables.\n\n::: {#e6af0852 .cell execution_count=23}\n``` {.python .cell-code}\ndef puissances(x):\n    return x**2, x**3, x**4\n\na, b, c = puissances(2)\n\nprint(a)\nprint(b)\nprint(c)\n```\n:::\n\n\n## Variables locales et variables globales\n\n\nNous avons vu en introduction que les fonctions pouvaient être vues comme des mini-programmes dans un programme global. Cette interprétation nous donne l'occasion d'aborder rapidement la notion de *scope* (contexte) en Python. Un *scope* est une sorte de conteneur à objets Python, auxquels il est possible d'accéder seulement dans le cadre de ce *scope*. \n\nTous les objets (variables, fonctions, etc.) que l'on définit lors d'une session Python sont enregistrés dans le ***scope* global** de Python. Ces objets peuvent alors être accédés à n'importe quel endroit du programme, y compris au sein d'une fonction. Lorsque c'est le cas, on parle de **variables globales**.\n\n::: {#ba3db39e .cell execution_count=24}\n``` {.python .cell-code}\nx = 5  # variable globale\n\ndef ajoute(y):\n    return x + y\n\najoute(6)\n```\n:::\n\n\nLa variable `x` n'a pas été passée en argument à la fonction `ajoute` ni été définie dans le cadre de cette fonction. Pourtant, on peut l'appeler au sein de la fonction. Cela permet de partager des éléments entre plusieurs fonctions. \n\n\nEn revanche, les arguments passés à une fonction ou bien les variables définies dans le cadre d'une fonction sont des **variables locales** : elles n'existent que dans le contexte spécifique de la fonction, et ne peuvent pas être réutilisées une fois que celle-ci s'est exécutée.\n\n::: {#2a517bc3 .cell execution_count=25}\n``` {.python .cell-code}\ndef ajoute(y):\n    z = 5  # variable locale\n    return z + y\n\najoute(6)\nprint(z)\n```\n:::\n\n\nAu sein d'un contexte donné, chaque variable est unique. En revanche, il est possible d'avoir des variables qui portent le même nom dans des contextes différents. Regardons par exemple ce qui se passe lorsque l'on crée une variable dans le contexte d'une fonction, alors qu'elle existe déjà dans le contexte global.\n\n::: {#5eb5077b .cell execution_count=26}\n``` {.python .cell-code}\nx = 5  # variable globale\n\ndef ajoute(y):\n    x = 10\n    return x + y\n\najoute(6)\n```\n:::\n\n\nC'est un bon exemple d'un principe plus général : **c'est toujours le contexte le plus local qui prime**. Lorsque Python effectue l'opération `x + y`, il va chercher les valeurs de `x` et de `y` d'abord dans le contexte local, puis, seulement s'il ne les trouve pas, dans le contexte supérieur -- en l'occurence, le contexte global.\n\n\nNB : on verra dans un prochain tutoriel sur les bonnes pratiques qu'**il est préférable de limiter au strict minimum l'utilisation de variables globales**, car elles réduisent la reproductibilité des analyses.\n\n\n## Exercices\n\n\n### Questions de compréhension\n\n\n- 1/ Pourquoi dit-on que l'utilisation de fonctions dans un programme est une bonne pratique de développement ?\n- 2/ Quelles sont les trois caractéristiques d'une fonction ?\n- 3/ Qu'est-ce qu'une fonction \"boîte noire\" ? A quelles autres fonctions s'oppose-t-elle ?\n- 4/ Que se passe-t-il quand on définit une fonction ? Et quand on l'appelle ?\n- 5/ Combien d'arguments peut-on passer à une fonction ?\n- 6/ Quelles sont les deux modalités de passage d'arguments à une fonction ?\n- 7/ Quelle est l'utilité de passer des arguments optionnels à une fonction ?\n- 8/ Dans quel ordre doivent être passés les arguments d'une fonction si celle-ci a à la fois des arguments obligatoires et optionnels ?\n- 9/ Existe-il des fonctions qui ne renvoient rien ?\n- 10/ Une fonction peut-elle renvoyer plusieurs objets ?\n- 11/ Que deviennent les variables du *scope* local d'une fonction une fois que la fonction a été appelée ?\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 3-38 solutions.py\n```\n\n### Fonction puissance\n\n\nCréer une fonction `puissance` qui prend en entrée deux nombres `x` et `y` et renvoie la fonction puissance $x^y$.\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 42-45 solutions.py\n```\n\n### Prédiction de valeurs retournées par des fonctions\n\n\nSoit `x = 5` et `y = 3` des arguments que l'on passe à chacune des fonctions définies dans la cellule suivante. Prédire ce que vont retourner les fonctions (valeur et `type` de l'objet), et vérifier vos réponses.\n\n::: {#49a8c818 .cell execution_count=27}\n``` {.python .cell-code}\ndef f1(x):\n    return x\n\ndef f2(x):\n    return ''\n\ndef f3(x):\n    print(\"Hello World\")\n    \ndef f4(x, y):\n    print(x + y)\n    \ndef f5(x, y):\n    x + y\n    \ndef f6(x, y):\n    if x >= 3 and y < 9:\n        return 'test ok'\n    else:\n        return 'test not ok'\n    \ndef f7(x, y):\n    return f6(2, 8)\n\ndef f8(x, y, z):\n    return x + y + z\n\ndef f9(x, y, z=5):\n    return x + y + z\n```\n:::\n\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 49-65 solutions.py\n```\n\n### Variables globales et variables locales\n\n\nQue vaut la variable `total` dans le programme suivant ?\n\n```{python} tags=[]\nz = 3\n\ndef f1(x, y):\n    z = 5\n    return x + y + z\n\ndef f2(x, y, z=1):\n    return x + y + z\n\ndef f3(x, y):\n    return x + y + z\n\ntotal = f1(2, 3) + f2(3, 1) + f3(1, 0)\nprint(total)\n```\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 69-93 solutions.py\n```\n\n### Calculatrice\n\n<!-- #region tags=[] -->\nEcrire une fonction `calculatrice` qui :\n- prend deux nombres en entrée\n- renvoie l'addition, la soustraction, la multiplication et la division de ces deux nombres en sortie\n\nUtiliser la propriété de *tuple unpacking* pour assigner les résultats à des variables en une seule ligne.\n<!-- #endregion -->\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 97-101 solutions.py\n```\n\n### Dédupliquer une liste\n\n<!-- #region tags=[] -->\nEcrire une fonction qui :\n- prend en entrée une liste d'éléments quelconques\n- renvoie une nouvelle liste constituée des éléments uniques de la liste initiale\n- permet via un paramètre optionnel de trier ou non la liste finale par ordre alphanumérique. Le comportement par défaut doit être de ne pas trier.\n\nIndice : la procédure a été abordée dans le tutoriel sur les dictionnaires et les sets.\n<!-- #endregion -->\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 105-113 solutions.py\n```\n\n### Multiplier les éléments d'une liste\n\n<!-- #region tags=[] -->\nEcrire une fonction qui :\n- prend en entrée une liste de nombres\n- imprime : \"Il y a $n$ nombres dans la liste.\" avec $n$ le nombre effectif\n- multiplie tous les éléments de la liste (sans utiliser de fonction pré-codée)\n- retourne le résultat\n<!-- #endregion -->\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 117-125 solutions.py\n```\n\n### Variance dans une population et variance dans un échantillon\n\n<!-- #region tags=[] -->\nDans un exercice du précédent tutoriel, nous avons codé \"à la main\" le calcul de la variance d'une liste de nombres, à partir de la formule : $$\\sigma^2 = {\\frac {1}{n}}\\sum_{i=1}^{n} (x_{i}-\\bar{x})^2$$\n\nEn toute rigueur, cette formule est valide lorsqu'on calcule la **variance en population complète**. Si l'on n'observe qu'un échantillon de la population, on ne calcule pas la variance mais on l'estime, et il faut alors utiliser la formule suivante pour obtenir un **estimateur sans biais de la vraie variance** : $$s^2 = {\\frac {1}{n-1}}\\sum_{i=1}^{n} (x_{i}-\\bar{x})^2$$.\n\nPour tenir compte de cette distinction :\n- coder une fonction `mean`  qui calcule la moyenne comme dans l'exercice du tutoriel précédent\n- coder une fonction `var`  qui calcule la variance comme dans l'exercice du tutoriel précédent (en appelant la fonction `mean` pour calculer la moyenne)\n- modifier la fonction `var` afin de permettre à l'utilisateur de choisir la méthode de calcul via un paramètre optionnel `mode` (valeur par défaut : 'population' pour le calcul via la formule en population ; valeur alternative : 'sample' pour le calcul via la formule en échantillon)\n\nComparer les valeurs obtenues dans les deux cas avec ce que renvoie la fonction *black box* `var` de la librarie `numpy` (cf. corrigé de l'exercice du tutoriel précédent pour la syntaxe, et voir la [doc](https://numpy.org/doc/stable/reference/generated/numpy.var.html) de la fonction et en particulier le paramètre `ddof` pour faire varier la méthode de calcul).\n<!-- #endregion -->\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 129-158 solutions.py\n```\n\n### Fonctions récursives : factorielle\n\n<!-- #region tags=[] -->\nLes fonctions récursives sont des fonctions qui s'appellent elles-mêmes dans le corps de la fonction, ce qui entraîne des appels infinis jusqu'à atteindre un critère d'arrêt.\n\nUn bon exemple de fonction récursive est la fonction qui calcule la factorielle d'un entier. La factorielle d'un entier naturel $n$ est le produit des nombres entiers strictement positifs inférieurs ou égaux à n. Par exemple : $5! = 5*4*3*2*1 = 120$.\n\nCoder cette fonction et vérifier qu'elle fonctionne correctement.\n<!-- #endregion -->\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 162-169 solutions.py\n```\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.11.4\n---\n",
    "supporting": [
      "tutorial_files"
    ],
    "filters": []
  }
}