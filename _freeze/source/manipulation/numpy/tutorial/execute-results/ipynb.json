{
  "hash": "9ead648348358b2edd18c2ef270067dc",
  "result": {
    "markdown": "---\ntitle: \"Calcul numérique avec NumPy\"\nabstract: \"Manipulation des arrays et des fonctions de NumPy, la librairie de référence pour le calcul numérique.\"\nexecute:\n    echo: true\n    eval: false\n---\n\nEn tant que statisticien, on est fréquemment amené à manipuler des séries de valeurs numériques, à partir desquelles on réalise diverses opérations mathématiques, des plus usuelles (moyenne, variance, etc.) aux plus complexes. On peut, comme on l'a fait dans les précédents tutoriels, utiliser les objets fondamentaux de Python, et en particulier les listes, pour réaliser de telles opérations. En pratique, on préférera utiliser la **librairie de référence pour le calcul scientifique**, `NumPy`, qui fournit à la fois des objets (les ***arrays***) et des fonctions qui vont grandement nous simplifier la vie pour effectuer tous nos calculs en Python de manière efficiente.\n\n\n## NumPy \n\n\nOn commence par importer la librairie `NumPy`. Comme expliqué dans un précédent tutoriel, l'usage est courant est de lui attribuer l'alias `np`. \n\n::: {#f02551dd .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n```\n:::\n\n\n### Pourquoi utiliser NumPy ?\n\n\nPlutôt que de présenter de manière abstraite les avantages de `NumPy`, illustrons ces derniers à travers un exemple simple : la multiplication terme à terme de deux vecteurs. \n\nOn génère deux vecteurs contenant les entiers allant de $0$ à $99999$, que l'on multiplie terme à terme. On effectue cela d'abord via les listes Python (fonction `mult_list`), puis à l'aide de `NumPy` (fonction `mult_np`), et on compare les performances des deux méthodes.\n\n::: {#8b489ded .cell execution_count=2}\n``` {.python .cell-code}\ndef mult_list(n):\n    a = range(n)\n    b = range(n)\n\n    c = []\n    for i in range(len(a)):\n        mult = a[i] * b[i]\n        c.append(mult)\n        \n    return c\n\ndef mult_np(n):\n    a_np = np.arange(n)\n    b_np = np.arange(n)\n    \n    c_np = a_np * b_np\n\n    return c_np\n```\n:::\n\n\n::: {#b1a5bcac .cell execution_count=3}\n``` {.python .cell-code}\nn = 100000\n```\n:::\n\n\n::: {#89fff155 .cell execution_count=4}\n``` {.python .cell-code}\n# Vérification de la cohérence sur les 10 premiers éléments\nprint(mult_list(n)[:10])\nprint(mult_np(n)[:10])\n```\n:::\n\n\n::: {#dafd8495 .cell execution_count=5}\n``` {.python .cell-code}\n%%timeit -n10\n\nmult_list(n)  # Performance de la méthode liste\n```\n:::\n\n\n::: {#92f10918 .cell execution_count=6}\n``` {.python .cell-code}\n%%timeit -n10\n\nmult_np(n)  # Performance de la méthode NumPy\n```\n:::\n\n\nCet exemple illustre à lui seul les principaux avantages de `NumPy` pour le calcul scientifique : \n- les calculs sont **vectorisés** : multiplier deux *arrays* va naturellement effectuer la multiplication terme à terme, contrairement aux listes qui ne permettent pas cette opération. Les personnes travaillant avec `R` retrouveront là une propriété familière et bien pratique.\n- conséquence de la vectorisation, **la syntaxe est plus légère et plus claire** : on voit directement l'opération qui est effectuée et on limite ainsi les risques d'erreur ;\n- les calculs sont automatiquement **optimisés** par `NumPy` (via l'appel à du code `C` pré-compilé), réduisant très largement le temps mis par les opérations mathématiques (divisé par un facteur 10 dans notre exemple).\n\n\n### Les *array* NumPy \n\n\n#### Définition\n\n\nToute la librairie `NumPy` est basée sur un objet fondamental : l'*array*. Un *array* est un objet qui contient une séquence de données, et présente deux caractéristiques principales :\n- les données contenues dans un *array* doivent être de **type homogène**, là où une même liste peut contenir des objets de différente nature ;\n- un *array* a une **taille fixée** à sa création, là où une liste peut grandir dynamiquement (en ajoutant des éléments via la méthode `append` par exemple).\n\nCe sont en grande partie ces deux contraintes qui rendent possible les gains de performance et la syntaxe lisible qu'offre `NumPy`.\n\n\n#### Création\n\n\nIl existe différentes manières de créer un *array*. La plus standard est de convertir une liste en *array* via la fonction *array* de `NumPy`.\n\n::: {#99c7fa22 .cell execution_count=7}\n``` {.python .cell-code}\nl = [1, 2, 3]\na = np.array(l)\nprint(a)\n```\n:::\n\n\nA première vue, la fonction `print` renvoie une représentation identique à celle d'une liste. Vérifions le type de notre objet. \n\n::: {#59caaa26 .cell execution_count=8}\n``` {.python .cell-code}\ntype(a)\n```\n:::\n\n\nL'objet est de type `ndarray`, qui est le type standard correspondant à un *array* `NumPy`. \n\nOn a vu qu'un *array* avait pour propriété de contenir des données de type homogène ; en l'occurrence, des entiers. On peut vérifier le type des données contenues via l'attribut `dtype` d'un *array*.\n\n::: {#67d9aa28 .cell execution_count=9}\n``` {.python .cell-code}\na.dtype\n```\n:::\n\n\nMême si `NumPy` est avant tout une librairie dédiée au calcul numérique, il reste tout à fait possible de définir des `arrays` contenant des chaînes de caractères.\n\n::: {#c77e2bc3 .cell execution_count=10}\n``` {.python .cell-code}\nb = np.array(['1', 'tigre'])\nb.dtype\n```\n:::\n\n\nLe `dtype` par défaut des `arrays` contenant des chaînes de caractères est un peu particulier, mais cela n'a pas d'importance en pratique. Retenez simplement sa forme.\n\nEnfin, question importante : que se passe-t-il si l'on essaie de définir un *array* contenant des objets de types hétérogènes ?\n\n::: {#14bac30c .cell execution_count=11}\n``` {.python .cell-code}\nc = np.array([1, 2, '3'])\nprint(c)\nprint(c.dtype)\n```\n:::\n\n\nRéponse : tous les objets sont convertis en chaîne de caractères par défaut.\n\n\n#### Dimension\n\n\nLes *array* correspondent en fait à des tableaux de données, c'est à dire qu'ils peuvent être uni- ou multi-dimensionnels. Un *array* de dimension 1 ressemble à un vecteur (ou une liste), un *array* de dimension 2 ressemble à une matrice, et ainsi de suite. \n\nOn peut afficher le nombre de dimensions d'un *array* via l'attribut `ndim`.\n\n::: {#15327326 .cell execution_count=12}\n``` {.python .cell-code}\nc = np.array([1, 2, '3'])\nc.ndim\n```\n:::\n\n\nDe la même manière que l'on a créé un *array* de dimension 1 à partir d'une liste simple, on peut créer un *array* multi-dimensionnel à partir d'une liste de listes.\n\n::: {#bf904db0 .cell execution_count=13}\n``` {.python .cell-code}\nd = np.array([[1, 2, 3], [4, 5, 6]])\nprint(d)\n```\n:::\n\n\nOn a converti une liste contenant 2 sous-listes à 3 éléments chacune, ce qui donne un *array* à deux dimensions. Notons que l'appel de `print` affiche une matrice à deux lignes et trois colonnes.\n\n::: {#870dd428 .cell execution_count=14}\n``` {.python .cell-code}\nd.ndim\n```\n:::\n\n\nOn a bien affaire à un *array* à deux dimensions. Mais en pratique, lorsqu'on manipule des `arrays` multidimensionnels, on a aussi envie de connaître la *taille* de chacune des dimensions. En dimension 2, c'est le nombre de lignes et de colonnes. Pour cela, on utilise la méthode `shape`, qui renvoie un *tuple* contenant les tailles des différentes dimensions.\n\n::: {#cc5a82b7 .cell execution_count=15}\n``` {.python .cell-code}\nd.shape\n```\n:::\n\n\nLe premier chiffre donne le nombre de lignes, le second le nombre de colonnes. On reviendra par la suite sur l'ordre des dimensions à travers la notion d'*axis*.\n\n\n#### Indexation\n\n\nOn accède aux différents éléments d'un *array* de dimension 1 exactement de la même manière que ceux d'une liste.\n\n::: {#c64a81ef .cell execution_count=16}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5, 6])\n\nprint(a)\nprint()\nprint(a[1])\nprint()\nprint(a[2:5])\nprint()\nprint(a[-2])\n```\n:::\n\n\nPour un *array* multidimensionnel, il faut spécifier le ou les éléments voulus sur chacune des dimensions de l'*array*, en les séparant par des virgules. \n\n::: {#9158d443 .cell execution_count=17}\n``` {.python .cell-code}\nb = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n\nprint(b)\nprint()\nprint(b[1, 3])\nprint()\nprint(b[1:3, 1:3])\n```\n:::\n\n\nPour accéder à une ligne complète, on peut utiliser `:` sur la dimension des colonnes pour spécifier : \"toutes les colonnes\". Et inversement pour récupérer une colonne complète.\n\n::: {#c4234e45 .cell execution_count=18}\n``` {.python .cell-code}\nprint(b[1,:])\nprint()\nprint(b[:,2])\n```\n:::\n\n\n#### Modification d'éléments\n\n\nLes éléments d'un *array* peuvent être modifiés. On combine pour cela la syntaxe d'indexation vue précédemment avec l'opérateur d'assignation `=`.\n\n::: {#06ecc173 .cell execution_count=19}\n``` {.python .cell-code}\nb = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n\nb[1, 1] = 18\nprint(b)\n```\n:::\n\n\nOn peut également modifier des séries de nombres, voire des lignes/colonnes complètes, à condition d'assigner un élément de même taille.\n\n::: {#e9472471 .cell execution_count=20}\n``` {.python .cell-code}\nb = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n\nb[:, 2] = [-1, -1, -1]\nb\n```\n:::\n\n\nContrairement aux listes, on ne va généralement pas ajouter ou supprimer d'éléments à un *array*. La raison est que, comme indiqué précédemment, la taille d'un *array* est fixée à sa construction. \n\nSi l'on souhaite faire grandir un *array*, on va généralement le faire à partir d'une liste -- qui elle peut grandir -- que l'on convertit ensuite en *array*. \n\nSi l'on souhaite supprimer des éléments d'un *array*, on peut utiliser la syntaxe d'indexation étudiée dans la section précédente pour récupérer le sous-*array* qui nous intéresse, et assigner ce dernier à une nouvelle variable.\n\n\n#### Masques booléens\n\n\nUn gros avantage des *arrays* `NumPy` par rapport aux listes est qu'ils supportent les **masques booléens**, c'est à dire qu'on peut sélectionner des éléments d'un *array* en lui passant un *array* de même taille contenant des booléens.\n\n::: {#82800e01 .cell execution_count=21}\n``` {.python .cell-code}\na = np.array([1, 2, 3])\na[[True, True, False]]\n```\n:::\n\n\nCette propriété ouvre de nombreuses possibilités, dans la mesure où elle peut être combinée avec la propriété de vectorisation des *arrays*. Il devient ainsi très facile de **sélectionner des éléments selon des conditions**, même pour les *arrays* multidimensionnels.\n\n::: {#c18a982d .cell execution_count=22}\n``` {.python .cell-code}\nb = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\ncond = (b > 6) & (b != 10)\n\nprint(cond)\nprint()\nprint(b[cond])\n```\n:::\n\n\nEt l'on peut bien entendu exploiter ce mécanisme pour modifier des éléments selon une condition.\n\n::: {#063e24e2 .cell execution_count=23}\n``` {.python .cell-code}\nb[cond] = -1\nprint(b)\n```\n:::\n\n\nCe dernier exemple illustre par ailleurs une propriété importante en `NumPy` appelée ***broadcasting*** : lorsque l'on remplace plusieurs éléments d'un *array* par un élément de taille 1 (et non un *array* de même taille), tous les éléments sont remplacés par cette valeur.\n\n\n### Opérations mathématiques\n\n\n#### Arithmétique sur les *arrays*\n\n\nTout au début de ce tutoriel, nous avons vu que multiplier deux *arrays* via l'opérateur `*` effectuait une multiplication termes à termes des deux *arrays*, et ce de manière vectorisée. Les opérations élémentaires (`+`, `-`, `*` et `/`) s'appliquent de la même manière aux *arrays* multidimensionnels.\n\n::: {#a5e87f19 .cell execution_count=24}\n``` {.python .cell-code}\na = np.array([[1, 2, 2], [2, 2, 1]])\nb = np.array([[3, 3, 1], [1, 3, 3]])\n\na * b\n```\n:::\n\n\nNotons qu'on retrouve la propriété de *broadcasting* discutée dans la section précédente : lorsque l'on effectue une opération entre un *array* et un nombre de taille 1, l'opération est appliquée à chaque terme de l'*array*.\n\n::: {#d002ea19 .cell execution_count=25}\n``` {.python .cell-code}\na * 4\n```\n:::\n\n\n#### Algèbre linéaire\n\n\n`NumPy` permet de réaliser simplement et de manière efficiente des opérations d'algèbre linéaire sur les *arrays*. L'ensemble des fonctions disponibles sont présentées dans la [documentation officielle](https://numpy.org/doc/stable/reference/routines.linalg.html) (en Anglais).\n\nPar exemple, l'opérateur `@` permet de réaliser une multiplication matricielle (et non plus termes à termes comme le fait `*`).\n\n::: {#ecacf62c .cell execution_count=26}\n``` {.python .cell-code}\na = np.array([[1, 2, 3], [3, 2, 1]])\nb = np.array([[2, 3], [1, 3], [3, 1]])\n\na @ b\n```\n:::\n\n\n#### Fonctions mathématiques\n\n\n`NumPy` offre pléthore de fonctions [mathématiques](https://numpy.org/doc/stable/reference/routines.math.html) et [statistiques](https://numpy.org/doc/stable/reference/routines.statistics.html), comme `sum`, `mean`, `min`, `round`, `log`, etc. Leur application à des objets unidimensionnels ne pose pas de problème particulier.\n\n::: {#6b4b8724 .cell execution_count=27}\n``` {.python .cell-code}\nprint(np.log(12))\nprint()\nprint(np.min([1, 2, 3]))\nprint()\nprint(np.mean([1, 2, 3]))\n```\n:::\n\n\nEn revanche, dans le cas multidimensionnel, leur utilisation devient un peu plus subtile car on peut vouloir réaliser l'agrégation selon différentes dimensions. Si l'on ne spécifie rien, l'agrégation est effectuée sur tous les éléments de l'*array*.\n\n::: {#f3a849b9 .cell execution_count=28}\n``` {.python .cell-code}\na = np.array([[1, 2, 2], [2, 2, 1]])\n\nnp.sum(a)\n```\n:::\n\n\nMais comment faire si l'on veut sommer par ligne ? Ou bien par colonne ? C'est là qu'intervient un élément crucial et assez complexe des fonctions de `NumPy` : le paramètre `axis`, qui spécifie la dimension selon laquelle est effectuée l'opération.\n\nLorsqu'il n'est pas spécifié comme dans l'exemple précédent, il prend la valeur `None` par défaut.\n\n::: {#f0e6b56a .cell execution_count=29}\n``` {.python .cell-code}\na = np.array([[1, 2, 2], [2, 2, 1]])\n\nnp.sum(a, axis=None)  # idem que np.sum(a)\n```\n:::\n\n\nLa figure suivante permet de bien se représenter la manière dont fonctionnent les axes avec `NumPy`, afin de bien spécifier le sens attendu de l'agrégation.\n\n![axis](img/axes.png)\n\nAinsi, si l'on souhaite calculer la somme de chaque colonne par exemple, il faut agréger selon l'axe $0$.\n\n::: {#5f461a36 .cell execution_count=30}\n``` {.python .cell-code}\na = np.array([[1, 2, 2], [2, 2, 1]])\n\nnp.sum(a, axis=0)\n```\n:::\n\n\nEt inversement pour obtenir les sommes de chaque ligne.\n\n::: {#a2da692c .cell execution_count=31}\n``` {.python .cell-code}\nnp.sum(a, axis=1)\n```\n:::\n\n\nEnfin, notons que les fonctions mathématiques qui réalisent une agrégation sont généralement également disponibles comme *méthodes* d'un *array*. Elles fonctionnent de la même manière, au détail près qu'elles ne prennent pas l'*array* en argument dans la mesure où elles sont déjà \"attachées\" à celui-ci.\n\n::: {#a9c41b77 .cell execution_count=32}\n``` {.python .cell-code}\na.sum(axis=1)\n```\n:::\n\n\n### Conclusion\n\n\n`NumPy` est la librairie quasi-standard de calcul scientifique en Python. Elle est à privilégier dès lors que vous souhaitez effectuer des opérations sur des données numériques, *a fortiori* lorsqu'il s'agit d'opérations vectorisées et/ou mobilisant des objets multidimensionnels comme des matrices.\n\nLes possibilités offertes par `NumPy` sont gigantesques, et nous n'en avons vu qu'un aperçu. La [documentation officielle](https://numpy.org/doc/stable/user/) présente l'ensemble de ces possibilités. Cette [*cheat sheet*](http://datacamp-community-prod.s3.amazonaws.com/ba1fe95a-8b70-4d2f-95b0-bc954e9071b0) peut également s'avérer utile en cas d'oubli. Nous verrons également des fonctions supplémentaires à travers les exercices de fin de chapitre.\n\n\n## Exercices\n\n\n### Questions de compréhension\n\n\n- 1/ Quels sont les principaux avantages de `NumPy` ?\n- 2/ Quelles sont les deux caractéristiques principales d'un *array* `NumPy` ?\n- 3/ Que se passe-t-il si l'on essaie de définir un *array* contenant des objets de types hétérogènes ?\n- 4/ Quelle est la principale méthode pour créer un *array* ?\n- 5/ Quelles informations contient l'attribut `shape` d'un array ?\n- 6/ Peut-on ajouter un élément à un *array* ? Supprimer un élément ?\n- 7/ Qu'est-ce qu'un masque booléen et à quoi cela sert-il ?\n- 8/ Qu'est-ce que la propriété de *broadcasting* ?\n- 9/ A quoi sert le paramètre `axis` des fonctions mathématiques de `NumPy` ?\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 3-32 solutions.py\n```\n\n### Exercice : sélectionner des éléments dans un vecteur\n\n\nUn vecteur comprenant les entiers compris entre 10 et 20 est défini dans la cellule suivante. En utilisant l'indexation des *arrays* `NumPy` :\n- sélectionner les éléments aux positions 1, 3 et 4\n- sélectionner tous les éléments sauf le premier\n- sélectionner tous les éléments sauf le premier et le dernier\n- sélectionner les 3 premiers éléments\n- sélectionner les 5 derniers éléments\n- sélectionner tous les éléments pairs\n- sélectionner tous les éléments en les triant dans l'ordre inverse (NB : la fonction `np.flip` permet de faire la même chose)\n\n```{python} tags=[]\nX = np.arange(10, 21)\n\nprint(X)\n```\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 36-44 solutions.py\n```\n\n### Exercice : sélectionner des éléments dans une matrice\n\n\nUne matrice de taille 5x5 comprenant tous les entiers compris entre 0 et 24 est définie dans la cellule suivante. En utilisant l'indexation des *arrays* `NumPy` :\n- sélectionner la valeur $19$\n- sélectionner la 2ème ligne\n- sélectionner la 4ème colonne\n- sélectionner la sous-matrice 3x3 centrale\n- sélectionner les éléments diagonaux (NB : la fonction `np.diag` permet de réaliser la même opération de manière beaucoup plus simple)\n\n::: {#050ea872 .cell execution_count=33}\n``` {.python .cell-code}\nY = np.arange(0, 25).reshape((5, 5))\n\nprint(Y)\n```\n:::\n\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 48-54 solutions.py\n```\n\n### Exercice : un peu de calcul\n\n\nDeux matrices carrées de taille 3x3 sont définies sous forme d'*arrays* `NumPy` dans la cellule suivante. A partir de ces matrices, réaliser les opérations mathématiques suivantes :\n- multiplier tous les éléments de `X` par 3\n- diviser les éléments de `Y` par ceux de `X`\n- passer tous les éléments de `Y` au `log`\n- passer tous les éléments de `X` au carré\n- faire une multiplication matricielle de `X` et `Y`\n- transposer la matrice `Y`\n\nNB : vous pourrez trouver les fonctions nécessaires dans la [documentation](https://numpy.org/doc/stable/reference/routines.math.html) ou via un moteur de recherche.\n\n::: {#ea114157 .cell execution_count=34}\n``` {.python .cell-code}\nX = np.array([[1,2,3],\n              [4,5,6],\n              [7,8,9]])\n\nY = np.array([[10,11,12],\n              [13,14,15],\n              [16,17,18]])\n```\n:::\n\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 58-76 solutions.py\n```\n\n### Exercice : initialisation d'*arrays* de diverses natures\n\n\nDans le tutoriel, nous avons vu que la méthode standard pour créer un *array* `NumPy` consistait à initialiser une liste, que l'on convertit ensuite en *array*. On peut également utiliser des fonctions natives de `NumPy` qui créent des *array* d'une taille donnée, contenant des valeurs basiques (ex : valeurs \"quasi-vides\", zéros, uns, une valeur spécifiée par l'utilisateur, etc.).\n\nPar exemple, pour créer une matrice à 3 lignes et deux colonnes contenant des zéros, la syntaxe est : \n\n::: {#3d12a475 .cell execution_count=35}\n``` {.python .cell-code}\nnp.zeros((3, 2))\n```\n:::\n\n\nEn vous référant à la [documentation](https://numpy.org/doc/stable/reference/routines.array-creation.html) de ces fonctions, générer :\n\n- un vecteur (array à 1 dimension), contenant 18 fois la valeur $1$ (fonction `np.ones`)\n- un array à 3 dimensions, respectivement de tailles 2, 3 et 5, contenant uniquement des zéros (fonction `np.zeros`)\n- une matrice (array à 2 dimensions), à 4 lignes et 3 colonnes, contenant uniquement la valeur 5 (fonction `np.full`)\n- une matrice identité de taille 5, i.e. une matrice à 5 lignes et 5 colonnes, contenant des $1$ sur sa diagonale et des $0$ partout ailleurs (fonction `np.eye`)\n- un vecteur contenant les entiers compris entre $0$ à $99$ inclus (fonction `np.arange`)\n- un vecteur contenant les entiers *pairs* compris entre $0$ à $99$ inclus (fonction `np.arange`)\n- un vecteur contenant 5 valeurs uniformément espacées entre $2$ et $3$ inclus (fonction `np.linspace`)\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 80-106 solutions.py\n```\n\n### Exercice : tirage d'un vecteur selon une loi normale\n\n\nEn vous référant à la [documentation](https://numpy.org/doc/stable/reference/random/generator.html) des fonctions de génération de nombres aléatoires de `NumPy`, générer un vecteur `X` de taille 10000, contenant des nombres tirés selon une loi normale de moyenne 0 et de variance 2.\n\nVérifiez ensuite à l'aide des fonctions mathématiques de `NumPy` que la moyenne et la variance de votre échantillon sont cohérents par rapport aux valeurs attendues.\n\nIndice : attention à la manière dont est spécifiée la variance dans la fonction `NumPy` de génération d'une loi normale. \n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 110-112 solutions.py\n```\n\n### Exercice : tirage d'une matrice selon une loi uniforme\n\n\nEn vous référant à la [documentation](https://numpy.org/doc/stable/reference/random/generator.html) des fonctions de génération de nombres aléatoires de `NumPy`, générer une matrice `U` de taille 1000 par 1000, contenant des nombres tirés selon une loi uniforme dans l'intervalle [-1, 1].\n\nEn utilisant la fonction `np.all` et un test booléen, vérifier que tous les nombres contenus dans `U` sont bien compris entre -1 et 1.\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 116-119 solutions.py\n```\n\n### Exercice : binariser une matrice de nombres\n\n\nOn peut parfois avoir besoin de binariser une matrice numérique, c'est à dire de fixer un seuil au delà duquel les valeurs numériques sont fixées à 1, et à 0 en-dessous. `NumPy` propose plusieurs méthodes pour réaliser une telle opération, nous allons en voir deux. \n\nDans la cellule suivante, une matrice `X` à 6 lignes et 6 colonnes est générée, qui comprend des entiers aléatoirement choisis entre 0 et 49. Vous devez binariser cette matrice de deux manières différentes **sans l'écraser** (i.e. la matrice binaire doit être assignée à une autre variable que `X` et `X` ne doit pas être modifiée) :\n- première méthode : en utilisant la fonction `np.zeros` et les masques booléens\n- seconde méthode : en utilisant la fonction `np.where` (cf. [doc](https://numpy.org/doc/stable/reference/generated/numpy.where.html))\n\n::: {#135c3786 .cell execution_count=36}\n``` {.python .cell-code}\nX = np.random.randint(0, 50, size=(6, 6))\n```\n:::\n\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 123-136 solutions.py\n```\n\n### Exercice : touché-coulé\n\n\nL'objectif de cet exercice est de programmer seulement à l'aide d'objets et de fonctions de `NumPy` un touché-coulé très basique. \n\nUne grille de 5x5 est définie dans la cellule suivante comme un *array*, les valeurs $1$ symbolisant la présence d'un bateau. Vous devez programmer une fonction `shoot` qui :\n- prend en input une coordonnée $x$ (indice de la ligne) et une cordonnée $y$ (indice de la colonne)\n- teste si au moins une valeur $1$ est présente dans la grille :\n  - si oui : \n    - s'il y a un bateau à l'adresse (x, y), remplacer la valeur $1$ par $2$ et `print` \"Touché !\"\n    - sinon, `print` \"Raté !\"\n  - si non :\n    - `print` \"Fin de partie !\"\n    \nPuis réalisez quelques tests pour vous assurer que votre fonction marche comme attendu.\n\n::: {#314bf429 .cell execution_count=37}\n``` {.python .cell-code}\nX = np.array([[1, 1, 1, 0, 0], [0, 0, 0, 0, 1], [1, 0, 0, 0, 1],\n              [1, 0, 0, 0, 0], [0, 1, 1, 1, 1]])\nprint(X)\n```\n:::\n\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 140-157 solutions.py\n```\n\n### Exercice : One Hot Encoding\n\n\nEn statistique, il est fréquent de vouloir encoder numériquement un vecteur de catégories. Une manière fréquente d'encoder des catégories est le *one hot encoding* (OHE) : chaque valeur est représentée par un vecteur binaire, qui contient un $1$ sur la colonne correspondant à la catégorie et des $0$ partout ailleurs.\n\nDans la cellule suivante, on encode des PCS au format OHE grâce à une fonction du package `scikit-learn`. L'objectif de l'exercice est de reproduire cet encodage en utilisant uniquement des fonctions de la librairie `NumPy`.\n\nIndice : on pourra utiliser les fonctions `np.unique`, `np.zeros` et `np.arange`.\n\n::: {#b53d412c .cell execution_count=38}\n``` {.python .cell-code}\nfrom sklearn.preprocessing import OneHotEncoder\n\nvalues = np.array([\"21\", \"46\", \"47\", \"23\", \"66\", \"82\", \"82\"])\n\nprint(OneHotEncoder().fit_transform(values.reshape((-1, 1))).todense())\n```\n:::\n\n\n```{python} tags=[]\n# Testez votre réponse dans cette cellule\n\n```\n\n```{python} tags=[]\n# Exécuter cette cellule pour afficher la solution\n%load -r 161-169 solutions.py\n```\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.10.12\n---\n",
    "supporting": [
      "tutorial_files"
    ],
    "filters": []
  }
}