# Working with tabular data using Pandas

Statistical analysis is generally based on **tabular data**, where each row represents an observation and each column a variable. To handle this type of data and easily apply standard data analysis methods, dedicated objects have been designed: `DataFrames`. Users of `R` are well acquainted with this data structure, which is native to this statistics-oriented language. In `Python`, a general-purpose language, this object does not exist natively. Fortunately, a very comprehensive and convenient library, designed as an overlay to `NumPy`, introduces the `DataFrame` object in `Python` and allows for simple and intuitive data manipulation and analysis: `Pandas`.

::: {.callout-note}
Pandas is the central element of the data science ecosystem in Python, offering virtually infinite data processing capabilities. Moreover, there are generally multiple ways to perform the same operation in Pandas. Consequently, this chapter is particularly long and dense with new features. The goal is not to memorize all the methods presented throughout this chapter, but rather to have a general overview of what is possible in order to use the right tools in projects. In particular, the end-of-chapter exercises and the mini-projects at the end of the course will provide an opportunity to apply this new knowledge to concrete problems.
:::

Let's start by importing the `Pandas` library. The common usage is to give it the alias `pd` to simplify future calls to the package's objects and functions. We also import `NumPy` as we will compare the fundamental objects of the two packages.

```{python}
import pandas as pd
import numpy as np
```

## Data structures

To fully understand how `Pandas` works, it is important to focus on its fundamental objects. We will therefore first study the `Series`, whose concatenation allows us to build a `DataFrame`.

### The `Series`

A Series is a one-dimensional data container that can hold any type of data (integers, strings, Python objects...). However, a Series is of a given type: a Series containing only integers will be of type `int`, and a Series containing objects of different natures will be of type `object`. Let's build our first Series from a list to check this behavior.

```{python}
l = [1, "X", 3]
s = pd.Series(l)
print(s)
```

In particular, we can access the data of a Series by position, as for a list or an array.

```{python}
print(s[1])
```

At first glance, we do not see much difference between a Series and a one-dimensional `NumPy` array. However, there is a significant difference: the presence of an index. The observations have an associated label. When we create a Series without specifying anything, the index is automatically set to the integers from 0 to n-1 (with n being the number of elements in the Series). But it is possible to pass a specific index (e.g., dates, town names, etc.).

```{python}
s = pd.Series(l, index=["a", "b", "c"])
print(s)
```

This allows us to access the data by label:

```{python}
s["b"]
```

This difference may seem minor at first, but it becomes essential for constructing the DataFrame. For the rest, Series behave very similarly to NumPy arrays: calculations are vectorized, we can directly sum two Series, etc. Moreover, we can easily convert a Series into an array via the `values` attribute. This naturally loses the index...

```{python}
s = pd.Series(l, index=["a", "b", "c"])
s.values
```

### The `DataFrame`

Fundamentally, a DataFrame consists of a collection of Series, aligned by their indexes. This concatenation thus constructs a data table, with Series corresponding to columns, and the index identifying the rows. The following figure ([source](https://www.geeksforgeeks.org/creating-a-pandas-dataframe/)) helps to understand this data structure.

![](img/structure_df.png){fig-align="center" width="800"}

A DataFrame can be constructed in multiple ways. In practice, we generally build a DataFrame directly from tabular data files (e.g., CSV, Excel), rarely by hand. So, we will only illustrate the most common manual construction method: from a data dictionary.

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1.3, 5.6, np.nan, np.nan, 0, np.nan],
        "var2": np.random.randint(-10, 10, 6),
        "experiment": ["test", "train", "test", "train", "train", "validation"],
        "date": ["2022-01-01", "2022-01-02", "2022-01-03", "2022-01-04", "2022-01-05", "2022-01-06"],
        "sample": "sample1"
    }
)

df
```

A Pandas DataFrame has a set of useful attributes that we will discover throughout this tutorial. For now, let's focus on the most basic ones: the index and the column names. By default, the index is initialized, as for Series, to the list of positions of the observations. We could have specified an alternative index when constructing the DataFrame by specifying the `index` argument of the `pd.DataFrame` function.

```{python}
df.index
```

```{python}
df.columns
```

Often, rather than specifying an index manually during the construction of the DataFrame, we will want to use a certain column of the DataFrame as an index. We use the `set_index` method associated with DataFrames for this.

```{python}
df = df.set_index("date")
df
```

The index attribute has naturally changed:

```{python}
df.index
```

## Selecting data

When manipulating tabular data, it is common to want to extract specific columns from a `DataFrame`. This extraction is simple with `Pandas` using square brackets.

### Selecting columns

#### Selecting a single column

To extract a single column, we can use the following syntax:

```{python}
selected_column = df["var1"]
selected_column
```

The `selected_column` object here returns the column named `var1` from the `DataFrame` `df`. But what type is this object? To answer this question, we use the `type()` function:

```{python}
type(selected_column)
```

As we can see, the result is a `Series`, which is a one-dimensional object in `Pandas`.

Another useful attribute to know is `shape`. It allows us to know the dimension of the object. For a `Series`, `shape` will return a tuple whose first element indicates the number of rows.

```{python}
selected_column.shape
```

#### Selecting multiple columns

To extract multiple columns, just pass a list of the desired column names:

```{python}
selected_columns = df[["var1", "var2", "experiment"]]
selected_columns
```

This snippet shows the columns `var1`, `var2`, and `experiment` from the `DataFrame` `df`. Let's now check its type:

```{python}
type(selected_columns)
```

The result is a `DataFrame` because it is a two-dimensional object. We can also check its shape with the `shape` attribute. In this case, the tuple returned by `shape` will contain two elements: the number of rows and the number of columns.

```{python}
selected_columns.shape
```

### Selecting rows

#### Using `loc` and `iloc`

When we want to select specific rows in a DataFrame, we can use two main methods: `loc` and `iloc`.

- `iloc` allows selecting rows and columns by their position, i.e., by numeric indices.

Example, selecting the first 3 rows:

```{python}
df.iloc[0:3, :]
```

- `loc` works with labels. If the DataFrame's indexes are numbers, they resemble positions, but this is not necessarily the case. It is crucial to note that, unlike `iloc`, with `loc`, the end index is included in the selection.

```{python}
df.loc["2022-01-01":"2022-01-03", :]
```

#### Filtering data based on conditions

In practice, rather than selecting rows based on positions or labels, we often want to filter a DataFrame based on certain conditions. In this case, we primarily use boolean filters.

- **Inequalities**: We might want to keep only the rows that meet a certain condition.

Example, filtering rows where the value of the `var2` column is greater than 0:

```{python}
df[df['var2'] >= 0]
```

- **Membership with `isin`**: If we want to filter data based on a list of possible values, the `isin` method is very useful.

Example, to keep only the rows where the `experiment` column has values 'test' or 'validation':

```{python}
df[df['experiment'].isin(['train', 'validation'])]
```

These methods can be combined to create more complex conditions. It is also possible to use logical operators (`&` for "and", `|` for "or") to combine multiple conditions. Be careful to enclose each condition in parentheses when combining them.

Example, selecting rows where `var2` is greater than 0 and `experiment` is equal to 'test' or 'validation':

```{python}
df[(df['var2'] >= 0) & (df['experiment'].isin(['train', 'validation']))]
```

## Exploring tabular data

In public statistics, the starting point is generally not the manual generation of data but rather pre-existing tab

ular files. These files, whether from surveys, administrative databases, or other sources, constitute the raw material for any subsequent analysis. Pandas offers powerful tools to import these tabular files and explore them for further manipulations.

### Importing and exporting data

#### Importing a CSV file

As we saw in a previous lab, the CSV format is one of the most common formats for storing tabular data. We previously used the `csv` library to handle them as text files, but it was not very convenient. To recall, the syntax for reading a CSV file and displaying the first lines was as follows:

```{python}
import csv

rows = []

with open("data/departement2021.csv") as file_in:
    csv_reader = csv.reader(file_in)
    for row in csv_reader:
        rows.append(row)

rows[:5]
```

With Pandas, just use the `read_csv()` function to import the file as a DataFrame, then the `head()` function.

```{python}
df_departements = pd.read_csv('data/departement2021.csv')
df_departements.head()
```

It is also possible to import a CSV file directly from a URL. This is particularly convenient when the data is regularly updated on a website, and we want to access the latest version without manually downloading the file each time. Let's take the example of a CSV file available on the INSEE website: the file of given names, from civil status data. We also note another handy feature: the CSV file is compressed (in `zip` format), but Pandas can recognize and decompress it before importing.

```{python}
# Importing a CSV file from a URL
url = "https://www.insee.fr/fr/statistiques/fichier/2540004/nat2021_csv.zip"
df_prenoms_url = pd.read_csv(url, sep=";")
df_prenoms_url.head()
```

When working with CSV files, there are many optional arguments available in the `read_csv()` function that allow us to adjust the import process according to the specifics of the file. These arguments can, for example, define a specific delimiter (as above for the given names file), skip certain lines at the beginning of the file, or define data types for each column, and many others. All these parameters and their usage are detailed in the [official documentation](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html).

#### Exporting to CSV format

Once the data has been processed and modified within Pandas, it is common to want to export the result as a CSV file for sharing, archiving, or use in other tools. Pandas offers a simple method for this operation: `to_csv()`. Suppose we want to export the data from the `df_departements` DataFrame specific to the five overseas departments.

```{python}
df_departements_dom = df_departements[df_departements["DEP"].isin(["971", "972", "973", "974", "975"])]
df_departements_dom.to_csv('output/departements2021_dom.csv')
```

One of the key arguments of the `to_csv()` method is `index`. By default, `index=True`, which means that the DataFrame's index will also be written in the CSV file. We can verify this by printing the first lines of our CSV file: Pandas has added an unnamed column, which contains the index of the retained rows.

```{python}
with open("output/departements2021_dom.csv") as file_in:
    for i in range(5):
        row = next(file_in).strip()
        print(row)
```

In some cases, notably when the index does not provide useful information or is simply automatically generated by Pandas, we might want to exclude it from the exported file. To do this, we can set `index=False`.

```{python}
df_departements_dom.to_csv('output/departements2021_dom_noindex.csv', index=False)
```

#### Importing a Parquet file

The Parquet format is another format for storing tabular data, increasingly used. Without going into technical details, the Parquet format has various characteristics that make it a preferred choice for storing and processing large volumes of data. Due to these advantages, this format is increasingly used for data dissemination at INSEE. It is therefore essential to know how to import and query Parquet files with Pandas.

Importing a Parquet file into a Pandas DataFrame is as easy as for a CSV file. The function is called `read_parquet()`.

```{python}
df_departements = pd.read_parquet('data/departement2021.parquet')
df_departements.head()
```

#### Exporting to Parquet format

Again, everything works as in the CSV world: we use the `to_parquet()` method to export a DataFrame to a Parquet file. Similarly, we can choose to export or not the index, using the `index` parameter (which defaults to `True`).

```{python}
df_departements_dom = df_departements[df_departements["DEP"].isin(["971", "972", "973", "974", "975"])]
df_departements_dom.to_parquet('output/departements2021_dom.parquet', index=False)
```

One of the major strengths of the Parquet format, compared to text formats like CSV, is its ability to store metadata, i.e., data that helps better understand the data contained in the file. In particular, a Parquet file includes in its metadata the data schema (variable names, variable types, etc.), making it a very suitable format for data dissemination. Let's verify this behavior by revisiting the DataFrame we defined earlier.

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1.3, 5.6, np.nan, np.nan, 0, np.nan],
        "var2": np.random.randint(-10, 10, 6),
        "experiment": ["test", "train", "test", "train", "train", "validation"],
        "date": ["2022-01-01", "2022-01-02", "2022-01-03", "2022-01-04", "2022-01-05", "2022-01-06"],
        "sample": "sample1"
    }
)

df = df.assign(
    experiment=pd.Categorical(df["experiment"]),
    date=pd.to_datetime(df["date"])
)
```

This time, we use two specific data types, for categorical data (`category`) and for temporal data (`datetime`). We will see later in the tutorial how to use these types. For now, let's simply note that Pandas stores these types in the data schema.

```{python}
df.info()
```

Let's now verify that exporting and re-importing this data in Parquet preserves the schema.

```{python}
df.to_parquet("output/df_test_schema.parquet", index=False)
df_test_schema_parquet = pd.read_parquet('output/df_test_schema.parquet')

df_test_schema_parquet.info()
```

Conversely, a CSV file, which by definition only contains text, does not preserve this data. The variables for which we specified the type are imported as strings (type `object` in Pandas).

```{python}
df.to_csv("output/df_test_schema.csv", index=False)
df_test_schema_csv = pd.read_csv('output/df_test_schema.csv')

df_test_schema_csv.info()
```

### Viewing a sample of data

When working with large datasets, it is often useful to quickly view a sample of the data to get an idea of its structure, format, or even to detect potential problems. Pandas offers several methods for this.

The `head()` method displays the first rows of the DataFrame. By default, it returns the first 5 rows, but we can specify another number as an argument if necessary.

```{python}
df_departements.head()
```

```{python}
df_departements.head(10)
```

Conversely, the `tail()` method gives a preview of the last rows of the DataFrame.

```{python}
df_departements.tail()
```

Displaying the first or last rows may sometimes not be representative of the entire dataset, especially when the data is sorted. To minimize the risk of obtaining a biased overview of the data, we can use the `sample()` method, which selects a random sample of rows. By default, it returns a single row, but we can request a specific number of rows using the `n` argument.

```{python}
df_departements.sample(n=5)
```

### Getting an overview of the data

One of the first steps when exploring new data is to understand the general structure of the dataset. The `info()` method in Pandas provides a quick overview of the data, including data types, the presence of missing values, and memory usage.

```{python}
df.info()
```

Several key pieces of information can be extracted from this result:

- **index**: The DataFrame has a `RangeIndex`, which means the index is a simple numeric sequence. Here, the index ranges from 0 to 5, for a total of 6 entries.

- **schema**: The list of columns is displayed with very useful information about the data schema:

  - **Non-Null Count**: The number of **non-missing** (non-`nan`) values in the column. If this number is less than the total number of entries (in our case, 6), it means the column contains missing values. Note the possible ambiguity on "null": this indeed means missing values, not values equal to 0. Thus, in our case, the number of "non-null" values for the `var1` variable is 5.

  - **Dtype**: The data type of the column, which helps understand the nature of the information stored in each column. For example, `float64`

 (real numbers), `int32` (integers), `category` (categorical variable), `datetime64[ns]` (temporal information), and `object` (text or mixed data).

Using `info()` is a quick and effective way to get an overview of a DataFrame, quickly identify columns containing missing values, and understand the data structure.

### Calculating descriptive statistics

In addition to the information returned by the `info()` method, we might want to obtain simple descriptive statistics to quickly visualize the distributions of variables. The `describe()` method provides a synthetic view of the distribution of data in each column.

```{python}
df.describe()
```

It should be noted that `describe()` only returns statistics for numeric columns by default. If we want to include columns of other types, we need to specify this via the `include` argument. For example, `df.describe(include='all')` will return statistics for all columns, including metrics such as the unique count, the most frequent value, and the frequency of the most frequent value for non-numeric columns.

```{python}
df.describe(include='all')
```

Note again that the `count` variable returns the number of **non-missing** values in each variable.

## Main data manipulations

### Transforming data

Data transformation operations are essential for shaping, cleaning, and preparing data for analysis. Transformations can apply to the entire DataFrame, specific columns, or specific rows.

#### Transforming a DataFrame

To transform an entire DataFrame (or a sub-DataFrame), it is possible to use vectorized functions, which allow quickly applying an operation to all elements of the DataFrame. This includes a number of methods available for `Series`, as well as NumPy mathematical functions, etc.

For example, raising each numeric value in a DataFrame to the power of 2:

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1.3, 5.6, np.nan, np.nan, 0, np.nan],
        "var2": np.random.randint(-10, 10, 6),
    }
)

df ** 2
```

or taking the absolute value:

```{python}
np.abs(df)
```

Some methods available for `Series` can also be used to transform an entire DataFrame. For example, the very useful [replace()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html) method, which allows replacing all occurrences of a given value with another value. For example, suppose the value 0 in the `var1` column actually indicates a measurement error. It would be preferable to replace it with a missing value.

```{python}
df.replace(0, np.nan)
```

::: {.callout-warning title="Assignment or in-place methods?"}
In the previous example, applying the [replace()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html) method does not directly modify the DataFrame. To make the modification persistent, one possibility is to assign the result to an object:

```{python}
df = df.replace(0, np.nan)
```

A second possibility is, when methods offer it, to use the `inplace` argument. When `inplace=True`, the operation is performed "in place", and the DataFrame is therefore directly modified.

```{python}
df.replace(0, np.nan, inplace=True)
```

In practice, it is better to limit `inplace` operations. They do not favor the reproducibility of analyses, as the re-execution of the same cell will give different results each time.
:::

#### Transforming columns

In some cases, we will not want to apply transformations to the entire data but to specific variables. Transformations possible at the DataFrame level (vectorized functions, methods like [replace()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html), etc.) naturally remain possible at the column level.

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1.3, 5.6, np.nan, np.nan, 0, np.nan],
        "var2": np.random.randint(-10, 10, 6),
    }
)

np.abs(df["var2"])
```

```{python}
df["var1"].replace(0, np.nan)
```

But there are other transformations that are generally applied at the level of one or a few columns. For example, when the schema has not been properly recognized upon import, it may happen that numeric variables are defined as strings (type `object` in Pandas).

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1.3, 5.6, np.nan],
        "var2": ["1", "5", "18"],
    }
)

df.info()
```

In this case, we can use the `astype` method to convert the column to the desired type.

```{python}
df['var2'] = df['var2'].astype(int)

df.info()
```

Another frequent operation is renaming one or more columns. To do this, we can use the [rename()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rename.html) method, passing a dictionary containing as many key-value pairs as variables to be renamed, where each key-value pair is of the form `'old_name': 'new_name'`.

```{python}
df.rename(columns={'var2': 'age'})
```

Finally, we might want to remove columns from the DataFrame that are not or no longer useful for analysis. For this, we use the [drop()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html) method, to which we pass either a string (name of a column if we want to remove only one) or a list of column names to remove.

```{python}
df.drop(columns=['var1'])
```

#### Transforming rows

In statistics, we generally apply transformations involving one or more columns. However, in some cases, it is necessary to apply transformations at the row level. For this, we can use the [apply()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html) method of Pandas, applied to the row axis (`axis=1`). Let's illustrate its operation with a simple case. First, we generate data.

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1, 5, 9, 13],
        "var2": [3, 7, 11, 15],
        "date": ["2022-01-01", "2022-01-02", "2022-01-03", "2022-01-04"],
    }
)

df.head()
```

We now apply the `apply()` function to the DataFrame to calculate a new variable that is the sum of the two existing ones.

```{python}
df['sum_row'] = df.apply(lambda row: row['var1'] + row['var2'], axis=1)

df.head()
```

::: {.callout-tip title="Lambda functions"}
A `lambda` function is a small anonymous function. It can take any number of arguments but can have only one expression. In the example above, the `lambda` function takes a row as an argument and returns the sum of the `var1` and `var2` columns for that row.

Lambda functions allow defining simple functions "on the fly" without having to give them a name. In our example, this would have been perfectly equivalent to the following code:

```{python}
def sum_row(row):
    return row['var1'] + row['var2']

df['sum_row'] = df.apply(sum_row, axis=1)
```
:::

Although `apply()` offers great flexibility, it is not the most efficient method, especially for large datasets. Vectorized operations are always preferable as they process data in blocks rather than row by row. In our case, it would have been preferable to create our variable using column operations.

```{python}
df['sum_row_vect'] = df['var1'] + df['var2']

df.head()
```

However, we might find ourselves in certain (rare) cases where an operation cannot be easily vectorized or where the logic is complex. Suppose, for example, we want to combine the values of several columns based on certain conditions.

```{python}
def combine_columns(row):
    if row['var1'] > 6:
        return str(row['var2'])
    else:
        return str(row['var2']) + "_" + row['date']

df['combined_column'] = df.apply(combine_columns, axis=1)

df
```

### Sorting values

Sorting data is particularly useful for exploring and visualizing data. With Pandas, we use the [sort_values()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html) method to sort the values of a DataFrame based on one or more columns.

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1, 5, 9, 13],
        "var2": [3, 7, 11, 15],
        "date": ["2022-01-01", "2022-01-02", "2022-01-03", "2022-01-04"],
    }
)

df
```

To sort the values based on a single column, just pass the column name as a parameter.

```{python}
df.sort_values(by='var1')
```

By default, the sorting is done in ascending

 order. To sort the values in descending order, just set `ascending=False`.

```{python}
df.sort_values(by='var1', ascending=False)
```

If we want to sort the DataFrame on multiple columns, we can provide a list of column names. We can also choose to sort in ascending order for some columns and descending order for others.

### Aggregating data

Aggregating data is a process where the data is broken down into groups based on certain criteria and then aggregated using an aggregation function applied independently to each group. This operation is common in exploratory analysis or when preprocessing data for visualization or statistical modeling.

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1.3, 5.6, np.nan, np.nan, 0, np.nan],
        "var2": np.random.randint(-10, 10, 6),
        "experiment": ["test", "train", "test", "train", "train", "validation"],
        "date": ["2022-01-01", "2022-01-02", "2022-01-03", "2022-01-04", "2022-01-05", "2022-01-06"],
        "sample": "sample1"
    }
)

df.head()
```

#### The `groupBy` operation

The `groupBy` method in Pandas allows dividing the DataFrame into subsets based on the values of one or more columns, and then applying an aggregation function to each subset. It returns a `DataFrameGroupBy` object that is not very useful by itself but is an essential intermediate step to then apply one or more aggregation function(s) to the different groups.

```{python}
df.groupby('experiment')
```

#### Aggregation functions

Once the data is grouped, we can apply aggregation functions to obtain a statistical summary. Pandas includes a number of these functions, the complete list of which is detailed in the [documentation](https://pandas.pydata.org/docs/user_guide/groupby.html#built-in-aggregation-methods). Here are some examples of using these methods.

For example, count the number of occurrences in each group.

```{python}
df.groupby('experiment').size()
```

Calculate the sum of a variable by group.

```{python}
df.groupby('experiment')['var1'].sum()
```

Or count the number of unique values of a variable by group. The possibilities are numerous.

```{python}
# For the number of unique values of 'var2' in each group
df.groupby('experiment')['var2'].nunique()
```

When we want to apply multiple aggregation functions at once or custom functions, we use the `agg` method. This method accepts a list of functions or a dictionary that associates column names with functions to apply. This allows for finer application of aggregation functions.

```{python}
df.groupby('experiment').agg({'var1': 'mean', 'var2': 'count'})
```

::: {.callout-note title="Method chaining"}
The previous examples illustrate an important concept in Pandas: method chaining. This term refers to the possibility of chaining transformations applied to a DataFrame by applying methods to it in a chain. At each applied method, an intermediate DataFrame is created (but not assigned to a variable), which becomes the input of the next method.

Method chaining allows combining several operations into a single code expression. This can improve efficiency by avoiding intermediate assignments and making the code more fluid and readable. It also favors a functional programming style where data flows smoothly through a chain of transformations.
:::

#### Effects on the index

It is interesting to note the effects of the aggregation process on the DataFrame's index. The last example above illustrates this well: the groups, i.e., the modalities of the variable used for aggregation, become the values of the index.

We might want to reuse this information in subsequent analyses and therefore want it as a column. For this, just reset the index with the `reset_index()` method.

```{python}
df_agg = df.groupby('experiment').agg({'var1': 'mean', 'var2': 'count'})
df_agg.reset_index()
```

### Handling missing values

Missing values are a common reality in real-world data processing and can occur for various reasons, such as non-responses to a questionnaire, data entry errors, data loss during transmission, or simply because the information is not applicable. Pandas offers several tools to handle missing values.

#### Representation of missing values

In Pandas, missing values are generally represented by `np.nan`, a special marker provided by the `NumPy` library. While it is preferable to use this object to denote missing values, note that the `None` object in `Python` is also understood as a missing value by `Pandas`.

Let's verify this property. To identify where the missing values are, we use the `isna()` function, which returns a boolean DataFrame indicating `True` where the values are `NaN`.

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1.3, 5.6, np.nan, np.nan, 0, np.nan],
        "var2": np.random.randint(-10, 10, 6),
        "experiment": ["test", "train", "test", None, "train", "validation"],
        "sample": "sample1"
    }
)

df.isna()
```

#### Calculations on columns containing missing values

During statistical calculations, missing values are generally ignored. For example, the `.mean()` method calculates the mean of non-missing values.

```{python}
df['var1'].mean()
```

However, calculations involving multiple columns do not always ignore missing values and can often result in `NaN`.

```{python}
df['var3'] = df['var1'] + df['var2']

df
```

#### Removing missing values

The `dropna()` method allows us to remove rows (`axis=0`) or columns (`axis=1`) containing missing values. By default, any row containing at least one missing value is removed.

```{python}
df.dropna()
```

By changing the `axis` parameter, we can request that any column containing at least one missing value be removed.

```{python}
df.dropna(axis=1)
```

Finally, the `how` parameter defines the deletion mode. By default, a row or column is removed when at least one value is missing (`how=any`), but it is possible to remove the row/column only when all values are missing (`how=all`).

#### Replacing missing values

To handle missing values in a DataFrame, a common approach is imputation, which involves replacing the missing values with other values. The `fillna()` method allows us to perform this operation in various ways. One possibility is replacement by a constant value.

```{python}
df['var1'].fillna(value=0)
```

::: {.callout-warning title="Changing the representation of missing values"}
It can sometimes be tempting to change the manifestation of a missing value for visibility reasons, for example by replacing it with a string:

```{python}
df['var1'].fillna(value="MISSING")
```

In practice, this is not recommended. It is indeed preferable to stick to Pandas' standard convention (using `np.nan`), firstly for standardization purposes that facilitate reading and maintaining the code, but also because the standard convention is optimized for performance and calculations from data containing missing values.
:::

Another frequent imputation method is to use a statistical value, such as the mean or median of the variable.

```{python}
df['var1'].fillna(value=df['var1'].mean())
```

::: {.callout-warning title="Imputation bias"}
Replacing missing values with a constant value, such as zero, the mean, or the median, can be problematic. If the data is not missing at random (MNAR), this can introduce bias into the analysis. MNAR variables are variables whose probability of being missing is related to their own value or other variables in the data. In such cases, more sophisticated imputation may be necessary to minimize distortions. We will see an example in the end-of-tutorial exercise.
:::

### Handling data of specific types

#### Text data

Text data often requires cleaning and preparation before analysis. Pandas provides an array of vectorized operations via the `str` library that make preparing text data both simple and very efficient. Again, the possibilities are numerous and detailed in the [documentation](https://pandas.pydata.org/docs/user_guide/text.html). Here we present the most frequently used methods in data analysis.

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1.3, 5.6, np.nan, np.nan, 0, np.nan],
        "var2": np.random.randint(-10, 10, 6),
        "experiment": ["test", "train", "test", "test", "train", "validation"],
        "sample": ["  sample1", "sample1", "sample2", "   sample2   ", "sample2  ", "sample1"]
    }
)

df
```

A first frequent operation is to extract certain characters from a string. We use the `str[n:]` function (with a somewhat peculiar syntax) for this. For example, if we want to extract the last character of the `sample` variable to retain only the sample number.

```{python}
df["sample_n"] = df["sample"].str[-1:]

df
```

The principle was correct, but the presence of extraneous spaces in our text data (which were not visible when viewing the DataFrame!) made the operation more difficult than expected. This is an opportunity to introduce the `strip` family of methods (`.str.strip()`, `.str.lstrip()`, and `.str.rstrip()`) that respectively remove extr

aneous spaces from both sides or one side.

```{python}
df["sample"] = df["sample"].str.strip()
df["sample_n"] = df["sample"].str[-1:]

df
```

We might also want to filter a DataFrame based on the presence or absence of a certain string (or substring) of characters. For this, we use the `.str.contains()` method.

```{python}
df[df['experiment'].str.contains('test')]
```

Finally, we might want to replace a string (or substring) of characters with another, which the `str.replace()` method allows.

```{python}
df['experiment'] = df['experiment'].str.replace('validation', 'val')

df
```

#### Categorical data

Categorical data is variables that contain a limited number of categories. Similar to `R` with the notion of `factor`, Pandas has a special data type, `category`, which is useful for representing categorical data more efficiently and informatively. Categorical data is indeed optimized for certain types of data and can speed up operations like grouping and sorting. It is also useful for visualization, ensuring that categories are displayed in a coherent and logical order.

To convert a variable to the `category` format, we use the `astype()` method.

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1.3, 5.6, np.nan, np.nan, 0, np.nan],
        "var2": np.random.randint(-10, 10, 6),
        "experiment": ["test", "train", "test", None, "train", "validation"],
    }
)
print(df.dtypes)
```

```{python}
df['experiment'] = df['experiment'].astype('category')

print(df.dtypes)
```

This conversion gives us access to some very useful methods, specific to handling categorical variables. For example, it can be useful to rename categories for clarity or standardization.

```{python}
df['experiment'] = df['experiment'].cat.rename_categories({'test': 'Test', 'train': 'Train', 'validation': 'Validation'})
df
```

Sometimes, the order of categories is significant, and we might want to modify it. This is particularly important for visualization, as the categories will by default be displayed in the specified order.

```{python}
df_cat = df['experiment'].cat.reorder_categories(['Test', 'Train', 'Validation'], ordered=True)
df.groupby("experiment").mean().plot(kind='bar')
```

#### Temporal data

Temporal data is often present in tabular data to temporally identify the observations collected. Pandas offers functionalities for handling these types of data, particularly through the `datetime64` type, which allows precise manipulation of dates and times.

```{python}
df = pd.DataFrame(
    data = {
        "var1": [1, 5, 9, 13],
        "var2": [3, 7, 11, 15],
        "date": ["2022-01-01", "2022-01-02", "2023-01-01", "2023-01-02"],
        "sample": ["sample1", "sample1", "sample2", "sample2"]
    }
)

df.dtypes
```

To handle temporal data, it is necessary to convert the strings into `datetime` objects. Pandas does this via the `to_datetime()` function.

```{python}
df['date'] = pd.to_datetime(df['date'])

df.dtypes
```

Once converted, dates can be formatted, compared, and used in calculations. In particular, Pandas now understands the "order" of the dates present in the data, allowing for filtering over given periods.

```python
df[(df['date'] >= "2022-01-01") & (df['date'] < "2022-01-03")]
```

We might also want to perform less precise filtering, involving the year or month. Pandas allows us to easily extract specific components of the date, such as the year, month, day, hour, etc.

```python
df['year'] = df['date'].dt.year
df['month'] = df['date'].dt.month
df['day'] = df['date'].dt.day

df[df['year'] == 2023]
```

Finally, calculations involving dates become possible. We can add or subtract time periods from dates and compare them with each other. The functions used come from `Pandas` but are very similar in operation to those of the [time](https://docs.python.org/fr/3/library/time.html) module in Python.

For example, we can add time intervals or calculate differences from a reference date.

```python
df['date_plus_one'] = df['date'] + pd.Timedelta(days=1)
df['date_diff'] = df['date'] - pd.to_datetime('2022-01-01')

df
```

### Joining tables

In data analysis, it is common to want to combine different data sources. This combination can be done vertically (one DataFrame on top of another), for example, when combining two years of the same survey for joint analysis. The combination can also be done horizontally (side by side) based on one or more join keys, often to enrich one data source with information from another source covering the same statistical units.

#### Concatenating tables

The vertical concatenation of tables is done using the `concat()` function in Pandas.

```{python}
df1 = pd.DataFrame(
    data = {
        "var1": [1, 5],
        "var2": [3, 7],
        "date": ["2022-01-01", "2022-01-02"],
        "sample": ["sample1", "sample1"]
    }
)

df2 = pd.DataFrame(
    data = {
        "var1": [9, 13],
        "date": ["2023-01-01", "2023-01-02"],
        "var2": [11, 15],
        "sample": ["sample2", "sample2"]
    }
)

df_concat = pd.concat([df1, df2])

df_concat
```

Note that the order of variables in the two DataFrames is not important. Pandas does not "dumbly" juxtapose the two DataFrames; it matches the schemas to align the variables by name. If two variables have the same name but not the same type - for example, if a numeric variable has been interpreted as strings - Pandas will resolve the issue by taking the common denominator, usually converting to strings (type `object`).

However, the previous concatenation reveals an issue of repetition at the index level. This is logical: we did not specify an index for our initial two DataFrames, which therefore have the same position index ([0, 1]). In this case (where the index is not important), we can pass the `ignore_index=True` parameter to rebuild the final index from scratch.

```{python}
df_concat = pd.concat([df1, df2], ignore_index=True)

df_concat
```

::: {.callout-warning title="Iterative construction of a DataFrame"}
One might have the idea of using `pd.concat()` to iteratively construct a DataFrame by adding a new row to the existing DataFrame in each iteration of a loop. However, this is not a good idea: as we have seen, a DataFrame is represented in memory as a juxtaposition of Series. Thus, adding a column to a DataFrame is not costly, but adding a row involves modifying each element constituting the DataFrame. To construct a DataFrame, it is therefore advisable to store the rows in a list of lists (one per column) or a dictionary, then call `pd.DataFrame()` to build the DataFrame, as we did at the beginning of this tutorial.
:::

#### Merging tables

Merging tables is an operation that allows us to associate rows from two different DataFrames based on one or more common keys, similar to joins in SQL databases. Different types of joins are possible depending on the data we want to keep, the main ones being represented in the following diagram.

![](img/joins.png)

Source: [link](https://medium.com/swlh/merging-dataframes-with-pandas-pd-merge-7764c7e2d46d)

In Pandas, joins are done with the [merge()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html) function. To perform a join, we must specify (at a minimum) two pieces of information:

- the type of join: by default, Pandas performs an `inner` join. The `how` parameter allows specifying other types of joins;

- the join key. By default, Pandas tries to join the two DataFrames based on their indexes. In practice, we often specify a variable present in the DataFrames as the join key (the `on` parameter if the variable has the same name in both DataFrames, or `left_on` and `right_on` otherwise).

Let's analyze the difference between the different types of joins through examples.

```{python}
df_a = pd.DataFrame({
    'key': ['K0', 'K1', 'K2', 'K3', 'K4'],
    'A': ['A0', 'A1', 'A2', 'A3', 'A4'],
    'B': ['B0', 'B1', 'B2', 'B3', 'A4']
})

df_b = pd.DataFrame({
    'key': ['K0', 'K1', 'K2', 'K5', 'K6'],
    'C': ['C0', 'C1', 'C2', 'C5', 'C6'],
    'D': ['D

0', 'D1', 'D2', 'D5', 'D6']
})

display(df_a)
display(df_b)
```

The `inner` join keeps the observations whose key is present in both DataFrames.

```{python}
df_merged_inner = pd.merge(df_a, df_b, on='key')
df_merged_inner
```

::: {.callout-warning title="Inner joins"}
The `inner` join is the most intuitive: it generally does not create missing values and therefore allows working directly on the merged table. But beware: if many keys are not present in both DataFrames, an `inner` join can result in significant data loss, leading to biased final results. In this case, it is better to choose a left or right join, depending on the source we want to enrich and for which it is most important to minimize data loss.
:::

A `left` join keeps all observations in the left DataFrame (the first DataFrame specified in `pd.merge()`). As a result, if keys are present in the left DataFrame but not in the right one, the final DataFrame contains missing values at those observations (for the right DataFrame's variables).

```{python}
df_merged_left = pd.merge(df_a, df_b, how="left", on='key')
df_merged_left
```

The `outer` join contains all observations and variables in both DataFrames. Thus, the retained information is maximal, but on the other hand, missing values can be quite numerous. It will therefore be necessary to handle missing values well before proceeding with analyses.

```{python}
df_merged_outer = pd.merge(df_a, df_b, how="outer", on='key')
df_merged_outer
```

## Exercises

### Comprehension questions

1. What is a DataFrame in the context of Pandas, and what type of data structure can it be compared to in Python?
2. What is the fundamental difference between a NumPy array and a Pandas Series?
3. What is the relationship between Series and DataFrame in Pandas?
4. How are data structured in a Pandas DataFrame?
5. What is the role of the index in a Pandas DataFrame, and how can it be used when manipulating data?
6. What methods can you use to explore an unknown DataFrame and learn more about its content and structure?
7. In Pandas, what is the difference between assigning the result of an operation to a new variable and using a method with the `inplace=True` argument?
8. How does the principle of vectorization apply in Pandas, and why is it advantageous for manipulating data?
9. How does Pandas represent missing values, and what impact does this have on calculations and data transformations?
10. What is the difference between concatenating two DataFrames and joining them via a merge, and when would you use one over the other?

<details>
<summary>Show solution</summary>

1. A DataFrame in Pandas is a two-dimensional data structure, comparable to a table or an Excel spreadsheet. In the Python context, it can be compared to a dictionary of NumPy arrays, where the keys are column names, and the values are the columns themselves.

2. The main difference between a NumPy array and a Pandas Series is that the Series can contain labeled data, meaning it has an associated index that allows access and manipulation by label.

3. A DataFrame is essentially a collection of Series. Each column of a DataFrame is a Series, and all these Series share the same index, which corresponds to the row labels of the DataFrame.

4. Data in a Pandas DataFrame are structured in columns and rows. Each column can contain a different type of data (numeric, string, boolean, etc.), and each row represents an observation.

5. The index in a Pandas DataFrame serves to uniquely identify each row in the DataFrame. It allows quick access to rows, performing joins, sorting data, and facilitating grouping operations.

6. To explore an unknown DataFrame, you can use `df.head()` to see the first rows, `df.tail()` for the last rows, `df.info()` to get a summary of data types and missing values, and `df.describe()` for descriptive statistics.

7. Assigning the result of an operation to a new variable creates a copy of the DataFrame with the applied modifications. Using a method with `inplace=True` modifies the original DataFrame without creating a copy, which can be more memory-efficient.

8. Pandas represents missing values with the `nan` (Not a Number) object from `NumPy` for numeric data and with `None` or `pd.NaT` for date/time data. These missing values are generally ignored in statistical calculations, which can affect the results if they are not handled properly.

9. Concatenating consists of stacking DataFrames vertically or aligning them horizontally, primarily used when the DataFrames have the same schema or when you want to stack the data. Merging, inspired by SQL JOIN operations, combines DataFrames based on common key values and is used to enrich one dataset with information from another.

</details>

### Multiple ways to create a DataFrame

In the following cell, we have retrieved cash register data on sales from different stores. The data is presented in two different ways: one as observations (each list contains data from a row), and the other as variables (each list contains data from a column).

```{python}
data_list1 = [
    ['Carrefour', '01.1.1', 3, 1.50],
    ['Casino', '02.1.1', 2, 2.30],
    ['Lidl', '01.1.1', 7, 0.99],
    ['Carrefour', '03.1.1', 5, 5.00],
    ['Casino', '01.1.1', 10, 1.20],
    ['Lidl', '02.1.1', 1, 3.10]
]

data_list2 = [
    ['Carrefour', 'Casino', 'Lidl', 'Carrefour', 'Casino', 'Lidl'],
    ['01.1.1', '02.1.1', '01.1.1', '03.1.1', '01.1.1', '02.1.1'],
    [3, 2, 7, 5, 10, 1],
    [1.50, 2.30, 0.99, 5.00, 1.20, 3.10]
]
```

The goal is to build in both cases the same DataFrame containing each of the 6 observations and 4 variables, with the same names in both DataFrames. Each case will correspond to a more suitable input data structure, dictionary, or list of lists... make the right choice! We will verify that the two DataFrames are identical using the [equals()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.equals.html) method.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
data_list1 = [
    ['Carrefour', 'Casino', 'Lidl', 'Carrefour', 'Casino', 'Lidl'],
    ['01.1.1', '02.1.1', '01.1.1', '03.1.1', '01.1.1', '02.1.1'],
    [3, 2, 7, 5, 10, 1],
    [1.50, 2.30, 0.99, 5.00, 1.20, 3.10]
]

data_list2 = [
    ['Carrefour', '01.1.1', 3, 1.50],
    ['Casino', '02.1.1', 2, 2.30],
    ['Lidl', '01.1.1', 7, 0.99],
    ['Carrefour', '03.1.1', 5, 5.00],
    ['Casino', '01.1.1', 10, 1.20],
    ['Lidl', '02.1.1', 1, 3.10]
]

# If the data is in column form: from a dictionary
data_dict = {
    'store': data_list1[0],
    'product': data_list1[1],
    'quantity': data_list1[2],
    'price': data_list1[3]
}

df_from_dict = pd.DataFrame(data_dict)

# If the data is in row form: from a list of lists
columns = ['store', 'product', 'quantity', 'price']
df_from_list = pd.DataFrame(data_list2, columns=columns)

# Verification
df_from_dict.equals(df_from_list)
```

</details>

### Data selection in a DataFrame

A Pandas DataFrame is created with cash register data (same data as the previous exercise).

```{python}
data = {
    'store': ['Carrefour', 'Casino', 'Lidl', 'Carrefour', 'Casino', 'Lidl'],
    'product': ['01.1.1', '02.1.1', '01.1.1', '03.1.1', '01.1.1', '02.1.1'],
    'quantity': [3, 2, 7, 5, 10, 1],
    'price': [1.50, 2.30, 0.99, 5.00, 1.20, 3.10],
    'date_time': pd.to_datetime(["2022-01-01 14:05", "2022

-01-02 09:30", 
                                 "2022-01-03 17:45", "2022-01-04 08:20", 
                                 "2022-01-05 19:00", "2022-01-06 16:30"])
}

df = pd.DataFrame(data)
```

Use the `loc` and `iloc` methods to select specific data:

- Select the data from the first row.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
print(df.iloc[0])
```

</details>

- Select all data from the "price" column.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
print(df.loc[:, 'price'])
```

</details>

- Select the rows corresponding to the store "Carrefour" only.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
print(df.loc[df['store'] == 'Carrefour'])
```

</details>

- Select the quantities purchased for products classified "01.1.1" (Bread).

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
print(df.loc[df['product'] == '01.1.1', 'quantity'])
```

</details>

- Select the data from the "store" and "price" columns for all rows.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
print(df.loc[:, ['store', 'price']])
```

</details>

- Select the rows where the purchased quantity is greater than 5.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
print(df.loc[df['quantity'] > 5])
```

</details>

- Filter to select all transactions that occurred after 3 PM.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
print(df.loc[df['date_time'].dt.hour > 15])
```

</details>

- Select the transactions that took place on "2022-01-03".

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
print(df.loc[df['date_time'].dt.date == pd.to_datetime('2022-01-03').date()])
```

</details>

### Exploring the first names file

The first names file contains data on the first names given to children born in France between 1900 and 2021. This data is available at the national, department, and regional levels at the following address: [https://www.insee.fr/fr/statistiques/2540004?sommaire=4767262](https://www.insee.fr/fr/statistiques/2540004?sommaire=4767262). The goal of this tutorial is to propose an analysis of this file, from data cleaning to first name statistics.

#### Part 1: Import and data exploration

- Import the data into a DataFrame using this [URL](https://www.insee.fr/fr/statistiques/fichier/2540004/nat2021_csv.zip).
- View a sample of the data. Do you notice any anomalies?
- Display the main information about the DataFrame. Identify any variables with incorrect types or any missing values.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
url = "https://www.insee.fr/fr/statistiques/fichier/2540004/nat2021_csv.zip"
df_first_names = pd.read_csv(url, sep=";")

df_first_names.head(10)
df_first_names.sample(n=50)

df_first_names.info()
```

</details>

#### Part 2: Data cleaning

- The output of the `info()` method suggests missing values in the first names column. Display these rows. Verify that these missing values are correctly specified.
- The output of the `head()` method shows a recurring "_PRENOMS_RARES" modality in the first names column. What proportion of the individuals in the database does this represent? Convert these values to `np.nan`.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
print(df_first_names[df_first_names["preusuel"].isna()])
prop_rares = df_first_names.groupby("preusuel")["nombre"].sum()["_PRENOMS_RARES"] / df_first_names["nombre"].sum()
print(prop_rares)  # ~ 2% of the database
df_first_names = df_first_names.replace('_PRENOMS_RARES', np.nan)
```

</details>

- We notice that the first names of people whose year of birth is unknown are grouped under the "XXXX" modality. What proportion of the individuals in the database does this represent? Convert these values to `np.nan`.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
prop_xxxx = df_first_names.groupby("annais")["nombre"].sum()["XXXX"] / df_first_names["nombre"].sum()
print(prop_xxxx)  # ~ 1% of the database
df_first_names = df_first_names.replace('XXXX', np.nan)
```

</details>

- Remove the rows containing missing values from the sample.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_first_names = df_first_names.dropna()
```

</details>

- Convert the `annais` column to numeric type and the `sexe` column to categorical type.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_first_names['annais'] = pd.to_numeric(df_first_names['annais'])
df_first_names['sexe'] = df_first_names['sexe'].astype('category')
```

</details>

- Verify with the `info()` method that the cleaning has been correctly applied.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_first_names.info()
```

</details>

#### Part 3: Descriptive statistics on births

- The [documentation](https://www.insee.fr/fr/statistiques/2540004?sommaire=4767262#documentation) of the file informs us that the data can be considered quasi-exhaustive from 1946 onwards. For this part only, filter the data to keep only data from 1946 onwards.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_first_names_post_1946 = df_first_names[df_first_names["annais"] >= 1946]
```

</details>

- Calculate the total number of births by sex.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
births_per_sex = df_first_names_post_1946.groupby('sexe')['nombre'].sum()
print(births_per_sex)
```

</details>

- Identify the five years with the highest number of births.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
top5_years = df_first_names_post_1946.groupby('annais')['nombre'].sum().nlargest(5)
print(top5_years)
```

</details>

#### Part 4: First name analysis

- Identify the total number of unique first names in the DataFrame.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
total_unique_names = df_first_names['preusuel'].nunique()
print(total_unique_names)
```

</details>

- Count the number of people with a single-letter first name.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
single_letter_names = df_first_names[df_first_names['preusuel'].str.len() == 1]['nombre'].sum()
print(single_letter_names)
```

</details>

- Create a "popularity function" that, for a given first name, displays the year it was most given and the number of times it was given that year.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
def popularity_by_year(df, first_name):
    # Filter the DataFrame to keep only the rows corresponding to the given first name
    df_first_name = df[df['preusuel'] == first_name]

    # Group by year, sum the births, and identify the year with the maximum births
    df_agg = df_first_name.groupby('annais')['nombre'].sum()
    max_year = df_agg.idxmax()
    max_n = df_agg[max_year]

    print(f"The first name '{first_name}' was most given in {max_year}, with {max_n} births.")

# Test the function with an example
popularity_by_year(df_first_names, 'ALFRED')
```

</details>

- Create a function that, for a given sex, returns a DataFrame containing the most given first name for each decade.

```{python}
# Test

 your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
def popularity_by_decade(df, sex):
    # Filter by sex
    df_sub = df[df["sexe"] == sex]

    # Calculate the decade variable
    df_sub["decade"] = (df_sub["annais"] // 10) * 10

    # Calculate the sum of births for each first name and each decade
    df_counts_decade = df_sub.groupby(["preusuel", "decade"])["nombre"].sum().reset_index()

    # Find the index of the most frequent first name for each decade
    idx = df_counts_decade.groupby("decade")["nombre"].idxmax()

    # Use the index to obtain the corresponding rows from the df_counts_decade DataFrame
    df_popularity_decade = df_counts_decade.loc[idx].set_index("decade")

    return df_popularity_decade

# Test the function with an example
popularity_by_decade(df_first_names, sex=2)
```

</details>

### Calculation of a carbon footprint per inhabitant at the municipal level

The goal of this exercise is to calculate a carbon footprint per inhabitant at the municipal level. To do this, we will need to combine two data sources:

- Legal populations at the municipal level from the population census ([source](https://www.insee.fr/fr/statistiques/6683037))

- Greenhouse gas emissions estimated at the municipal level by ADEME ([source](https://www.data.gouv.fr/fr/datasets/inventaire-de-gaz-a-effet-de-serre-territorialise/#_))

This exercise constitutes a simplified version of a [complete practical exercise on Pandas](https://pythonds.linogaliana.fr/content/manipulation/02b_pandas_TP.html#importer-les-donn%C3%A9es) proposed by Lino Galiana in his [course at ENSAE](https://pythonds.linogaliana.fr/).

#### Part 1: Exploring the legal municipal populations data

- Import the CSV file `communes.csv`.
- Use the `.sample()`, `.info()`, and `.describe()` methods to get an overview of the data.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_pop_communes = pd.read_csv("data/communes.csv", sep=";")

df_pop_communes.sample(10)
df_pop_communes.info()
df_pop_communes.describe()
```

</details>

- Identify and remove rows corresponding to municipalities without population.
- Remove the "PMUN" and "PCAP" columns, which are irrelevant for the analysis.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
n_communes_0_pop = df_pop_communes[df_pop_communes["PTOT"] == 0].shape[0]
print(n_communes_0_pop)
df_pop_communes = df_pop_communes[df_pop_communes["PTOT"] > 0]

df_pop_communes = df_pop_communes.drop(columns=["PMUN", "PCAP"])
```

</details>

Do the municipalities with the longest names also have the smallest populations? To find out:
- Create a new variable that contains the number of characters of each municipality using the [str.len()](https://pandas.pydata.org/docs/reference/api/pandas.Series.str.len.html) method.
- Calculate the correlation between this variable and the total population using the [corr()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.corr.html) method.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_pop_communes_stats = df_pop_communes.copy()
df_pop_communes_stats['length'] = df_pop_communes_stats['COM'].str.len()
df_pop_communes_stats['length'].corr(df_pop_communes_stats['PTOT'])
```

</details>

#### Part 2: Exploring the municipal emissions data

- Import the emissions data from this [URL](https://data.ademe.fr/data-fair/api/v1/datasets/igt-pouvoir-de-rechauffement-global/data-files/IGT%20-%20Pouvoir%20de%20r%C3%A9chauffement%20global.csv).
- Use the `.sample()`, `.info()`, and `.describe()` methods to get an overview of the data.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
url_ademe = "https://data.ademe.fr/data-fair/api/v1/datasets/igt-pouvoir-de-rechauffement-global/data-files/IGT%20-%20Pouvoir%20de%20r%C3%A9chauffement%20global.csv"
df_emissions = pd.read_csv(url_ademe)

df_emissions.sample(10)
df_emissions.info()
df_emissions.describe()
```

</details>

- Are there rows with missing values for all emission columns? Check using the [isnull()](https://pandas.pydata.org/docs/reference/api/pandas.isnull.html) and [all()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.all.html) methods.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_emissions_num = df_emissions.select_dtypes(['number'])
only_nan = df_emissions_num[df_emissions_num.isnull().all(axis=1)]
only_nan.shape[0]
```

</details>

- Create a new column that gives the total emissions per municipality.
- Display the 10 most emitting municipalities. What do you observe in the results?

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_emissions['total_emissions'] = df_emissions.sum(axis=1, numeric_only=True)

df_emissions.sort_values(by="total_emissions", ascending=False).head(10)
```

</details>

- It seems that the major emission sectors are "Industry excluding energy" and "Other international transport." To verify if this conjecture holds, calculate the correlation between total emissions and the sectoral emission items using the [corrwith()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.corrwith.html) method.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_emissions.corrwith(df_emissions["total_emissions"], numeric_only=True)
```

</details>

- Extract the department number from the municipality code into a new variable.
- Calculate the total emissions by department.
- Display the top 10 emitting departments. Are the results logical compared to the analysis at the municipal level?

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_emissions["dep"] = df_emissions["INSEE commune"].str[:2]
df_emissions.groupby("dep").agg({"total_emissions": "sum"}).sort_values(by="total_emissions", ascending=False).head(10)
```

</details>

#### Part 3: Preliminary checks for merging data sources

To perform a merge, it is always preferable to have a join key, i.e., a column common to both sources that uniquely identifies the statistical units. The purpose of this part is to find the relevant join key.

- Check if the variable containing the municipality names contains duplicates.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
duplicates = df_pop_communes.groupby('COM').count()['DEPCOM']
duplicates = duplicates[duplicates > 1]
duplicates = duplicates.reset_index()
duplicates
```

</details>

- Filter in the initial DataFrame the municipalities with duplicated names and sort it by municipality code. Do the duplicates seem problematic?

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_pop_communes_duplicates = df_pop_communes[df_pop_communes["COM"].isin(duplicates["COM"])]
df_pop_communes_duplicates.sort_values('COM')
```

</details>

- Verify that the municipality codes uniquely identify the associated municipality.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
(df_pop_communes_duplicates.groupby("DEPCOM")["COM"].nunique() != 1).sum()
```

</details>

- Display the municipalities present in the population data but not in the emissions data, and vice versa. What do you conclude?

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
# Observations in the population data but not in the emissions data
df_pop_communes[~df_pop_communes["DEPCOM"].isin(df_emissions["INSEE commune"])]

# Observations in the emissions data but not in the population data
df_emissions[~df_emissions["INSEE commune"].isin(df_pop_communes["DEPCOM"])]
```

</details>

#### Part 4: Calculating a carbon footprint per inhabitant for each municipality

- Merge the two DataFrames using the municipality code as the join key. Note: the variables are not named the same on both sides!

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_emissions_pop = pd.merge(df_pop_communes

, df_emissions, how="inner", left_on="DEPCOM", right_on="INSEE commune")
df_emissions_pop
```

</details>

- Calculate a carbon footprint for each municipality, corresponding to the total emissions of the municipality divided by its total population.
- Display the top 10 municipalities with the highest carbon footprints.
- Are the results the same as those with total emissions? What do you conclude?

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_emissions_pop["carbon_footprint"] = df_emissions_pop["total_emissions"] / df_emissions_pop["PTOT"]
df_emissions_pop.sort_values("carbon_footprint", ascending=False).head(10)
```

</details>

### Analysis of the evolution of a production index

You have two CSV data sets available in the `data/` folder:
- `serie_glaces_valeurs.csv` contains the monthly values of the production price index of the French ice cream and sorbet industry.
- `serie_glaces_metadonnees.csv` contains the associated metadata, including the codes indicating the data status.

The goal is to use `Pandas` to calculate:
- the evolution of the index between each period (month)
- the evolution of the index on a year-over-year basis (between a given month and the same month the following year).

#### Part 1: Importing data

- Import the two CSV files into DataFrames. Note: in both cases, there are extraneous rows before the data that need to be skipped using the `skiprows` parameter of the [read_csv()](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html) function.
- Give simple and relevant names to the various variables.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_values = pd.read_csv('data/serie_glaces_valeurs.csv', delimiter=';',
                        skiprows=4, names=["period", "index", "code"])
df_metadata = pd.read_csv('data/serie_glaces_metadonnees.csv', delimiter=';',
                          skiprows=5, names=["code", "meaning"])
```

</details>

#### Part 2: Filtering relevant data

- Merge the two DataFrames to retrieve the meanings of the codes present in the data.
- Filter the data to keep only the "Normal Value" data.
- Remove the columns related to the codes, which we no longer need for the rest.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_merged = pd.merge(df_values, df_metadata, how='left', on='code')

df_clean = df_merged[df_merged['code'] == "A"]
df_clean = df_clean[["period", "index"]]
```

</details>

#### Part 3: Data preprocessing

Verify if the types of variables are relevant according to their nature. If not, convert them with the appropriate functions.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_clean.info()
df_clean['period'] = pd.to_datetime(df_clean['period'])
df_clean['index'] = pd.to_numeric(df_clean['index'])
df_clean.info()
```

</details>

#### Part 4: Calculating periodic evolution

- Use the [shift()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.shift.html) method to create a new column containing the previous month's index.
- Calculate the difference between the current index and the shifted index to obtain the (percentage) evolution from one month to the next.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_clean['previous_index'] = df_clean['index'].shift(1)
df_clean['evolution'] = ((df_clean['index'] - df_clean['previous_index']) / df_clean['previous_index']) * 100

# Alternative method
df_clean['alternative_evolution'] = df_clean['index'].pct_change(periods=1) * 100
```

</details>

#### Part 5: Calculating year-over-year evolution

As you saw in the previous exercise's solution, the [pct_change()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pct_change.html) method allows you to calculate an evolution between two periods. Use this method to calculate a year-over-year evolution for each month.

```{python}
# Test your answer in this cell
```

<details>
<summary>Show solution</summary>

```{python}
df_clean["year_over_year_evolution"] = df_clean['index'].pct_change(periods=12) * 100
df_clean.head(20)
```

</details>
