::: {.content-visible when-profile="fr"}
---
title: "Calcul numérique avec NumPy"
---



En tant que statisticien, on est fréquemment amené à manipuler des séries de valeurs numériques, à partir desquelles on réalise diverses opérations mathématiques, des plus usuelles (moyenne, variance, etc.) aux plus complexes. On peut, comme on l'a fait dans les précédents tutoriels, utiliser les objets fondamentaux de Python, et en particulier les listes, pour réaliser de telles opérations. En pratique, on préférera utiliser la **librairie de référence pour le calcul scientifique**, `NumPy`, qui fournit à la fois des objets (les ***arrays***) et des fonctions qui vont grandement nous simplifier la vie pour effectuer tous nos calculs en Python de manière efficiente.


## NumPy 


On commence par importer la librairie `NumPy`. Comme expliqué dans un précédent tutoriel, l'usage est courant est de lui attribuer l'alias `np`. 

```{python}
import numpy as np
```

### Pourquoi utiliser NumPy ?


Plutôt que de présenter de manière abstraite les avantages de `NumPy`, illustrons ces derniers à travers un exemple simple : la multiplication terme à terme de deux vecteurs. 

On génère deux vecteurs contenant les entiers allant de $0$ à $99999$, que l'on multiplie terme à terme. On effectue cela d'abord via les listes Python (fonction `mult_list`), puis à l'aide de `NumPy` (fonction `mult_np`), et on compare les performances des deux méthodes.

```{python}
def mult_list(n):
    a = range(n)
    b = range(n)

    c = []
    for i in range(len(a)):
        mult = a[i] * b[i]
        c.append(mult)
        
    return c

def mult_np(n):
    a_np = np.arange(n)
    b_np = np.arange(n)
    
    c_np = a_np * b_np

    return c_np
```

```{python}
n = 100000
```

```{python}
# Vérification de la cohérence sur les 10 premiers éléments
print(mult_list(n)[:10])
print(mult_np(n)[:10])
```

```{python}
%%timeit -n10

mult_list(n)  # Performance de la méthode liste
```

```{python}
%%timeit -n10

mult_np(n)  # Performance de la méthode NumPy
```

Cet exemple illustre à lui seul les principaux avantages de `NumPy` pour le calcul scientifique : 

- les calculs sont **vectorisés** : multiplier deux *arrays* va naturellement effectuer la multiplication terme à terme, contrairement aux listes qui ne permettent pas cette opération. Les personnes travaillant avec `R` retrouveront là une propriété familière et bien pratique.

- conséquence de la vectorisation, **la syntaxe est plus légère et plus claire** : on voit directement l'opération qui est effectuée et on limite ainsi les risques d'erreur ;

- les calculs sont automatiquement **optimisés** par `NumPy` (via l'appel à du code `C` pré-compilé), réduisant très largement le temps mis par les opérations mathématiques (divisé par un facteur 10 dans notre exemple).


### Les *array* NumPy 


#### Définition


Toute la librairie `NumPy` est basée sur un objet fondamental : l'*array*. Un *array* est un objet qui contient une séquence de données, et présente deux caractéristiques principales :

- les données contenues dans un *array* doivent être de **type homogène**, là où une même liste peut contenir des objets de différente nature ;

- un *array* a une **taille fixée** à sa création, là où une liste peut grandir dynamiquement (en ajoutant des éléments via la méthode `append` par exemple).

Ce sont en grande partie ces deux contraintes qui rendent possible les gains de performance et la syntaxe lisible qu'offre `NumPy`.


#### Création


Il existe différentes manières de créer un *array*. La plus standard est de convertir une liste en *array* via la fonction *array* de `NumPy`.

```{python}
l = [1, 2, 3]
a = np.array(l)
print(a)
```

A première vue, la fonction `print` renvoie une représentation identique à celle d'une liste. Vérifions le type de notre objet. 

```{python}
type(a)
```

L'objet est de type `ndarray`, qui est le type standard correspondant à un *array* `NumPy`. 

On a vu qu'un *array* avait pour propriété de contenir des données de type homogène ; en l'occurrence, des entiers. On peut vérifier le type des données contenues via l'attribut `dtype` d'un *array*.

```{python}
a.dtype
```

Même si `NumPy` est avant tout une librairie dédiée au calcul numérique, il reste tout à fait possible de définir des `arrays` contenant des chaînes de caractères.

```{python}
b = np.array(['1', 'tigre'])
b.dtype
```

Le `dtype` par défaut des `arrays` contenant des chaînes de caractères est un peu particulier, mais cela n'a pas d'importance en pratique. Retenez simplement sa forme.

Enfin, question importante : que se passe-t-il si l'on essaie de définir un *array* contenant des objets de types hétérogènes ?

```{python}
c = np.array([1, 2, '3'])
print(c)
print(c.dtype)
```

Réponse : tous les objets sont convertis en chaîne de caractères par défaut.


#### Dimension


Les *array* correspondent en fait à des tableaux de données, c'est à dire qu'ils peuvent être uni- ou multi-dimensionnels. Un *array* de dimension 1 ressemble à un vecteur (ou une liste), un *array* de dimension 2 ressemble à une matrice, et ainsi de suite. 

On peut afficher le nombre de dimensions d'un *array* via l'attribut `ndim`.

```{python}
c = np.array([1, 2, '3'])
c.ndim
```

De la même manière que l'on a créé un *array* de dimension 1 à partir d'une liste simple, on peut créer un *array* multi-dimensionnel à partir d'une liste de listes.

```{python}
d = np.array([[1, 2, 3], [4, 5, 6]])
print(d)
```

On a converti une liste contenant 2 sous-listes à 3 éléments chacune, ce qui donne un *array* à deux dimensions. Notons que l'appel de `print` affiche une matrice à deux lignes et trois colonnes.

```{python}
d.ndim
```

On a bien affaire à un *array* à deux dimensions. Mais en pratique, lorsqu'on manipule des `arrays` multidimensionnels, on a aussi envie de connaître la *taille* de chacune des dimensions. En dimension 2, c'est le nombre de lignes et de colonnes. Pour cela, on utilise la méthode `shape`, qui renvoie un *tuple* contenant les tailles des différentes dimensions.

```{python}
d.shape
```

Le premier chiffre donne le nombre de lignes, le second le nombre de colonnes. On reviendra par la suite sur l'ordre des dimensions à travers la notion d'*axis*.


#### Indexation


On accède aux différents éléments d'un *array* de dimension 1 exactement de la même manière que ceux d'une liste.

```{python}
a = np.array([1, 2, 3, 4, 5, 6])

print(a)
print()
print(a[1])
print()
print(a[2:5])
print()
print(a[-2])
```

Pour un *array* multidimensionnel, il faut spécifier le ou les éléments voulus sur chacune des dimensions de l'*array*, en les séparant par des virgules. 

```{python}
b = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

print(b)
print()
print(b[1, 3])
print()
print(b[1:3, 1:3])
```

Pour accéder à une ligne complète, on peut utiliser `:` sur la dimension des colonnes pour spécifier : "toutes les colonnes". Et inversement pour récupérer une colonne complète.

```{python}
print(b[1,:])
print()
print(b[:,2])
```

#### Modification d'éléments


Les éléments d'un *array* peuvent être modifiés. On combine pour cela la syntaxe d'indexation vue précédemment avec l'opérateur d'assignation `=`.

```{python}
b = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

b[1, 1] = 18
print(b)
```

On peut également modifier des séries de nombres, voire des lignes/colonnes complètes, à condition d'assigner un élément de même taille.

```{python}
b = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

b[:, 2] = [-1, -1, -1]
b
```

Contrairement aux listes, on ne va généralement pas ajouter ou supprimer d'éléments à un *array*. La raison est que, comme indiqué précédemment, la taille d'un *array* est fixée à sa construction. 

Si l'on souhaite faire grandir un *array*, on va généralement le faire à partir d'une liste -- qui elle peut grandir -- que l'on convertit ensuite en *array*. 

Si l'on souhaite supprimer des éléments d'un *array*, on peut utiliser la syntaxe d'indexation étudiée dans la section précédente pour récupérer le sous-*array* qui nous intéresse, et assigner ce dernier à une nouvelle variable.


#### Masques booléens


Un gros avantage des *arrays* `NumPy` par rapport aux listes est qu'ils supportent les **masques booléens**, c'est à dire qu'on peut sélectionner des éléments d'un *array* en lui passant un *array* de même taille contenant des booléens.

```{python}
a = np.array([1, 2, 3])
a[[True, True, False]]
```

Cette propriété ouvre de nombreuses possibilités, dans la mesure où elle peut être combinée avec la propriété de vectorisation des *arrays*. Il devient ainsi très facile de **sélectionner des éléments selon des conditions**, même pour les *arrays* multidimensionnels.

```{python}
b = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
cond = (b > 6) & (b != 10)

print(cond)
print()
print(b[cond])
```

Et l'on peut bien entendu exploiter ce mécanisme pour modifier des éléments selon une condition.

```{python}
b[cond] = -1
print(b)
```

Ce dernier exemple illustre par ailleurs une propriété importante en `NumPy` appelée ***broadcasting*** : lorsque l'on remplace plusieurs éléments d'un *array* par un élément de taille 1 (et non un *array* de même taille), tous les éléments sont remplacés par cette valeur.


### Opérations mathématiques


#### Arithmétique sur les *arrays*


Tout au début de ce tutoriel, nous avons vu que multiplier deux *arrays* via l'opérateur `*` effectuait une multiplication termes à termes des deux *arrays*, et ce de manière vectorisée. Les opérations élémentaires (`+`, `-`, `*` et `/`) s'appliquent de la même manière aux *arrays* multidimensionnels.

```{python}
a = np.array([[1, 2, 2], [2, 2, 1]])
b = np.array([[3, 3, 1], [1, 3, 3]])

a * b
```

Notons qu'on retrouve la propriété de *broadcasting* discutée dans la section précédente : lorsque l'on effectue une opération entre un *array* et un nombre de taille 1, l'opération est appliquée à chaque terme de l'*array*.

```{python}
a * 4
```

#### Algèbre linéaire


`NumPy` permet de réaliser simplement et de manière efficiente des opérations d'algèbre linéaire sur les *arrays*. L'ensemble des fonctions disponibles sont présentées dans la [documentation officielle](https://numpy.org/doc/stable/reference/routines.linalg.html) (en Anglais).

Par exemple, l'opérateur `@` permet de réaliser une multiplication matricielle (et non plus termes à termes comme le fait `*`).

```{python}
a = np.array([[1, 2, 3], [3, 2, 1]])
b = np.array([[2, 3], [1, 3], [3, 1]])

a @ b
```

#### Fonctions mathématiques


`NumPy` offre pléthore de fonctions [mathématiques](https://numpy.org/doc/stable/reference/routines.math.html) et [statistiques](https://numpy.org/doc/stable/reference/routines.statistics.html), comme `sum`, `mean`, `min`, `round`, `log`, etc. Leur application à des objets unidimensionnels ne pose pas de problème particulier.

```{python}
print(np.log(12))
print()
print(np.min([1, 2, 3]))
print()
print(np.mean([1, 2, 3]))
```

En revanche, dans le cas multidimensionnel, leur utilisation devient un peu plus subtile car on peut vouloir réaliser l'agrégation selon différentes dimensions. Si l'on ne spécifie rien, l'agrégation est effectuée sur tous les éléments de l'*array*.

```{python}
a = np.array([[1, 2, 2], [2, 2, 1]])

np.sum(a)
```

Mais comment faire si l'on veut sommer par ligne ? Ou bien par colonne ? C'est là qu'intervient un élément crucial et assez complexe des fonctions de `NumPy` : le paramètre `axis`, qui spécifie la dimension selon laquelle est effectuée l'opération.

Lorsqu'il n'est pas spécifié comme dans l'exemple précédent, il prend la valeur `None` par défaut.

```{python}
a = np.array([[1, 2, 2], [2, 2, 1]])

np.sum(a, axis=None)  # idem que np.sum(a)
```

La figure suivante permet de bien se représenter la manière dont fonctionnent les axes avec `NumPy`, afin de bien spécifier le sens attendu de l'agrégation.

![axis](img/axes.png)

Ainsi, si l'on souhaite calculer la somme de chaque colonne par exemple, il faut agréger selon l'axe $0$.

```{python}
a = np.array([[1, 2, 2], [2, 2, 1]])

np.sum(a, axis=0)
```

Et inversement pour obtenir les sommes de chaque ligne.

```{python}
np.sum(a, axis=1)
```

Enfin, notons que les fonctions mathématiques qui réalisent une agrégation sont généralement également disponibles comme *méthodes* d'un *array*. Elles fonctionnent de la même manière, au détail près qu'elles ne prennent pas l'*array* en argument dans la mesure où elles sont déjà "attachées" à celui-ci.

```{python}
a.sum(axis=1)
```

### Conclusion


`NumPy` est la librairie quasi-standard de calcul scientifique en Python. Elle est à privilégier dès lors que vous souhaitez effectuer des opérations sur des données numériques, *a fortiori* lorsqu'il s'agit d'opérations vectorisées et/ou mobilisant des objets multidimensionnels comme des matrices.

Les possibilités offertes par `NumPy` sont gigantesques, et nous n'en avons vu qu'un aperçu. La [documentation officielle](https://numpy.org/doc/stable/user/) présente l'ensemble de ces possibilités. Cette [*cheat sheet*](https://assets.datacamp.com/blog_assets/Numpy_Python_Cheat_Sheet.pdf) peut également s'avérer utile en cas d'oubli. Nous verrons également des fonctions supplémentaires à travers les exercices de fin de chapitre.


## Exercices


### Questions de compréhension



- 1/ Quels sont les principaux avantages de `NumPy` ?

- 2/ Quelles sont les deux caractéristiques principales d'un *array* `NumPy` ?

- 3/ Que se passe-t-il si l'on essaie de définir un *array* contenant des objets de types hétérogènes ?

- 4/ Quelle est la principale méthode pour créer un *array* ?

- 5/ Quelles informations contient l'attribut `shape` d'un array ?

- 6/ Peut-on ajouter un élément à un *array* ? Supprimer un élément ?

- 7/ Qu'est-ce qu'un masque booléen et à quoi cela sert-il ?

- 8/ Qu'est-ce que la propriété de *broadcasting* ?

- 9/ A quoi sert le paramètre `axis` des fonctions mathématiques de `NumPy` ?

<details>
<summary>Afficher la solution</summary>

- 1/ Les calculs sont vectorisés, ce qui simplifie grandement la syntaxe et réduit donc les risques d'erreur. Par ailleurs, les calculs sont optimisés automatiquement par NumPy, ce qui accroît très fortement les performances.

- 2/ Les données contenues dans un array doivent être de type homogène. Un array a une taille fixée lors de sa création.

- 3/ Tous les objets sont interprétés comme des chaînes de caractères.

- 4/ Créer une liste et la convertir ensuite en array via la fonction np.array.

- 5/ L'attribut shape d'un array renvoie un tuple qui contient la taille de chaque dimension, et donc également le nombre de dimensions.

- 6/ Il existe des fonctions qui effectuent ces opérations, mais elles ne sont pas très utilisées en pratique, dans la mesure où un array est de taille fixée lors de sa création.

- 7/ Un masque booléen est un array de valeurs booléennes (True et False), que l'on va utiliser pour sélectionner des éléments d'un autre array. C'est notamment très pratique pour sélectionner des éléments selon une condition (test).

- 8/ Lorsqu'on effectue une opération entre un array et une valeur de taille 1 (typiquement, un entier ou un réel), l'opération est appliquée à chaque élément de l'array.

- 9/ Le paramètre axis sert à spécifier la dimension selon laquelle on souhaite performer une agrégation (fonction math, stat..).

</details>

### Manipulations simples des données d'un DataFrame


Un vecteur comprenant les entiers compris entre 10 et 20 est défini dans la cellule suivante. En utilisant l'indexation des *arrays* `NumPy` :

- sélectionner les éléments aux positions 1, 3 et 4

- sélectionner tous les éléments sauf le premier

- sélectionner tous les éléments sauf le premier et le dernier

- sélectionner les 3 premiers éléments

- sélectionner les 5 derniers éléments

- sélectionner tous les éléments pairs

- sélectionner tous les éléments en les triant dans l'ordre inverse (NB : la fonction `np.flip` permet de faire la même chose)

```{python}
X = np.arange(10, 21)

print(X)
```

```{python}
# Testez votre réponse dans cette cellule

```

<details>
<summary>Afficher la solution</summary>

```python
X = np.arange(10, 21)

print(X[[1, 3, 4]])
print(X[1:])
print(X[1:-1])
print(X[:3])
print(X[-5:])
print(X[::2])
print(X[::-1])
```

</details>

### Sélectionner des éléments dans une matrice


Une matrice de taille 5x5 comprenant tous les entiers compris entre 0 et 24 est définie dans la cellule suivante. En utilisant l'indexation des *arrays* `NumPy` :

- sélectionner la valeur $19$

- sélectionner la 2ème ligne

- sélectionner la 4ème colonne

- sélectionner la sous-matrice 3x3 centrale

- sélectionner les éléments diagonaux (NB : la fonction `np.diag` permet de réaliser la même opération de manière beaucoup plus simple)

```{python}
Y = np.arange(0, 25).reshape((5, 5))

print(Y)
```

```{python}
# Testez votre réponse dans cette cellule

```

<details>
<summary>Afficher la solution</summary>

```python
Y = np.arange(0, 25).reshape((5, 5))

print(Y[3, 4])
print(Y[1, :])
print(Y[:, 3])
print(Y[1:4, 1:4])
print(Y[np.arange(0, 5), np.arange(0, 5)])
```

</details>

### Un peu de calcul


Deux matrices carrées de taille 3x3 sont définies sous forme d'*arrays* `NumPy` dans la cellule suivante. A partir de ces matrices, réaliser les opérations mathématiques suivantes :

- multiplier tous les éléments de `X` par 3

- diviser les éléments de `Y` par ceux de `X`

- passer tous les éléments de `Y` au `log`

- passer tous les éléments de `X` au carré

- faire une multiplication matricielle de `X` et `Y`

- transposer la matrice `Y`

NB : vous pourrez trouver les fonctions nécessaires dans la [documentation](https://numpy.org/doc/stable/reference/routines.math.html) ou via un moteur de recherche.

```{python}
X = np.array([[1,2,3],
              [4,5,6],
              [7,8,9]])

Y = np.array([[10,11,12],
              [13,14,15],
              [16,17,18]])
```

```{python}
# Testez votre réponse dans cette cellule

```

<details>
<summary>Afficher la solution</summary>

```python
X = np.array([[1,2,3],
              [4,5,6],
              [7,8,9]])

Y = np.array([[10,11,12],
              [13,14,15],
              [16,17,18]])

print(3 * X)
print()
print(Y / X)
print()
print(np.log(Y))
print()
print(np.square(X))
print()
print(Y @ X)
print()
print(Y.T)
```

</details>

### Initialisation d'*arrays* de diverses natures


Dans le tutoriel, nous avons vu que la méthode standard pour créer un *array* `NumPy` consistait à initialiser une liste, que l'on convertit ensuite en *array*. On peut également utiliser des fonctions natives de `NumPy` qui créent des *array* d'une taille donnée, contenant des valeurs basiques (ex : valeurs "quasi-vides", zéros, uns, une valeur spécifiée par l'utilisateur, etc.).

Par exemple, pour créer une matrice à 3 lignes et deux colonnes contenant des zéros, la syntaxe est : 

```{python}
np.zeros((3, 2))
```

En vous référant à la [documentation](https://numpy.org/doc/stable/reference/routines.array-creation.html) de ces fonctions, générer :


- un vecteur (array à 1 dimension), contenant 18 fois la valeur $1$ (fonction `np.ones`)

- un array à 3 dimensions, respectivement de tailles 2, 3 et 5, contenant uniquement des zéros (fonction `np.zeros`)

- une matrice (array à 2 dimensions), à 4 lignes et 3 colonnes, contenant uniquement la valeur 5 (fonction `np.full`)

- une matrice identité de taille 5, i.e. une matrice à 5 lignes et 5 colonnes, contenant des $1$ sur sa diagonale et des $0$ partout ailleurs (fonction `np.eye`)

- un vecteur contenant les entiers compris entre $0$ à $99$ inclus (fonction `np.arange`)

- un vecteur contenant les entiers *pairs* compris entre $0$ à $99$ inclus (fonction `np.arange`)

- un vecteur contenant 5 valeurs uniformément espacées entre $2$ et $3$ inclus (fonction `np.linspace`)

```{python}
# Testez votre réponse dans cette cellule

```

<details>
<summary>Afficher la solution</summary>

```python
a = np.ones((18,))
print(a)
print()

b = np.zeros((2, 3, 5))
print(b)
print()

c = np.full((4, 3), fill_value=5)
print(c)
print()

d = np.eye(5)
print(d)
print()

e = np.arange(0, 100)
print(e)
print()

x = np.arange(0, 100, step=2)
print(x)
print()

y = np.linspace(2.0, 3.0, num=5)
print(y)
print()
```

</details>

### Tirage d'un vecteur selon une loi normale


En vous référant à la [documentation](https://numpy.org/doc/stable/reference/random/generator.html) des fonctions de génération de nombres aléatoires de `NumPy`, générer un vecteur `X` de taille 10000, contenant des nombres tirés selon une loi normale de moyenne 0 et de variance 2.

Vérifiez ensuite à l'aide des fonctions mathématiques de `NumPy` que la moyenne et la variance de votre échantillon sont cohérents par rapport aux valeurs attendues.

Indice : attention à la manière dont est spécifiée la variance dans la fonction `NumPy` de génération d'une loi normale. 

```{python}
# Testez votre réponse dans cette cellule

```

<details>
<summary>Afficher la solution</summary>

```python
X = np.random.normal(0, np.sqrt(2), 10000)

print(np.mean(X), np.var(X))
```

</details>

### Tirage d'une matrice selon une loi uniforme


En vous référant à la [documentation](https://numpy.org/doc/stable/reference/random/generator.html) des fonctions de génération de nombres aléatoires de `NumPy`, générer une matrice `U` de taille 1000 par 1000, contenant des nombres tirés selon une loi uniforme dans l'intervalle [-1, 1].

En utilisant la fonction `np.all` et un test booléen, vérifier que tous les nombres contenus dans `U` sont bien compris entre -1 et 1.

```{python}
# Testez votre réponse dans cette cellule

```

<details>
<summary>Afficher la solution</summary>

```python
N = 1000
U = np.random.uniform(-1, 1, size=(N, N))

np.all((U >= -1) & (U <= 1))
```

</details>

### Binariser une matrice de nombres


On peut parfois avoir besoin de binariser une matrice numérique, c'est à dire de fixer un seuil au delà duquel les valeurs numériques sont fixées à 1, et à 0 en-dessous. `NumPy` propose plusieurs méthodes pour réaliser une telle opération, nous allons en voir deux. 

Dans la cellule suivante, une matrice `X` à 6 lignes et 6 colonnes est générée, qui comprend des entiers aléatoirement choisis entre 0 et 49. Vous devez binariser cette matrice de deux manières différentes **sans l'écraser** (i.e. la matrice binaire doit être assignée à une autre variable que `X` et `X` ne doit pas être modifiée) :

- première méthode : en utilisant la fonction `np.zeros` et les masques booléens

- seconde méthode : en utilisant la fonction `np.where` (cf. [doc](https://numpy.org/doc/stable/reference/generated/numpy.where.html))

```{python}
X = np.random.randint(0, 50, size=(6, 6))
```

```{python}
# Testez votre réponse dans cette cellule

```

<details>
<summary>Afficher la solution</summary>

```python
X = np.random.randint(0, 50, size=(6, 6))

# Première possibilité : via les masques booléens
A = np.zeros((6, 6))
A[X > 25] = 1

# Deuxième possibilité : via la fonction np.where
B = np.where(X > 25, 1, 0)

print(X)
print()
print(A)
print()
print(B)
```

</details>

### Touché-coulé


L'objectif de cet exercice est de programmer seulement à l'aide d'objets et de fonctions de `NumPy` un touché-coulé très basique. 

Une grille de 5x5 est définie dans la cellule suivante comme un *array*, les valeurs $1$ symbolisant la présence d'un bateau. Vous devez programmer une fonction `shoot` qui :

- prend en input une coordonnée $x$ (indice de la ligne) et une cordonnée $y$ (indice de la colonne)

- teste si au moins une valeur $1$ est présente dans la grille :

  - si oui : 

    - s'il y a un bateau à l'adresse (x, y), remplacer la valeur $1$ par $2$ et `print` "Touché !"

    - sinon, `print` "Raté !"

  - si non :

    - `print` "Fin de partie !"
    
Puis réalisez quelques tests pour vous assurer que votre fonction marche comme attendu.

```{python}
X = np.array([[1, 1, 1, 0, 0], [0, 0, 0, 0, 1], [1, 0, 0, 0, 1],
              [1, 0, 0, 0, 0], [0, 1, 1, 1, 1]])
print(X)
```

```{python}
# Testez votre réponse dans cette cellule

```

<details>
<summary>Afficher la solution</summary>

```python
X = np.array([[1, 1, 1, 0, 0], [0, 0, 0, 0, 1], [1, 0, 0, 0, 1],
              [1, 0, 0, 0, 0], [0, 1, 1, 1, 1]])

def shoot(x, y):
    if np.any(X == 1):
        if X[x, y] == 1:
            print("Touché !")
            X[x, y] = 2
        else:
            print("Raté !")
        print(X)
        print()
    else:
        print("Fin de partie !")

shoot(0, 1)
shoot(1, 0)
shoot(0, 2)
```

</details>

### One Hot Encoding


En statistique, il est fréquent de vouloir encoder numériquement un vecteur de catégories. Une manière fréquente d'encoder des catégories est le *one hot encoding* (OHE) : chaque valeur est représentée par un vecteur binaire, qui contient un $1$ sur la colonne correspondant à la catégorie et des $0$ partout ailleurs.

Dans la cellule suivante, on encode des PCS au format OHE grâce à une fonction du package `scikit-learn`. L'objectif de l'exercice est de reproduire cet encodage en utilisant uniquement des fonctions de la librairie `NumPy`.

Indice : on pourra utiliser les fonctions `np.unique`, `np.zeros` et `np.arange`.

```{python}
from sklearn.preprocessing import OneHotEncoder

values = np.array(["21", "46", "47", "23", "66", "82", "82"])

print(OneHotEncoder().fit_transform(values.reshape((-1, 1))).todense())
```

```{python}
# Testez votre réponse dans cette cellule

```

<details>
<summary>Afficher la solution</summary>

```python
values = np.array(["21", "46", "47", "23", "66", "82", "82"])

categories, pos = np.unique(values, return_inverse=True)
n_values = values.shape[0]
n_categories = categories.shape[0]

ohe = np.zeros((n_values, n_categories))
ohe[np.arange(n_values), pos] = 1
ohe
```

</details>

:::















::: {.content-visible when-profile="en"}

# Numerical computing with NumPy

As a statistician, you frequently need to manipulate series of numerical values and perform various mathematical operations, from the most common (mean, variance, etc.) to the more complex. As we did in previous tutorials, you can use Python's fundamental objects, particularly lists, to perform such operations. However, in practice, you will prefer to use the **reference library for scientific computing**, `NumPy`, which provides both objects (***arrays***) and functions that greatly simplify performing all your calculations in Python efficiently.

## NumPy

We start by importing the `NumPy` library. As explained in a previous tutorial, it is common practice to assign it the alias `np`.

```{python}
import numpy as np
```

### Why use NumPy?

Rather than presenting the advantages of `NumPy` abstractly, let's illustrate them through a simple example: element-wise multiplication of two vectors.

We generate two vectors containing integers from $0$ to $99999$, which we multiply element-wise. We first perform this using Python lists (function `mult_list`), then using `NumPy` (function `mult_np`), and compare the performance of both methods.

```{python}
def mult_list(n):
    a = range(n)
    b = range(n)

    c = []
    for i in range(len(a)):
        mult = a[i] * b[i]
        c.append(mult)
        
    return c

def mult_np(n):
    a_np = np.arange(n)
    b_np = np.arange(n)
    
    c_np = a_np * b_np

    return c_np
```

```{python}
n = 100000
```

```{python}
# Verify consistency on the first 10 elements
print(mult_list(n)[:10])
print(mult_np(n)[:10])
```

```{python}
%%timeit -n10

mult_list(n)  # Performance of the list method
```

```{python}
%%timeit -n10

mult_np(n)  # Performance of the NumPy method
```

This example illustrates the main advantages of `NumPy` for scientific computing:

- Calculations are **vectorized**: multiplying two arrays naturally performs element-wise multiplication, unlike lists which do not support this operation. People familiar with `R` will recognize this as a familiar and very convenient property.
- As a result of vectorization, **the syntax is lighter and clearer**: you directly see the operation being performed, reducing the risk of error.
- Calculations are automatically **optimized** by `NumPy` (through calls to pre-compiled `C` code), significantly reducing the time taken for mathematical operations (by a factor of 10 in our example).

### NumPy arrays

#### Definition

The entire `NumPy` library is based on a fundamental object: the array. An array is an object that contains a sequence of data and has two main characteristics:

- The data contained in an array must be of **homogeneous type**, whereas a single list can contain objects of different natures.
- An array has a **fixed size** at creation, whereas a list can dynamically grow (e.g., by adding elements via the `append` method).

These two constraints largely enable the performance gains and readable syntax that `NumPy` offers.

#### Creation

There are different ways to create an array. The most standard way is to convert a list into an array using the `array` function from `NumPy`.

```{python}
l = [1, 2, 3]
a = np.array(l)
print(a)
```

At first glance, the `print` function returns a representation identical to that of a list. Let's check the type of our object.

```{python}
type(a)
```

The object is of type `ndarray`, which is the standard type corresponding to a `NumPy` array.

We have seen that an array has the property of containing homogeneous data types; in this case, integers. We can check the type of the data contained using the `dtype` attribute of an array.

```{python}
a.dtype
```

Although `NumPy` is primarily a library for numerical computation, it is entirely possible to define arrays containing strings.

```{python}
b = np.array(['1', 'tiger'])
b.dtype
```

The default `dtype` of arrays containing strings is a bit peculiar, but this doesn't matter in practice. Just remember its form.

Finally, an important question: what happens if you try to define an array containing objects of heterogeneous types?

```{python}
c = np.array([1, 2, '3'])
print(c)
print(c.dtype)
```

Answer: all objects are converted to strings by default.

#### Dimension

Arrays correspond to data tables, meaning they can be uni- or multi-dimensional. A 1-dimensional array looks like a vector (or list), a 2-dimensional array looks like a matrix, and so on.

You can display the number of dimensions of an array using the `ndim` attribute.

```{python}
c = np.array([1, 2, '3'])
c.ndim
```

Just as we created a 1-dimensional array from a simple list, we can create a multi-dimensional array from a list of lists.

```{python}
d = np.array([[1, 2, 3], [4, 5, 6]])
print(d)
```

We converted a list containing 2 sub-lists with 3 elements each, resulting in a 2-dimensional array. Note that calling `print` displays a matrix with two rows and three columns.

```{python}
d.ndim
```

We indeed have a 2-dimensional array. However, in practice, when handling multidimensional arrays, we also want to know the size of each dimension. In 2 dimensions, it's the number of rows and columns. For this, we use the `shape` method, which returns a tuple containing the sizes of the different dimensions.

```{python}
d.shape
```

The first number gives the number of rows, the second the number of columns. We will revisit the order of dimensions later through the notion of *axis*.

#### Indexing

You access the elements of a 1-dimensional array in the same way as those of a list.

```{python}
a = np.array([1, 2, 3, 4, 5, 6])

print(a)
print()
print(a[1])
print()
print(a[2:5])
print()
print(a[-2])
```

For a multidimensional array, you need to specify the desired elements for each dimension of the array, separated by commas.

```{python}
b = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

print(b)
print()
print(b[1, 3])
print()
print(b[1:3, 1:3])
```

To access a complete row, you can use `:` for the column dimension to specify "all columns". Conversely, to retrieve a complete column.

```{python}
print(b[1,:])
print()
print(b[:,2])
```

#### Modifying elements

Array elements can be modified. To do this, combine the indexing syntax seen earlier with the assignment operator `=`.

```{python}
b = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

b[1, 1] = 18
print(b)
```

You can also modify series of numbers, or even complete rows/columns, as long as you assign an element of the same size.

```{python}
b = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

b[:, 2] = [-1, -1, -1]
b
```

Unlike lists, you generally do not add or remove elements from an array. This is because, as stated earlier, an array's size is fixed at creation.

If you want to grow an array, you typically do so by starting with a list — which can grow — and then converting it to an array.

If you want to delete elements from an array, you can use the indexing syntax studied in the previous section to retrieve the sub-array of interest and assign it to a new variable.

#### Boolean masks

A significant advantage of `NumPy` arrays over lists is that they support **boolean masks**, allowing you to select elements of an array by passing an array of the same size containing booleans.

```{python}
a = np.array([1, 2, 3])
a[[True, True, False]]
```

This property opens many possibilities since it can be combined with the vectorization property of arrays. It becomes very easy to **select elements according to conditions**, even for multidimensional arrays.

```{python}
b = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
cond = (b > 6) & (b != 10)

print(cond)
print()
print(b[cond])
```

And you can, of course, exploit this mechanism to modify elements according to a condition.

```{python}
b[cond] = -1
print(b)
```

This last example also illustrates an important property in `NumPy` called ***broadcasting***: when replacing multiple elements of an array with a single-size element (not an array of the same size), all elements are replaced by this value.

### Mathematical operations

#### Arithmetic on arrays

At the beginning of this tutorial, we saw that multiplying two arrays using

 the `*` operator performs element-wise multiplication of the two arrays in a vectorized manner. Basic operations (`+`, `-`, `*`, and `/`) apply similarly to multidimensional arrays.

```{python}
a = np.array([[1, 2, 2], [2, 2, 1]])
b = np.array([[3, 3, 1], [1, 3, 3]])

a * b
```

We again see the broadcasting property discussed in the previous section: when you perform an operation between an array and a single-size number, the operation is applied to each term in the array.

```{python}
a * 4
```

#### Linear algebra

`NumPy` allows you to perform simple and efficient linear algebra operations on arrays. The complete list of available functions is presented in the [official documentation](https://numpy.org/doc/stable/reference/routines.linalg.html) (in English).

For example, the `@` operator performs matrix multiplication (and no longer element-wise multiplication like `*`).

```{python}
a = np.array([[1, 2, 3], [3, 2, 1]])
b = np.array([[2, 3], [1, 3], [3, 1]])

a @ b
```

#### Mathematical functions

`NumPy` offers a plethora of [mathematical](https://numpy.org/doc/stable/reference/routines.math.html) and [statistical](https://numpy.org/doc/stable/reference/routines.statistics.html) functions, such as `sum`, `mean`, `min`, `round`, `log`, etc. Applying them to one-dimensional objects poses no particular problem.

```{python}
print(np.log(12))
print()
print(np.min([1, 2, 3]))
print()
print(np.mean([1, 2, 3]))
```

However, in the multidimensional case, their use becomes a bit more subtle because you may want to aggregate along different dimensions. If nothing is specified, the aggregation is done over all the array elements.

```{python}
a = np.array([[1, 2, 2], [2, 2, 1]])

np.sum(a)
```

But how do you sum by rows? Or by columns? This is where a crucial and somewhat complex element of `NumPy` functions comes in: the `axis` parameter, which specifies the dimension along which to perform the operation.

When not specified, as in the previous example, it defaults to `None`.

```{python}
a = np.array([[1, 2, 2], [2, 2, 1]])

np.sum(a, axis=None)  # same as np.sum(a)
```

The following figure helps visualize how axes work with `NumPy`, to specify the expected direction of aggregation correctly.

![axis](img/axes.png)

Thus, if you want to compute the sum of each column, for example, you need to aggregate along axis $0$.

```{python}
a = np.array([[1, 2, 2], [2, 2, 1]])

np.sum(a, axis=0)
```

Conversely, to get the sums of each row.

```{python}
np.sum(a, axis=1)
```

Finally, note that mathematical functions that perform aggregation are generally also available as *methods* of an array. They work the same way, except that they do not take the array as an argument since they are already "attached" to it.

```{python}
a.sum(axis=1)
```

### Conclusion

`NumPy` is the quasi-standard library for scientific computing in Python. It is preferred whenever you want to perform operations on numerical data, especially when dealing with vectorized operations and/or multidimensional objects like matrices.

The possibilities offered by `NumPy` are vast, and we have only seen a glimpse. The [official documentation](https://numpy.org/doc/stable/user/) presents all these possibilities. This [*cheat sheet*](https://assets.datacamp.com/blog_assets/Numpy_Python_Cheat_Sheet.pdf) can also be useful in case of forgetfulness. We will also see additional functions through the end-of-chapter exercises.

## Exercises

### Questions de compréhension

- 1/ What are the main advantages of `NumPy`?
- 2/ What are the two main characteristics of a `NumPy` array?
- 3/ What happens if you try to define an array containing objects of heterogeneous types?
- 4/ What is the primary method for creating an array?
- 5/ What information does the `shape` attribute of an array contain?
- 6/ Can you add an element to an array? Remove an element?
- 7/ What is a boolean mask, and what is it used for?
- 8/ What is the broadcasting property?
- 9/ What is the purpose of the `axis` parameter in `NumPy`'s mathematical functions?

<details>
<summary>Show the solution</summary>

- 1/ Calculations are vectorized, which greatly simplifies syntax and reduces the risk of errors. Additionally, calculations are automatically optimized by `NumPy`, significantly increasing performance.
- 2/ The data contained in an array must be of homogeneous type. An array has a fixed size at creation.
- 3/ All objects are interpreted as strings.
- 4/ Create a list and then convert it to an array using the `np.array` function.
- 5/ The `shape` attribute of an array returns a tuple that contains the size of each dimension, and thus also the number of dimensions.
- 6/ There are functions that perform these operations, but they are not commonly used in practice since an array has a fixed size at creation.
- 7/ A boolean mask is an array of boolean values (`True` and `False`) used to select elements from another array. It is particularly useful for selecting elements based on a condition (test).
- 8/ When you perform an operation between an array and a single-size value (typically, an integer or a real number), the operation is applied to each element of the array.
- 9/ The `axis` parameter specifies the dimension along which you want to perform an aggregation (math, stat functions, etc.).

</details>

### Simple manipulations of a DataFrame's data

A vector containing integers between 10 and 20 is defined in the following cell. Using `NumPy` array indexing:

- Select the elements at positions 1, 3, and 4
- Select all elements except the first one
- Select all elements except the first and the last one
- Select the first 3 elements
- Select the last 5 elements
- Select all even elements
- Select all elements in reverse order (NB: the `np.flip` function can achieve the same result)

```{python}
X = np.arange(10, 21)

print(X)
```

```{python}
# Test your answer in this cell

```

<details>
<summary>Show the solution</summary>

```{python}
X = np.arange(10, 21)

print(X[[1, 3, 4]])
print(X[1:])
print(X[1:-1])
print(X[:3])
print(X[-5:])
print(X[::2])
print(X[::-1])
```

</details>

### Selecting elements in a matrix

A 5x5 matrix containing integers from 0 to 24 is defined in the following cell. Using `NumPy` array indexing:

- Select the value $19$
- Select the 2nd row
- Select the 4th column
- Select the central 3x3 submatrix
- Select the diagonal elements (NB: the `np.diag` function can perform the same operation much more easily)

```{python}
Y = np.arange(0, 25).reshape((5, 5))

print(Y)
```

```{python}
# Test your answer in this cell

```

<details>
<summary>Show the solution</summary>

```{python}
Y = np.arange(0, 25).reshape((5, 5))

print(Y[3, 4])
print(Y[1, :])
print(Y[:, 3])
print(Y[1:4, 1:4])
print(Y[np.arange(0, 5), np.arange(0, 5)])
```

</details>

### Some calculations

Two 3x3 square matrices are defined as `NumPy` arrays in the following cell. Based on these matrices, perform the following mathematical operations:

- Multiply all elements of `X` by 3
- Divide the elements of `Y` by those of `X`
- Apply the `log` function to all elements of `Y`
- Square all elements of `X`
- Perform matrix multiplication of `X` and `Y`
- Transpose the `Y` matrix

NB: You can find the necessary functions in the [documentation](https://numpy.org/doc/stable/reference/routines.math.html) or using a search engine.

```{python}
X = np.array([[1,2,3],
              [4,5,6],
              [7,8,9]])

Y = np.array([[10,11,12],
              [13,14,15],
              [16,17,18]])
```

```{python}
# Test your answer in this cell

```

<details>
<summary>Show the solution</summary>

```{python}
X = np.array([[1,2,3],
              [4,5,6],
              [7,8,9]])

Y = np.array([[10,11,12],
              [13,14,15],
              [16,17,18]])

print(3 * X)
print()
print(Y / X)
print()
print(np.log(Y

))
print()
print(np.square(X))
print()
print(Y @ X)
print()
print(Y.T)
```

</details>

### Initializing arrays of various types

In the tutorial, we saw that the standard method to create a `NumPy` array is to initialize a list and then convert it to an array. You can also use native `NumPy` functions that create arrays of a given size containing basic values (e.g., near-empty values, zeros, ones, a user-specified value, etc.).

For example, to create a 3x2 matrix containing zeros, the syntax is:

```{python}
np.zeros((3, 2))
```

Referring to the [documentation](https://numpy.org/doc/stable/reference/routines.array-creation.html) of these functions, generate:

- A vector (1-dimensional array) containing the value $1$ repeated 18 times (using the `np.ones` function)
- A 3-dimensional array with sizes 2, 3, and 5 respectively, containing only zeros (using the `np.zeros` function)
- A matrix (2-dimensional array) with 4 rows and 3 columns, containing only the value 5 (using the `np.full` function)
- A 5x5 identity matrix, i.e., a matrix with 5 rows and 5 columns containing $1$ on its diagonal and $0$ elsewhere (using the `np.eye` function)
- A vector containing integers from $0$ to $99$ inclusive (using the `np.arange` function)
- A vector containing even integers from $0$ to $99$ inclusive (using the `np.arange` function)
- A vector containing 5 values evenly spaced between $2$ and $3$ inclusive (using the `np.linspace` function)

```{python}
# Test your answer in this cell

```

<details>
<summary>Show the solution</summary>

```{python}
a = np.ones((18,))
print(a)
print()

b = np.zeros((2, 3, 5))
print(b)
print()

c = np.full((4, 3), fill_value=5)
print(c)
print()

d = np.eye(5)
print(d)
print()

e = np.arange(0, 100)
print(e)
print()

x = np.arange(0, 100, step=2)
print(x)
print()

y = np.linspace(2.0, 3.0, num=5)
print(y)
print()
```

</details>

### Drawing a vector from a normal distribution

Referring to the [documentation](https://numpy.org/doc/stable/reference/random/generator.html) of `NumPy`'s random number generation functions, generate a vector `X` of size 10000 containing numbers drawn from a normal distribution with mean 0 and variance 2.

Then verify using `NumPy`'s mathematical functions that the mean and variance of your sample are consistent with the expected values.

Hint: Pay attention to how the variance is specified in the `NumPy` function for generating a normal distribution.

```{python}
# Test your answer in this cell

```

<details>
<summary>Show the solution</summary>

```{python}
X = np.random.normal(0, np.sqrt(2), 10000)

print(np.mean(X), np.var(X))
```

</details>

### Drawing a matrix from a uniform distribution

Referring to the [documentation](https://numpy.org/doc/stable/reference/random/generator.html) of `NumPy`'s random number generation functions, generate a matrix `U` of size 1000 by 1000 containing numbers drawn from a uniform distribution in the interval [-1, 1].

Using the `np.all` function and a boolean test, verify that all numbers in `U` are indeed between -1 and 1.

```{python}
# Test your answer in this cell

```

<details>
<summary>Show the solution</summary>

```{python}
N = 1000
U = np.random.uniform(-1, 1, size=(N, N))

np.all((U >= -1) & (U <= 1))
```

</details>

### Binarizing a matrix of numbers

Sometimes, you may need to binarize a numerical matrix, meaning to set a threshold beyond which numerical values are set to 1 and to 0 below. `NumPy` offers several methods for performing such an operation; we will see two.

In the following cell, a 6x6 matrix `X` is generated, containing integers randomly chosen between 0 and 49. You need to binarize this matrix in two different ways **without overwriting it** (i.e., the binary matrix should be assigned to a different variable than `X`, and `X` should not be modified):

- First method: using the `np.zeros` function and boolean masks
- Second method: using the `np.where` function (see [doc](https://numpy.org/doc/stable/reference/generated/numpy.where.html))

```{python}
X = np.random.randint(0, 50, size=(6, 6))
```

```{python}
# Test your answer in this cell

```

<details>
<summary>Show the solution</summary>

```{python}
X = np.random.randint(0, 50, size=(6, 6))

# First possibility: using boolean masks
A = np.zeros((6, 6))
A[X > 25] = 1

# Second possibility: using the np.where function
B = np.where(X > 25, 1, 0)

print(X)
print()
print(A)
print()
print(B)
```

</details>

### Battleship

The objective of this exercise is to program a very basic battleship game using only `NumPy` objects and functions.

A 5x5 grid is defined in the following cell as an array, with $1$ values representing the presence of a ship. You need to program a `shoot` function that:

- Takes as input an $x$ coordinate (row index) and a $y$ coordinate (column index)
- Tests if at least one $1$ value is present in the grid:
  - If yes:
    - If there is a ship at the address (x, y), replace the $1$ value with $2$ and `print` "Hit!"
    - Otherwise, `print` "Missed!"
  - If no:
    - `print` "Game over!"

Then perform some tests to ensure your function works as expected.

```{python}
X = np.array([[1, 1, 1, 0, 0], [0, 0, 0, 0, 1], [1, 0, 0, 0, 1],
              [1, 0, 0, 0, 0], [0, 1, 1, 1, 1]])
print(X)
```

```{python}
# Test your answer in this cell

```

<details>
<summary>Show the solution</summary>

```{python}
X = np.array([[1, 1, 1, 0, 0], [0, 0, 0, 0, 1], [1, 0, 0, 0, 1],
              [1, 0, 0, 0, 0], [0, 1, 1, 1, 1]])

def shoot(x, y):
    if np.any(X == 1):
        if X[x, y] == 1:
            print("Hit!")
            X[x, y] = 2
        else:
            print("Missed!")
        print(X)
        print()
    else:
        print("Game over!")

shoot(0, 1)
shoot(1, 0)
shoot(0, 2)
```

</details>

### One Hot Encoding

In statistics, it is common to numerically encode a vector of categories. A frequent way to encode categories is *one hot encoding* (OHE): each value is represented by a binary vector, containing a $1$ in the column corresponding to the category and $0$ elsewhere.

In the following cell, we encode PCS in OHE format using a function from the `scikit-learn` package. The exercise's objective is to reproduce this encoding using only `NumPy` library functions.

Hint: You can use the `np.unique`, `np.zeros`, and `np.arange` functions.

```{python}
from sklearn.preprocessing import OneHotEncoder

values = np.array(["21", "46", "47", "23", "66", "82", "82"])

print(OneHotEncoder().fit_transform(values.reshape((-1, 1))).todense())
```

```{python}
# Test your answer in this cell

```

<details>
<summary>Show the solution</summary>

```{python}
values = np.array(["21", "46", "47", "23", "66", "82", "82"])

categories, pos = np.unique(values, return_inverse=True)
n_values = values.shape[0]
n_categories = categories.shape[0]

ohe = np.zeros((n_values, n_categories))
ohe[np.arange(n_values), pos] = 1
ohe
```

</details>


:::