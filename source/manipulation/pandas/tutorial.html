<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Working with tabular data using Pandas – Formation SSPy </title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="../../../site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../source/manipulation/modules-files/tutorial.html">Manipulation de données</a></li><li class="breadcrumb-item"><a href="../../../source/manipulation/pandas/tutorial.html">Traiter des données tabulaires avec Pandas</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../../">Formation SSPy <i class="fa-brands fa-python" aria-label="python"></i></a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Fondamentaux du langage</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/fundamentals/types-variables/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Types de base et variables</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/fundamentals/data-structures1/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Structures de données 1 : listes et tuples</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/fundamentals/data-structures2/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Structures de données 2 : dictionnaires et sets</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/fundamentals/tests/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tests logiques et conditions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/fundamentals/loops/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Boucles</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/fundamentals/functions/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Fonctions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/fundamentals/oop/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Notions de programmation orientée objet</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Manipulation de données</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/manipulation/modules-files/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Manipulation de fichiers</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/manipulation/csv-json-files/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Travailler avec des fichiers CSV et JSON</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/manipulation/numpy/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Calcul numérique avec NumPy</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/manipulation/pandas/tutorial.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Traiter des données tabulaires avec Pandas</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/manipulation/dataviz/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction à la visualisation de données</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Projets</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/projects/puissance4/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Projet 1 - Puissance 4</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/projects/meteo/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Projet 2 - Interaction avec des APIs</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/projects/RP/tutorial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Projet 3 - Analyse du recensement de la population</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#structures-de-données" id="toc-structures-de-données" class="nav-link active" data-scroll-target="#structures-de-données">Structures de données</a>
  <ul class="collapse">
  <li><a href="#la-series" id="toc-la-series" class="nav-link" data-scroll-target="#la-series">La <code>Series</code></a></li>
  <li><a href="#le-dataframe" id="toc-le-dataframe" class="nav-link" data-scroll-target="#le-dataframe">Le <code>DataFrame</code></a></li>
  </ul></li>
  <li><a href="#sélectionner-des-données" id="toc-sélectionner-des-données" class="nav-link" data-scroll-target="#sélectionner-des-données">Sélectionner des données</a>
  <ul class="collapse">
  <li><a href="#sélectionner-des-colonnes" id="toc-sélectionner-des-colonnes" class="nav-link" data-scroll-target="#sélectionner-des-colonnes">Sélectionner des colonnes</a></li>
  <li><a href="#sélectionner-des-lignes" id="toc-sélectionner-des-lignes" class="nav-link" data-scroll-target="#sélectionner-des-lignes">Sélectionner des lignes</a></li>
  </ul></li>
  <li><a href="#explorer-des-données-tabulaires" id="toc-explorer-des-données-tabulaires" class="nav-link" data-scroll-target="#explorer-des-données-tabulaires">Explorer des données tabulaires</a>
  <ul class="collapse">
  <li><a href="#importer-et-exporter-des-données" id="toc-importer-et-exporter-des-données" class="nav-link" data-scroll-target="#importer-et-exporter-des-données">Importer et exporter des données</a></li>
  <li><a href="#visualiser-un-échantillon-des-données" id="toc-visualiser-un-échantillon-des-données" class="nav-link" data-scroll-target="#visualiser-un-échantillon-des-données">Visualiser un échantillon des données</a></li>
  <li><a href="#obtenir-une-vue-densemble-des-données" id="toc-obtenir-une-vue-densemble-des-données" class="nav-link" data-scroll-target="#obtenir-une-vue-densemble-des-données">Obtenir une vue d’ensemble des données</a></li>
  <li><a href="#calculer-des-statistiques-descriptives" id="toc-calculer-des-statistiques-descriptives" class="nav-link" data-scroll-target="#calculer-des-statistiques-descriptives">Calculer des statistiques descriptives</a></li>
  </ul></li>
  <li><a href="#principales-manipulations-de-données" id="toc-principales-manipulations-de-données" class="nav-link" data-scroll-target="#principales-manipulations-de-données">Principales manipulations de données</a>
  <ul class="collapse">
  <li><a href="#transformer-les-données" id="toc-transformer-les-données" class="nav-link" data-scroll-target="#transformer-les-données">Transformer les données</a></li>
  <li><a href="#trier-les-valeurs" id="toc-trier-les-valeurs" class="nav-link" data-scroll-target="#trier-les-valeurs">Trier les valeurs</a></li>
  <li><a href="#agréger-des-données" id="toc-agréger-des-données" class="nav-link" data-scroll-target="#agréger-des-données">Agréger des données</a></li>
  <li><a href="#traiter-les-valeurs-manquantes" id="toc-traiter-les-valeurs-manquantes" class="nav-link" data-scroll-target="#traiter-les-valeurs-manquantes">Traiter les valeurs manquantes</a></li>
  <li><a href="#traiter-les-données-de-types-spécifiques" id="toc-traiter-les-données-de-types-spécifiques" class="nav-link" data-scroll-target="#traiter-les-données-de-types-spécifiques">Traiter les données de types spécifiques</a></li>
  <li><a href="#joindre-des-tables" id="toc-joindre-des-tables" class="nav-link" data-scroll-target="#joindre-des-tables">Joindre des tables</a></li>
  </ul></li>
  <li><a href="#exercices" id="toc-exercices" class="nav-link" data-scroll-target="#exercices">Exercices</a>
  <ul class="collapse">
  <li><a href="#questions-de-compréhension" id="toc-questions-de-compréhension" class="nav-link" data-scroll-target="#questions-de-compréhension">Questions de compréhension</a></li>
  <li><a href="#plusieurs-manières-de-créer-un-dataframe" id="toc-plusieurs-manières-de-créer-un-dataframe" class="nav-link" data-scroll-target="#plusieurs-manières-de-créer-un-dataframe">Plusieurs manières de créer un DataFrame</a></li>
  <li><a href="#sélection-de-données-dans-un-dataframe" id="toc-sélection-de-données-dans-un-dataframe" class="nav-link" data-scroll-target="#sélection-de-données-dans-un-dataframe">Sélection de données dans un DataFrame</a></li>
  <li><a href="#exploration-du-fichier-des-prénoms" id="toc-exploration-du-fichier-des-prénoms" class="nav-link" data-scroll-target="#exploration-du-fichier-des-prénoms">Exploration du fichier des prénoms</a></li>
  <li><a href="#calcul-dune-empreinte-carbone-par-habitant-au-niveau-communal" id="toc-calcul-dune-empreinte-carbone-par-habitant-au-niveau-communal" class="nav-link" data-scroll-target="#calcul-dune-empreinte-carbone-par-habitant-au-niveau-communal">Calcul d’une empreinte carbone par habitant au niveau communal</a></li>
  <li><a href="#analyse-de-lévolution-dun-indice-de-production" id="toc-analyse-de-lévolution-dun-indice-de-production" class="nav-link" data-scroll-target="#analyse-de-lévolution-dun-indice-de-production">Analyse de l’évolution d’un indice de production</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../source/manipulation/modules-files/tutorial.html">Manipulation de données</a></li><li class="breadcrumb-item"><a href="../../../source/manipulation/pandas/tutorial.html">Traiter des données tabulaires avec Pandas</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Working with tabular data using Pandas</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>L’analyse statistique a généralement pour base des <strong>données tabulaires</strong>, dans lesquelles chaque ligne représente une observation et chaque colonne une variable. Pour traiter ce type de données et y appliquer facilement les méthodes d’analyse de données standards, des objets dédiés ont été conçus : les <code>DataFrames</code>. Les utilisateurs de <code>R</code> connaissent bien cette structure de données, qui est native à ce langage orienté statistique. En <code>Python</code>, langage généraliste, cet objet n’existe pas nativement. Heureusement, une librairie très complete et bien pratique, pensée comme une surcouche à <code>NumPy</code>, introduit en <code>Python</code> l’objet <code>DataFrame</code> et permet la manipulation et l’analyse de données de manière simple et intuitive : <code>Pandas</code>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Pandas étant l’élément central de l’éco-système data science en Python, il offre des possibilités de traitement de la donnée quasi-infinies. En plus de ça, il existe généralement de multiples manières de réaliser une même opération en Pandas. En conséquence, ce chapitre est particulièrement long et dense en nouvelles fonctionnalités. L’objectif n’est pas de retenir toutes les méthodes présentées tout au long de ce chapitre, mais plutôt d’avoir une vision générale de ce qu’il est possible de faire afin de pouvoir mobiliser les bons outils dans les projets. En particulier, les exercices de fin de chapitre et les mini-projets de fin de formation seront l’occasion d’appliquer ces nouvelles connaissances à des problématiques concrètes.</p>
</div>
</div>
<p>On commence par importer la librairie <code>Pandas</code>. L’usage est courant est de lui attribuer l’alias <code>pd</code> afin de simplifier les futurs appels aux objets et fonctions du package. On importe également <code>NumPy</code> car on va comparer les objets fondamentaux des deux packages.</p>
<div id="38e4b286" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="structures-de-données" class="level2">
<h2 class="anchored" data-anchor-id="structures-de-données">Structures de données</h2>
<p>Pour bien comprendre le fonctionnement de <code>Pandas</code>, il faut s’intéresser à ses objets fondamentaux. On va donc d’abord étudier les <code>Series</code>, dont la concaténation permet de construire un <code>DataFrame</code>.</p>
<section id="la-series" class="level3">
<h3 class="anchored" data-anchor-id="la-series">La <code>Series</code></h3>
<p>Une Series est un conteneur de données unidimensionnel pouvant accueillir n’importe quel type de données (entiers, <em>strings</em>, objets Python…). Une Series est néanmoins d’un type donné : une Series ne contenant que des entiers sera de type <code>int</code>, et une Series contenant des objets de différente nature sera de type <code>object</code>. Construisons notre première Series à partir d’une liste pour vérifier ce comportement.</p>
<div id="2398840b" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> [<span class="dv">1</span>, <span class="st">"X"</span>, <span class="dv">3</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series(l)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(s)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0    1
1    X
2    3
dtype: object</code></pre>
</div>
</div>
<p>On peut notamment accéder aux données d’une Series par position, comme pour une liste ou un array.</p>
<div id="064485cf" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(s[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>X</code></pre>
</div>
</div>
<p>A priori, on ne voit pas beaucoup de différence entre une Series et un <em>array</em> <code>NumPy</code> à 1 dimension. Pourtant, il existe une différence de taille qui est la présence d’un index : les observations ont un label associé. Lorsqu’on crée une Series sans rien spécifier, l’index est automatiquement fixé aux entiers de 0 à n-1 (avec n le nombre d’éléments de la Series). Mais il est possible de passer un index spécifique (ex : des dates, des noms de communes, etc.).</p>
<div id="97bfc33a" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series(l, index<span class="op">=</span>[<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>])</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(s)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>a    1
b    X
c    3
dtype: object</code></pre>
</div>
</div>
<p>Ce qui permet d’accéder aux données par label :</p>
<div id="ce1a7c58" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>s[<span class="st">"b"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>'X'</code></pre>
</div>
</div>
<p>Cette différence apparaît secondaire à première vue, mais deviendra essentielle pour la construction du DataFrame. Pour le reste, les Series se comportent de manière très proche des arrays NumPy : les calculs sont vectorisés, on peut directement faire la somme de deux Series, etc. D’ailleurs, on peut très facilement convertir une Series en array via l’attribut <code>values</code>. Ce qui, naturellement, fait perdre l’index…</p>
<div id="5b26ca0e" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> pd.Series(l, index<span class="op">=</span>[<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>])</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>s.values</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>array([1, 'X', 3], dtype=object)</code></pre>
</div>
</div>
</section>
<section id="le-dataframe" class="level3">
<h3 class="anchored" data-anchor-id="le-dataframe">Le <code>DataFrame</code></h3>
<p>Fondamentalement, un DataFrame consiste en une collection de Series, alignées par les index. Cette concaténation construit donc une table de données, dont les Series correspondent aux colonnes, et dont l’index identifie les lignes. La figure suivante (<a href="https://www.geeksforgeeks.org/creating-a-pandas-dataframe/">source</a>) permet de bien comprendre cette structure de données.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/structure_df.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="800"></p>
</figure>
</div>
<p>Un DataFrame peut être construit de multiples manières. En pratique, on construit généralement un DataFrame directement à partir de fichiers de données tabulaires (ex : CSV, excel), rarement à la main. On illustrera donc seulement la méthode de construction manuelle la plus usuelle : à partir d’un dictionnaire de données.</p>
<div id="14ef9a78" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="fl">1.3</span>, <span class="fl">5.6</span>, np.nan, np.nan, <span class="dv">0</span>, np.nan],</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: np.random.randint(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">6</span>),</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"experiment"</span>: [<span class="st">"test"</span>, <span class="st">"train"</span>, <span class="st">"test"</span>, <span class="st">"train"</span>, <span class="st">"train"</span>, <span class="st">"validation"</span>],</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"date"</span>: [<span class="st">"2022-01-01"</span>, <span class="st">"2022-01-02"</span>, <span class="st">"2022-01-03"</span>, <span class="st">"2022-01-04"</span>, <span class="st">"2022-01-05"</span>, <span class="st">"2022-01-06"</span>],</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"sample"</span>: <span class="st">"sample1"</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>-3</td>
<td>test</td>
<td>2022-01-01</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>5</td>
<td>train</td>
<td>2022-01-02</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>-10</td>
<td>test</td>
<td>2022-01-03</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>-9</td>
<td>train</td>
<td>2022-01-04</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>2</td>
<td>train</td>
<td>2022-01-05</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>NaN</td>
<td>-9</td>
<td>validation</td>
<td>2022-01-06</td>
<td>sample1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Un DataFrame Pandas dispose d’un ensemble d’attributs utiles que nous allons découvrir tout au long de ce tutoriel. Pour l’instant, intéressons-nous aux plus basiques : l’index et le nom des colonnes. Par défaut, l’index est initialisé comme pour les Series à la liste des positions des observations. On aurait pu spécifier un index alternatif lors de la construction du DataFrame en spécifiant l’argument <code>index</code> de la fonction <code>pd.DataFrame</code>.</p>
<div id="fe201e27" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>df.index</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>RangeIndex(start=0, stop=6, step=1)</code></pre>
</div>
</div>
<div id="a56b86a8" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>df.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>Index(['var1', 'var2', 'experiment', 'date', 'sample'], dtype='object')</code></pre>
</div>
</div>
<p>Souvent, plutôt que de spécifier un index à la main lors de la construction du DataFrame, on va vouloir utiliser une certaine colonne du DataFrame comme index. On utilise pour cela la méthode <code>set_index</code> associée aux DataFrames.</p>
<div id="8375a0a9" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.set_index(<span class="st">"date"</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-01</td>
<td>1.3</td>
<td>-3</td>
<td>test</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-02</td>
<td>5.6</td>
<td>5</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-03</td>
<td>NaN</td>
<td>-10</td>
<td>test</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-04</td>
<td>NaN</td>
<td>-9</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-05</td>
<td>0.0</td>
<td>2</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-06</td>
<td>NaN</td>
<td>-9</td>
<td>validation</td>
<td>sample1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>L’attribut index a naturellement changé :</p>
<div id="c2462ade" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>df.index</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>Index(['2022-01-01', '2022-01-02', '2022-01-03', '2022-01-04', '2022-01-05',
       '2022-01-06'],
      dtype='object', name='date')</code></pre>
</div>
</div>
</section>
</section>
<section id="sélectionner-des-données" class="level2">
<h2 class="anchored" data-anchor-id="sélectionner-des-données">Sélectionner des données</h2>
<p>Lors de la manipulation des données tabulaires, il est fréquent de vouloir extraire des colonnes spécifiques d’un <code>DataFrame</code>. Cette extraction est simple avec <code>Pandas</code> grâce à l’utilisation des crochets.</p>
<section id="sélectionner-des-colonnes" class="level3">
<h3 class="anchored" data-anchor-id="sélectionner-des-colonnes">Sélectionner des colonnes</h3>
<section id="sélectionner-une-seule-colonne" class="level4">
<h4 class="anchored" data-anchor-id="sélectionner-une-seule-colonne">Sélectionner une seule colonne</h4>
<p>Pour extraire une seule colonne, on peut utiliser la syntaxe suivante :</p>
<div id="82e65ed3" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>selected_column <span class="op">=</span> df[<span class="st">"var1"</span>]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>selected_column</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>date
2022-01-01    1.3
2022-01-02    5.6
2022-01-03    NaN
2022-01-04    NaN
2022-01-05    0.0
2022-01-06    NaN
Name: var1, dtype: float64</code></pre>
</div>
</div>
<p>L’objet <code>selected_column</code> renvoie ici la colonne nommée <code>var1</code> du <code>DataFrame</code> <code>df</code>. Mais de quel type est cet objet ? Pour répondre à cette question, on utilise la fonction <code>type()</code> :</p>
<div id="e914952f" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(selected_column)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>pandas.core.series.Series</code></pre>
</div>
</div>
<p>Comme on peut le voir, le résultat est une <code>Series</code>, qui est un objet unidimensionnel dans <code>Pandas</code>.</p>
<p>Un autre attribut utile à connaître est <code>shape</code>. Il permet de connaître la dimension de l’objet. Pour une <code>Series</code>, <code>shape</code> retournera un tuple dont le premier élément indique le nombre de lignes.</p>
<div id="b8cfeb62" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>selected_column.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>(6,)</code></pre>
</div>
</div>
</section>
<section id="sélectionner-plusieurs-colonnes" class="level4">
<h4 class="anchored" data-anchor-id="sélectionner-plusieurs-colonnes">Sélectionner plusieurs colonnes</h4>
<p>Pour extraire plusieurs colonnes, il suffit de passer une liste des noms des colonnes souhaitées :</p>
<div id="3bfbb60c" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>selected_columns <span class="op">=</span> df[[<span class="st">"var1"</span>, <span class="st">"var2"</span>, <span class="st">"experiment"</span>]]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>selected_columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-01</td>
<td>1.3</td>
<td>-3</td>
<td>test</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-02</td>
<td>5.6</td>
<td>5</td>
<td>train</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-03</td>
<td>NaN</td>
<td>-10</td>
<td>test</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-04</td>
<td>NaN</td>
<td>-9</td>
<td>train</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-05</td>
<td>0.0</td>
<td>2</td>
<td>train</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-06</td>
<td>NaN</td>
<td>-9</td>
<td>validation</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Cet extrait montre les colonnes <code>var1</code>, <code>var2</code> et <code>experiment</code> du <code>DataFrame</code> <code>df</code>. Vérifions maintenant son type :</p>
<div id="d128d3b9" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(selected_columns)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>pandas.core.frame.DataFrame</code></pre>
</div>
</div>
<p>Le résultat est un <code>DataFrame</code>, car il s’agit d’un objet bidimensionnel. On peut aussi vérifier sa forme avec l’attribut <code>shape</code>. Dans ce cas, le tuple renvoyé par <code>shape</code> contiendra deux éléments : le nombre de lignes et le nombre de colonnes.</p>
<div id="bacc6d08" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>selected_columns.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>(6, 3)</code></pre>
</div>
</div>
</section>
</section>
<section id="sélectionner-des-lignes" class="level3">
<h3 class="anchored" data-anchor-id="sélectionner-des-lignes">Sélectionner des lignes</h3>
<section id="utilisation-de-loc-et-iloc" class="level4">
<h4 class="anchored" data-anchor-id="utilisation-de-loc-et-iloc">Utilisation de <code>loc</code> et <code>iloc</code></h4>
<p>Lorsqu’on veut sélectionner des lignes spécifiques dans un DataFrame, on peut se servir des deux principales méthodes : <code>loc</code> et <code>iloc</code>.</p>
<ul>
<li><code>iloc</code> permet de sélectionner des lignes et des colonnes par leur position, c’est-à-dire par des indices numériques.</li>
</ul>
<p>Exemple, sélection des 3 premières lignes :</p>
<div id="2030be3a" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>df.iloc[<span class="dv">0</span>:<span class="dv">3</span>, :]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-01</td>
<td>1.3</td>
<td>-3</td>
<td>test</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-02</td>
<td>5.6</td>
<td>5</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-03</td>
<td>NaN</td>
<td>-10</td>
<td>test</td>
<td>sample1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<ul>
<li><code>loc</code> quant à lui, fonctionne avec des labels. Si les index du DataFrame sont des numéros, ils ressemblent aux positions, mais ce n’est pas forcément le cas. Il est crucial de noter que, contrairement à <code>iloc</code>, avec <code>loc</code>, l’index de fin est inclus dans la sélection.</li>
</ul>
<div id="b95152e7" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>df.loc[<span class="st">"2022-01-01"</span>:<span class="st">"2022-01-03"</span>, :]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-01</td>
<td>1.3</td>
<td>-3</td>
<td>test</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-02</td>
<td>5.6</td>
<td>5</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-03</td>
<td>NaN</td>
<td>-10</td>
<td>test</td>
<td>sample1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="filtrage-des-données-selon-des-conditions" class="level4">
<h4 class="anchored" data-anchor-id="filtrage-des-données-selon-des-conditions">Filtrage des données selon des conditions</h4>
<p>En pratique, plutôt que de sélectionner des lignes basées sur des positions ou des labels, on souhaite souvent filtrer un DataFrame selon certaines conditions. Dans ce cas, on se sert principalement de filtres booléens.</p>
<ul>
<li><strong>Inégalités</strong> : On peut vouloir garder seulement les lignes qui respectent une certaine condition.</li>
</ul>
<p>Exemple, filtrer les lignes où la valeur de la colonne <code>var2</code> est supérieure à 0 :</p>
<div id="884617f1" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>df[df[<span class="st">'var2'</span>] <span class="op">&gt;=</span> <span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-02</td>
<td>5.6</td>
<td>5</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-05</td>
<td>0.0</td>
<td>2</td>
<td>train</td>
<td>sample1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<ul>
<li><strong>Appartenance avec <code>isin</code></strong> : Si on veut filtrer les données basées sur une liste de valeurs possibles, la méthode <code>isin</code> est très utile.</li>
</ul>
<p>Exemple, pour garder uniquement les lignes où la colonne <code>experiment</code> a des valeurs ‘test’ ou ‘validation’ :</p>
<div id="40a7745d" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>df[df[<span class="st">'experiment'</span>].isin([<span class="st">'train'</span>, <span class="st">'validation'</span>])]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-02</td>
<td>5.6</td>
<td>5</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-04</td>
<td>NaN</td>
<td>-9</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-05</td>
<td>0.0</td>
<td>2</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-06</td>
<td>NaN</td>
<td>-9</td>
<td>validation</td>
<td>sample1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Ces méthodes peuvent être combinées pour créer des conditions plus complexes. Il est aussi possible d’utiliser les opérateurs logiques (<code>&amp;</code> pour “et”, <code>|</code> pour “ou”) pour combiner plusieurs conditions. Attention, il faut bien prendre soin d’encadrer chaque condition par des parenthèses lors de la combinaison.</p>
<p>Exemple, sélectionner les lignes où <code>var2</code> est supérieur à 0 et <code>experiment</code> est égal à ‘test’ ou ‘validation’:</p>
<div id="adfe1e11" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>df[(df[<span class="st">'var2'</span>] <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="op">&amp;</span> (df[<span class="st">'experiment'</span>].isin([<span class="st">'train'</span>, <span class="st">'validation'</span>]))]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">2022-01-02</td>
<td>5.6</td>
<td>5</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2022-01-05</td>
<td>0.0</td>
<td>2</td>
<td>train</td>
<td>sample1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
</section>
</section>
<section id="explorer-des-données-tabulaires" class="level2">
<h2 class="anchored" data-anchor-id="explorer-des-données-tabulaires">Explorer des données tabulaires</h2>
<p>En statistique publique, le point de départ n’est généralement pas la génération manuelle de données, mais plutôt des fichiers tabulaires préexistants. Ces fichiers, qu’ils soient issus d’enquêtes, de bases administratives ou d’autres sources, constituent la matière première pour toute analyse ultérieure. Pandas offre des outils puissants pour importer ces fichiers tabulaires et les explorer en vue de manipulations plus poussées.</p>
<section id="importer-et-exporter-des-données" class="level3">
<h3 class="anchored" data-anchor-id="importer-et-exporter-des-données">Importer et exporter des données</h3>
<section id="importer-un-fichier-csv" class="level4">
<h4 class="anchored" data-anchor-id="importer-un-fichier-csv">Importer un fichier CSV</h4>
<p>Comme nous l’avons vu dans un précédent TP, le format CSV est l’un des formats les plus courants pour stocker des données tabulaires. Nous avons précédemment utilisé la librairie <code>csv</code> pour les manipuler comme des fichiers texte, mais ce n’était pas très pratique. Pour rappel, la syntaxe pour lire un fichier CSV et afficher les premières lignes était la suivante :</p>
<div id="bd13d49b" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> csv</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>rows <span class="op">=</span> []</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"data/departement2021.csv"</span>) <span class="im">as</span> file_in:</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    csv_reader <span class="op">=</span> csv.reader(file_in)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> row <span class="kw">in</span> csv_reader:</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>        rows.append(row)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>rows[:<span class="dv">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>[['DEP', 'REG', 'CHEFLIEU', 'TNCC', 'NCC', 'NCCENR', 'LIBELLE'],
 ['01', '84', '01053', '5', 'AIN', 'Ain', 'Ain'],
 ['02', '32', '02408', '5', 'AISNE', 'Aisne', 'Aisne'],
 ['03', '84', '03190', '5', 'ALLIER', 'Allier', 'Allier'],
 ['04',
  '93',
  '04070',
  '4',
  'ALPES DE HAUTE PROVENCE',
  'Alpes-de-Haute-Provence',
  'Alpes-de-Haute-Provence']]</code></pre>
</div>
</div>
<p>Avec Pandas, il suffit d’utiliser la fonction <code>read_csv()</code> pour importer le fichier comme un DataFrame, puis la fonction <code>head()</code>.</p>
<div id="cd103361" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>df_departements <span class="op">=</span> pd.read_csv(<span class="st">'data/departement2021.csv'</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>df_departements.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">DEP</th>
<th data-quarto-table-cell-role="th">REG</th>
<th data-quarto-table-cell-role="th">CHEFLIEU</th>
<th data-quarto-table-cell-role="th">TNCC</th>
<th data-quarto-table-cell-role="th">NCC</th>
<th data-quarto-table-cell-role="th">NCCENR</th>
<th data-quarto-table-cell-role="th">LIBELLE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>01</td>
<td>84</td>
<td>01053</td>
<td>5</td>
<td>AIN</td>
<td>Ain</td>
<td>Ain</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>02</td>
<td>32</td>
<td>02408</td>
<td>5</td>
<td>AISNE</td>
<td>Aisne</td>
<td>Aisne</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>03</td>
<td>84</td>
<td>03190</td>
<td>5</td>
<td>ALLIER</td>
<td>Allier</td>
<td>Allier</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>04</td>
<td>93</td>
<td>04070</td>
<td>4</td>
<td>ALPES DE HAUTE PROVENCE</td>
<td>Alpes-de-Haute-Provence</td>
<td>Alpes-de-Haute-Provence</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>05</td>
<td>93</td>
<td>05061</td>
<td>4</td>
<td>HAUTES ALPES</td>
<td>Hautes-Alpes</td>
<td>Hautes-Alpes</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Il est également possible d’importer un fichier CSV directement à partir d’une URL. C’est particulièrement pratique lorsque les données sont régulièrement mises à jour sur un site web et que l’on souhaite accéder à la version la plus récente sans avoir à télécharger manuellement le fichier à chaque fois. Prenons l’exemple d’un fichier CSV disponible sur le site de l’INSEE : le fichier des prénoms, issu des données de l’état civil. On note au passage une autre fonctionnalité bien pratique : le fichier CSV est compressé (format <code>zip</code>), mais Pandas est capable de le reconnaître et de le décompresser avant de l’importer.</p>
<div id="1d583bc1" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Importer un fichier CSV depuis une URL</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://www.insee.fr/fr/statistiques/fichier/2540004/nat2021_csv.zip"</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>df_prenoms_url <span class="op">=</span> pd.read_csv(url, sep<span class="op">=</span><span class="st">";"</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>df_prenoms_url.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">sexe</th>
<th data-quarto-table-cell-role="th">preusuel</th>
<th data-quarto-table-cell-role="th">annais</th>
<th data-quarto-table-cell-role="th">nombre</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>_PRENOMS_RARES</td>
<td>1900</td>
<td>1249</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1</td>
<td>_PRENOMS_RARES</td>
<td>1901</td>
<td>1342</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1</td>
<td>_PRENOMS_RARES</td>
<td>1902</td>
<td>1330</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1</td>
<td>_PRENOMS_RARES</td>
<td>1903</td>
<td>1286</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1</td>
<td>_PRENOMS_RARES</td>
<td>1904</td>
<td>1430</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Lorsqu’on travaille avec des fichiers CSV, il y a de nombreux arguments optionnels disponibles dans la fonction <code>read_csv()</code> qui permettent d’ajuster le processus d’importation en fonction des spécificités du fichier. Ces arguments peuvent notamment permettre de définir un délimiteur spécifique (comme ci-dessus pour le fichier des prénoms), de sauter certaines lignes en début de fichier, ou encore de définir les types de données pour chaque colonne, et bien d’autres. Tous ces paramètres et leur utilisation sont détaillés dans la <a href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">documentation officielle</a>.</p>
</section>
<section id="exporter-au-format-csv" class="level4">
<h4 class="anchored" data-anchor-id="exporter-au-format-csv">Exporter au format CSV</h4>
<p>Une fois que les données ont été traitées et modifiées au sein de Pandas, il est courant de vouloir exporter le résultat sous forme de fichier CSV pour le partager, l’archiver ou l’utiliser dans d’autres outils. Pandas offre une méthode simple pour cette opération : <code>to_csv()</code>. Supposons par exemple que l’on souhaite exporter les données du DataFrame <code>df_departements</code> spécifiques aux cinq départements d’outre-mer.</p>
<div id="3a8b788e" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>df_departements_dom <span class="op">=</span> df_departements[df_departements[<span class="st">"DEP"</span>].isin([<span class="st">"971"</span>, <span class="st">"972"</span>, <span class="st">"973"</span>, <span class="st">"974"</span>, <span class="st">"975"</span>])]</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>df_departements_dom.to_csv(<span class="st">'output/departements2021_dom.csv'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Un des arguments clés de la méthode <code>to_csv()</code> est <code>index</code>. Par défaut, <code>index=True</code>, ce qui signifie que l’index du DataFrame sera également écrit dans le fichier CSV. On peut le vérifier en imprimant les premières lignes de notre fichier CSV : Pandas a ajouté une colonne non-nommée, qui contient l’index des lignes retenues.</p>
<div id="1a527a74" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"output/departements2021_dom.csv"</span>) <span class="im">as</span> file_in:</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> <span class="bu">next</span>(file_in).strip()</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(row)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>,DEP,REG,CHEFLIEU,TNCC,NCC,NCCENR,LIBELLE
96,971,1,97105,3,GUADELOUPE,Guadeloupe,Guadeloupe
97,972,2,97209,3,MARTINIQUE,Martinique,Martinique
98,973,3,97302,3,GUYANE,Guyane,Guyane
99,974,4,97411,0,LA REUNION,La Réunion,La Réunion</code></pre>
</div>
</div>
<p>Dans certains cas, notamment lorsque l’index n’apporte pas d’information utile ou est simplement généré automatiquement par Pandas, on pourrait vouloir l’exclure du fichier exporté. Pour ce faire, on peut définir <code>index=False</code>.</p>
<div id="95f5267f" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>df_departements_dom.to_csv(<span class="st">'output/departements2021_dom_noindex.csv'</span>, index<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="importer-un-fichier-parquet" class="level4">
<h4 class="anchored" data-anchor-id="importer-un-fichier-parquet">Importer un fichier Parquet</h4>
<p>Le format Parquet est un autre format pour le stockage de données tabulaires, de plus en plus fréquemment utilisé. Sans entrer dans les détails techniques, le format Parquet présente différentes caractéristiques qui en font un choix privilégié pour le stockage et le traitement de gros volumes de données. En raison de ces avantages, ce format est de plus en plus utilisé pour la mise à disposition de données à l’Insee. Il est donc essentiel de savoir importer et requêter des fichiers Parquet avec Pandas.</p>
<p>Importer un fichier Parquet dans un DataFrame Pandas se fait tout aussi facilement que pour un fichier CSV. La fonction se nomme <code>read_parquet()</code>.</p>
<div id="77fb2510" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>df_departements <span class="op">=</span> pd.read_parquet(<span class="st">'data/departement2021.parquet'</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>df_departements.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">DEP</th>
<th data-quarto-table-cell-role="th">REG</th>
<th data-quarto-table-cell-role="th">CHEFLIEU</th>
<th data-quarto-table-cell-role="th">TNCC</th>
<th data-quarto-table-cell-role="th">NCC</th>
<th data-quarto-table-cell-role="th">NCCENR</th>
<th data-quarto-table-cell-role="th">LIBELLE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>01</td>
<td>84</td>
<td>01053</td>
<td>5</td>
<td>AIN</td>
<td>Ain</td>
<td>Ain</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>02</td>
<td>32</td>
<td>02408</td>
<td>5</td>
<td>AISNE</td>
<td>Aisne</td>
<td>Aisne</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>03</td>
<td>84</td>
<td>03190</td>
<td>5</td>
<td>ALLIER</td>
<td>Allier</td>
<td>Allier</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>04</td>
<td>93</td>
<td>04070</td>
<td>4</td>
<td>ALPES DE HAUTE PROVENCE</td>
<td>Alpes-de-Haute-Provence</td>
<td>Alpes-de-Haute-Provence</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>05</td>
<td>93</td>
<td>05061</td>
<td>4</td>
<td>HAUTES ALPES</td>
<td>Hautes-Alpes</td>
<td>Hautes-Alpes</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="exporter-au-format-parquet" class="level4">
<h4 class="anchored" data-anchor-id="exporter-au-format-parquet">Exporter au format Parquet</h4>
<p>Là encore, tout se passe comme dans le monde des CSV : on utilise la méthode <code>to_parquet()</code> pour exporter un DataFrame dans un fichier Parquet. De même, on peut choisir d’exporter ou non l’index, à l’aide du paramètre <code>index</code> (qui vaut <code>True</code> par défaut).</p>
<div id="2e6f9d68" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>df_departements_dom <span class="op">=</span> df_departements[df_departements[<span class="st">"DEP"</span>].isin([<span class="st">"971"</span>, <span class="st">"972"</span>, <span class="st">"973"</span>, <span class="st">"974"</span>, <span class="st">"975"</span>])]</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>df_departements_dom.to_parquet(<span class="st">'output/departements2021_dom.parquet'</span>, index<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Une des grandes forces du format Parquet, en comparaison des formats texte comme le CSV, est sa capacité à stocker des méta-données, i.e.&nbsp;des données permettant de mieux comprendre les données contenues dans le fichier. En particulier, un fichier Parquet inclut dans ses méta-données le schéma des données (noms des variables, types des variables, etc.), ce qui en fait un format très adapté à la diffusion de données. Vérifions ce comportement en reprenant le DataFrame que nous avons défini précédemment.</p>
<div id="429c10a4" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="fl">1.3</span>, <span class="fl">5.6</span>, np.nan, np.nan, <span class="dv">0</span>, np.nan],</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: np.random.randint(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">6</span>),</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"experiment"</span>: [<span class="st">"test"</span>, <span class="st">"train"</span>, <span class="st">"test"</span>, <span class="st">"train"</span>, <span class="st">"train"</span>, <span class="st">"validation"</span>],</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"date"</span>: [<span class="st">"2022-01-01"</span>, <span class="st">"2022-01-02"</span>, <span class="st">"2022-01-03"</span>, <span class="st">"2022-01-04"</span>, <span class="st">"2022-01-05"</span>, <span class="st">"2022-01-06"</span>],</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"sample"</span>: <span class="st">"sample1"</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.assign(</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>    experiment<span class="op">=</span>pd.Categorical(df[<span class="st">"experiment"</span>]),</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>    date<span class="op">=</span>pd.to_datetime(df[<span class="st">"date"</span>])</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>On utilise cette fois deux types de données spécifiques, pour les données catégorielles (<code>category</code>) et pour les données temporelles (<code>datetime</code>). On verra plus loin dans le tutoriel comment utiliser ces types. Pour l’instant, notons simplement que Pandas stocke ces types dans le schéma des données.</p>
<div id="11a34225" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 6 entries, 0 to 5
Data columns (total 5 columns):
 #   Column      Non-Null Count  Dtype         
---  ------      --------------  -----         
 0   var1        3 non-null      float64       
 1   var2        6 non-null      int64         
 2   experiment  6 non-null      category      
 3   date        6 non-null      datetime64[ns]
 4   sample      6 non-null      object        
dtypes: category(1), datetime64[ns](1), float64(1), int64(1), object(1)
memory usage: 458.0+ bytes</code></pre>
</div>
</div>
<p>Vérifions à présent que l’export et le ré-import de ces données en Parquet préserve le schéma.</p>
<div id="edf9ae26" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>df.to_parquet(<span class="st">"output/df_test_schema.parquet"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>df_test_schema_parquet <span class="op">=</span> pd.read_parquet(<span class="st">'output/df_test_schema.parquet'</span>)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>df_test_schema_parquet.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 6 entries, 0 to 5
Data columns (total 5 columns):
 #   Column      Non-Null Count  Dtype         
---  ------      --------------  -----         
 0   var1        3 non-null      float64       
 1   var2        6 non-null      int64         
 2   experiment  6 non-null      category      
 3   date        6 non-null      datetime64[ns]
 4   sample      6 non-null      object        
dtypes: category(1), datetime64[ns](1), float64(1), int64(1), object(1)
memory usage: 458.0+ bytes</code></pre>
</div>
</div>
<p>A l’inverse, un fichier CSV ne contenant par définition que du texte, ne permet pas de préserver ces données. Les variables dont nous avons spécifié le type sont importées comme des strings (type <code>object</code> en Pandas).</p>
<div id="89271181" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>df.to_csv(<span class="st">"output/df_test_schema.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>df_test_schema_csv <span class="op">=</span> pd.read_csv(<span class="st">'output/df_test_schema.csv'</span>)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>df_test_schema_csv.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 6 entries, 0 to 5
Data columns (total 5 columns):
 #   Column      Non-Null Count  Dtype  
---  ------      --------------  -----  
 0   var1        3 non-null      float64
 1   var2        6 non-null      int64  
 2   experiment  6 non-null      object 
 3   date        6 non-null      object 
 4   sample      6 non-null      object 
dtypes: float64(1), int64(1), object(3)
memory usage: 368.0+ bytes</code></pre>
</div>
</div>
</section>
</section>
<section id="visualiser-un-échantillon-des-données" class="level3">
<h3 class="anchored" data-anchor-id="visualiser-un-échantillon-des-données">Visualiser un échantillon des données</h3>
<p>Lorsqu’on travaille avec des jeux de données volumineux, il est souvent utile de visualiser rapidement un échantillon des données pour avoir une idée de leur structure, de leur format ou encore pour détecter d’éventuels problèmes. Pandas offre plusieurs méthodes pour cela.</p>
<p>La méthode <code>head()</code> permet d’afficher les premières lignes du DataFrame. Par défaut, elle retourne les 5 premières lignes, mais on peut spécifier un autre nombre en argument si nécessaire.</p>
<div id="acf7fa2b" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>df_departements.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">DEP</th>
<th data-quarto-table-cell-role="th">REG</th>
<th data-quarto-table-cell-role="th">CHEFLIEU</th>
<th data-quarto-table-cell-role="th">TNCC</th>
<th data-quarto-table-cell-role="th">NCC</th>
<th data-quarto-table-cell-role="th">NCCENR</th>
<th data-quarto-table-cell-role="th">LIBELLE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>01</td>
<td>84</td>
<td>01053</td>
<td>5</td>
<td>AIN</td>
<td>Ain</td>
<td>Ain</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>02</td>
<td>32</td>
<td>02408</td>
<td>5</td>
<td>AISNE</td>
<td>Aisne</td>
<td>Aisne</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>03</td>
<td>84</td>
<td>03190</td>
<td>5</td>
<td>ALLIER</td>
<td>Allier</td>
<td>Allier</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>04</td>
<td>93</td>
<td>04070</td>
<td>4</td>
<td>ALPES DE HAUTE PROVENCE</td>
<td>Alpes-de-Haute-Provence</td>
<td>Alpes-de-Haute-Provence</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>05</td>
<td>93</td>
<td>05061</td>
<td>4</td>
<td>HAUTES ALPES</td>
<td>Hautes-Alpes</td>
<td>Hautes-Alpes</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="5070e06d" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>df_departements.head(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">DEP</th>
<th data-quarto-table-cell-role="th">REG</th>
<th data-quarto-table-cell-role="th">CHEFLIEU</th>
<th data-quarto-table-cell-role="th">TNCC</th>
<th data-quarto-table-cell-role="th">NCC</th>
<th data-quarto-table-cell-role="th">NCCENR</th>
<th data-quarto-table-cell-role="th">LIBELLE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>01</td>
<td>84</td>
<td>01053</td>
<td>5</td>
<td>AIN</td>
<td>Ain</td>
<td>Ain</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>02</td>
<td>32</td>
<td>02408</td>
<td>5</td>
<td>AISNE</td>
<td>Aisne</td>
<td>Aisne</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>03</td>
<td>84</td>
<td>03190</td>
<td>5</td>
<td>ALLIER</td>
<td>Allier</td>
<td>Allier</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>04</td>
<td>93</td>
<td>04070</td>
<td>4</td>
<td>ALPES DE HAUTE PROVENCE</td>
<td>Alpes-de-Haute-Provence</td>
<td>Alpes-de-Haute-Provence</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>05</td>
<td>93</td>
<td>05061</td>
<td>4</td>
<td>HAUTES ALPES</td>
<td>Hautes-Alpes</td>
<td>Hautes-Alpes</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>06</td>
<td>93</td>
<td>06088</td>
<td>4</td>
<td>ALPES MARITIMES</td>
<td>Alpes-Maritimes</td>
<td>Alpes-Maritimes</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>07</td>
<td>84</td>
<td>07186</td>
<td>5</td>
<td>ARDECHE</td>
<td>Ardèche</td>
<td>Ardèche</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>08</td>
<td>44</td>
<td>08105</td>
<td>4</td>
<td>ARDENNES</td>
<td>Ardennes</td>
<td>Ardennes</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>09</td>
<td>76</td>
<td>09122</td>
<td>5</td>
<td>ARIEGE</td>
<td>Ariège</td>
<td>Ariège</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">9</td>
<td>10</td>
<td>44</td>
<td>10387</td>
<td>5</td>
<td>AUBE</td>
<td>Aube</td>
<td>Aube</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>À l’inverse, la méthode <code>tail()</code> donne un aperçu des dernières lignes du DataFrame.</p>
<div id="4da20bc0" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>df_departements.tail()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">DEP</th>
<th data-quarto-table-cell-role="th">REG</th>
<th data-quarto-table-cell-role="th">CHEFLIEU</th>
<th data-quarto-table-cell-role="th">TNCC</th>
<th data-quarto-table-cell-role="th">NCC</th>
<th data-quarto-table-cell-role="th">NCCENR</th>
<th data-quarto-table-cell-role="th">LIBELLE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">96</td>
<td>971</td>
<td>1</td>
<td>97105</td>
<td>3</td>
<td>GUADELOUPE</td>
<td>Guadeloupe</td>
<td>Guadeloupe</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">97</td>
<td>972</td>
<td>2</td>
<td>97209</td>
<td>3</td>
<td>MARTINIQUE</td>
<td>Martinique</td>
<td>Martinique</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">98</td>
<td>973</td>
<td>3</td>
<td>97302</td>
<td>3</td>
<td>GUYANE</td>
<td>Guyane</td>
<td>Guyane</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">99</td>
<td>974</td>
<td>4</td>
<td>97411</td>
<td>0</td>
<td>LA REUNION</td>
<td>La Réunion</td>
<td>La Réunion</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">100</td>
<td>976</td>
<td>6</td>
<td>97608</td>
<td>0</td>
<td>MAYOTTE</td>
<td>Mayotte</td>
<td>Mayotte</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>L’affichage des premières ou dernières lignes peut parfois ne pas être représentatif de l’ensemble du jeu de données, lorsque les données sont triées par exemple. Afin de minimiser le risque d’obtenir un aperçu biaisé des données, on peut utiliser la méthode <code>sample()</code>, qui sélectionne un un échantillon aléatoire de lignes. Par défaut, elle retourne une seule ligne, mais on peut demander un nombre spécifique de lignes en utilisant l’argument <code>n</code>.</p>
<div id="2134c9d0" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>df_departements.sample(n<span class="op">=</span><span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">DEP</th>
<th data-quarto-table-cell-role="th">REG</th>
<th data-quarto-table-cell-role="th">CHEFLIEU</th>
<th data-quarto-table-cell-role="th">TNCC</th>
<th data-quarto-table-cell-role="th">NCC</th>
<th data-quarto-table-cell-role="th">NCCENR</th>
<th data-quarto-table-cell-role="th">LIBELLE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">77</td>
<td>77</td>
<td>11</td>
<td>77288</td>
<td>0</td>
<td>SEINE ET MARNE</td>
<td>Seine-et-Marne</td>
<td>Seine-et-Marne</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">99</td>
<td>974</td>
<td>4</td>
<td>97411</td>
<td>0</td>
<td>LA REUNION</td>
<td>La Réunion</td>
<td>La Réunion</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">13</td>
<td>14</td>
<td>28</td>
<td>14118</td>
<td>2</td>
<td>CALVADOS</td>
<td>Calvados</td>
<td>Calvados</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">28</td>
<td>2A</td>
<td>94</td>
<td>2A004</td>
<td>3</td>
<td>CORSE DU SUD</td>
<td>Corse-du-Sud</td>
<td>Corse-du-Sud</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">43</td>
<td>43</td>
<td>84</td>
<td>43157</td>
<td>3</td>
<td>HAUTE LOIRE</td>
<td>Haute-Loire</td>
<td>Haute-Loire</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="obtenir-une-vue-densemble-des-données" class="level3">
<h3 class="anchored" data-anchor-id="obtenir-une-vue-densemble-des-données">Obtenir une vue d’ensemble des données</h3>
<p>L’une des premières étapes lors de l’exploration de nouvelles données est de comprendre la structure générale du jeu de données. La méthode <code>info()</code> de Pandas offre une vue d’ensemble rapide des données, notamment en termes de types de données, de présence de valeurs manquantes et de mémoire utilisée.</p>
<div id="ac59e700" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 6 entries, 0 to 5
Data columns (total 5 columns):
 #   Column      Non-Null Count  Dtype         
---  ------      --------------  -----         
 0   var1        3 non-null      float64       
 1   var2        6 non-null      int64         
 2   experiment  6 non-null      category      
 3   date        6 non-null      datetime64[ns]
 4   sample      6 non-null      object        
dtypes: category(1), datetime64[ns](1), float64(1), int64(1), object(1)
memory usage: 458.0+ bytes</code></pre>
</div>
</div>
<p>Plusieurs éléments d’information clés peuvent être extraits de ce résultat :</p>
<ul>
<li><p><strong>index</strong> : le DataFrame a un <code>RangeIndex</code>, ce qui signifie que l’index est constitué d’une suite numérique simple. Ici, l’index va de 0 à 5, soit 6 entrées au total.</p></li>
<li><p><strong>schéma</strong> : la liste des colonnes est affichée avec des informations très utiles sur le schéma des données :</p>
<ul>
<li><p><strong>Non-Null Count</strong> : le nombre de valeurs <strong>non-manquantes</strong> (non <code>nan</code>) dans la colonne. Si ce nombre est inférieur au nombre total d’entrées (dans notre cas, 6), cela signifie que la colonne contient des valeurs manquantes. Attention à l’ambiguité possible sur “null” : cela signifie bien les valeurs manquantes, pas les valeurs égales à 0. Ainsi, dans notre cas, le nombre de valeurs “non-null” pour la variable <code>var1</code> est 5.</p></li>
<li><p><strong>Dtype</strong> : Le type de données de la colonne, qui permet decomprendre la nature des informations stockées dans chaque colonne. Par exemple, <code>float64</code> (nombres réels), <code>int32</code> (nombres entiers), <code>category</code> (variable catégorielle), <code>datetime64[ns]</code> (information temporelle) et <code>object</code> (données textuelles ou mixtes).</p></li>
</ul></li>
</ul>
<p>L’utilisation de <code>info()</code> est un moyen rapide et efficace d’obtenir une vue d’ensemble d’un DataFrame, d’identifier rapidement les colonnes contenant des valeurs manquantes et de comprendre la structure des données.</p>
</section>
<section id="calculer-des-statistiques-descriptives" class="level3">
<h3 class="anchored" data-anchor-id="calculer-des-statistiques-descriptives">Calculer des statistiques descriptives</h3>
<p>En complément des informations renvoyées par la méthode <code>info()</code>, on peut vouloir obtenir des statistiques descriptives simples afin de visualiser rapidement les distributions des variables. La méthode <code>describe()</code> permet d’avoir une vue synthétique de la distribution des données dans chaque colonne.</p>
<div id="d48bde9a" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>df.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">count</td>
<td>3.00000</td>
<td>6.000000</td>
<td>6</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">mean</td>
<td>2.30000</td>
<td>0.166667</td>
<td>2022-01-03 12:00:00</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">min</td>
<td>0.00000</td>
<td>-10.000000</td>
<td>2022-01-01 00:00:00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">25%</td>
<td>0.65000</td>
<td>-4.250000</td>
<td>2022-01-02 06:00:00</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">50%</td>
<td>1.30000</td>
<td>4.000000</td>
<td>2022-01-03 12:00:00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">75%</td>
<td>3.45000</td>
<td>4.750000</td>
<td>2022-01-04 18:00:00</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">max</td>
<td>5.60000</td>
<td>5.000000</td>
<td>2022-01-06 00:00:00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">std</td>
<td>2.93087</td>
<td>6.794606</td>
<td>NaN</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Il est à noter que <code>describe()</code> ne renvoie des statistiques que pour les colonnes numériques par défaut. Si l’on souhaite inclure des colonnes d’autres types, il est nécessaire de le préciser via l’argument <code>include</code>. Par exemple, <code>df.describe(include='all')</code> renverra des statistiques pour toutes les colonnes, y compris des métriques comme le nombre unique, la valeur la plus fréquente et la fréquence de la valeur la plus fréquente pour les colonnes non numériques.</p>
<div id="f6b3ada5" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>df.describe(include<span class="op">=</span><span class="st">'all'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="41">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">count</td>
<td>3.00000</td>
<td>6.000000</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">unique</td>
<td>NaN</td>
<td>NaN</td>
<td>3</td>
<td>NaN</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">top</td>
<td>NaN</td>
<td>NaN</td>
<td>train</td>
<td>NaN</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">freq</td>
<td>NaN</td>
<td>NaN</td>
<td>3</td>
<td>NaN</td>
<td>6</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">mean</td>
<td>2.30000</td>
<td>0.166667</td>
<td>NaN</td>
<td>2022-01-03 12:00:00</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">min</td>
<td>0.00000</td>
<td>-10.000000</td>
<td>NaN</td>
<td>2022-01-01 00:00:00</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">25%</td>
<td>0.65000</td>
<td>-4.250000</td>
<td>NaN</td>
<td>2022-01-02 06:00:00</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">50%</td>
<td>1.30000</td>
<td>4.000000</td>
<td>NaN</td>
<td>2022-01-03 12:00:00</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">75%</td>
<td>3.45000</td>
<td>4.750000</td>
<td>NaN</td>
<td>2022-01-04 18:00:00</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">max</td>
<td>5.60000</td>
<td>5.000000</td>
<td>NaN</td>
<td>2022-01-06 00:00:00</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">std</td>
<td>2.93087</td>
<td>6.794606</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Notons que, là encore, la variable <code>count</code> renvoie le nombre de valeurs <strong>non-manquantes</strong> dans chaque variable.</p>
</section>
</section>
<section id="principales-manipulations-de-données" class="level2">
<h2 class="anchored" data-anchor-id="principales-manipulations-de-données">Principales manipulations de données</h2>
<section id="transformer-les-données" class="level3">
<h3 class="anchored" data-anchor-id="transformer-les-données">Transformer les données</h3>
<p>Les opérations de transformation sur les données sont essentielles pour façonner, nettoyer et préparer les données en vue de leur analyse. Les transformations peuvent concerner l’ensemble du DataFrame, des colonnes spécifiques ou encore des lignes spécifiques.</p>
<section id="transformer-un-dataframe" class="level4">
<h4 class="anchored" data-anchor-id="transformer-un-dataframe">Transformer un DataFrame</h4>
<p>Pour transformer un DataFrame complet (ou un sous-DataFrame), il est possible d’utiliser des fonctions vectorisées, qui permettent d’appliquer rapidement une opération à l’ensemble des éléments du DataFrame. Cela inclut un certain nombre de méthodes disponibles pour les <code>Series</code>, mais aussi les fonctions mathématiques de <code>NumPy</code>, etc.</p>
<p>Par exemple, passer chaque valeur numérique d’un DataFrame à la puissance 2 :</p>
<div id="6f81ca8e" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="fl">1.3</span>, <span class="fl">5.6</span>, np.nan, np.nan, <span class="dv">0</span>, np.nan],</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: np.random.randint(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">6</span>),</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>df <span class="op">**</span> <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.69</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>31.36</td>
<td>25</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>81</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.00</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>NaN</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>ou les passer en valeur absolue :</p>
<div id="1a66f012" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">abs</span>(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>5</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>9</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>NaN</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Certaines méthodes, disponibles pour les <code>Series</code>, peuvent aussi être utilisées pour transformer un DataFrame complet. Par exemple, la bien utile méthode <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html">replace()</a>, qui permet de remplacer toutes les occurences d’une valeur donnée par une autre valeur. Par exemple, supposons que la valeur 0 dans la colonne <code>var1</code> indique en fait une erreur de mesure. Il serait préférable de la remplacer par une valeur manquante.</p>
<div id="f42949eb" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>df.replace(<span class="dv">0</span>, np.nan)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="44">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>1.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>5.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>9.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>NaN</td>
<td>1.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>NaN</td>
<td>1.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled" title="Assignation ou méthodes *in place* (en place) ?">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Assignation ou méthodes <em>in place</em> (en place) ?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Dans l’exemple précédent, l’application de la méthode <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html">replace()</a> ne modifie pas directement le DataFrame. Pour que la modifiction soit persistente, une première possibilité est d’assigner le résultat à un objet :</p>
<div id="1cc231ad" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.replace(<span class="dv">0</span>, np.nan)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Une seconde possibilité est, lorsque les méthodes le proposent, d’utiliser l’argument <code>inplace</code>. Lorsque <code>inplace=True</code>, l’opération est effectuée “en place”, et le DataFrame est donc modifié directement.</p>
<div id="99882650" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>df.replace(<span class="dv">0</span>, np.nan, inplace<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En pratique, il est préférable de limiter les opérations <code>inplace</code>. Elles ne favorisent pas la reproductibilité des analyses, dans la mesure où la ré-exécution d’une même cellule va donner à chaque fois des résultats différents.</p>
</div>
</div>
</section>
<section id="transformer-les-colonnes" class="level4">
<h4 class="anchored" data-anchor-id="transformer-les-colonnes">Transformer les colonnes</h4>
<p>Dans certains cas, on ne va pas vouloir appliquer les transformations à l’ensemble des données, mais à des variables spécifiques. Les transformations qui sont possibles à l’échelle du DataFrame (fonctions vectorisées, méthodes comme <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html">replace()</a>, etc.) restent naturellement possibles à l’échelle d’une colonne.</p>
<div id="3ceb1418" class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="fl">1.3</span>, <span class="fl">5.6</span>, np.nan, np.nan, <span class="dv">0</span>, np.nan],</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: np.random.randint(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">6</span>),</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>np.<span class="bu">abs</span>(df[<span class="st">"var2"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="47">
<pre><code>0     7
1     3
2    10
3     4
4     5
5     8
Name: var2, dtype: int64</code></pre>
</div>
</div>
<div id="efd07da4" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"var1"</span>].replace(<span class="dv">0</span>, np.nan)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="48">
<pre><code>0    1.3
1    5.6
2    NaN
3    NaN
4    NaN
5    NaN
Name: var1, dtype: float64</code></pre>
</div>
</div>
<p>Mais il existe d’autres transformations que l’on applique généralement au niveau d’une ou de quelques colonnes. Par exemple, lorsque le schéma n’a pas été bien reconnu à l’import, il peut arriver que des variables numériques soient définies comme des string (type <code>object</code> en Pandas).</p>
<div id="dbd41a8a" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="fl">1.3</span>, <span class="fl">5.6</span>, np.nan],</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: [<span class="st">"1"</span>, <span class="st">"5"</span>, <span class="st">"18"</span>],</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 3 entries, 0 to 2
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   var1    2 non-null      float64
 1   var2    3 non-null      object 
dtypes: float64(1), object(1)
memory usage: 176.0+ bytes</code></pre>
</div>
</div>
<p>Dans ce cas, on peut utiliser la méthode <code>astype</code> pour convertir la colonne dans le type souhaité.</p>
<div id="a58da660" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'var2'</span>] <span class="op">=</span> df[<span class="st">'var2'</span>].astype(<span class="bu">int</span>)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 3 entries, 0 to 2
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   var1    2 non-null      float64
 1   var2    3 non-null      int64  
dtypes: float64(1), int64(1)
memory usage: 176.0 bytes</code></pre>
</div>
</div>
<p>Une autre opération fréquente est le renommage d’une ou plusieurs colonnes. Pour cela, on peut utiliser la méthode <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rename.html">rename()</a>, à laquelle on passe un dictionnaire qui contient autant de couples clé-valeur que de variables à renommer, et dans lequel chaque couple clé-valeur est de la forme <code>'ancien_nom': 'nouveau_nom'</code>.</p>
<div id="9b980585" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>df.rename(columns<span class="op">=</span>{<span class="st">'var2'</span>: <span class="st">'age'</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="51">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>5</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>18</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Enfin, on peut souhaiter supprimer du DataFrame des colonnes qui ne sont pas ou plus utiles à l’analyse. Pour cela, on utilise la méthode <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html">drop()</a>, à laquelle on passe soit un string (nom d’une colonne si l’on souhaite n’en supprimer qu’une seule) ou une liste de noms de colonne à supprimer.</p>
<div id="6d613e10" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>df.drop(columns<span class="op">=</span>[<span class="st">'var1'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="52">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>18</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="transformer-les-lignes" class="level4">
<h4 class="anchored" data-anchor-id="transformer-les-lignes">Transformer les lignes</h4>
<p>En statistiques, on applique généralement des tranformations faisant intervenir une ou plusieurs colonnes. Néanmoins, dans certains cas, il est nécessaire d’appliquer des transformations au niveau des lignes. Pour cela, on peut utiliser la méthode <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html">apply()</a> de Pandas, appliquée à l’axe des lignes (<code>axis=1</code>). Illustrons son fonctionnement avec un cas simple. Pour cela, on génère d’abord des données.</p>
<div id="d5ab4cab" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">13</span>],</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: [<span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">11</span>, <span class="dv">15</span>],</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"date"</span>: [<span class="st">"2022-01-01"</span>, <span class="st">"2022-01-02"</span>, <span class="st">"2022-01-03"</span>, <span class="st">"2022-01-04"</span>],</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="53">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>3</td>
<td>2022-01-01</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>7</td>
<td>2022-01-02</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9</td>
<td>11</td>
<td>2022-01-03</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>13</td>
<td>15</td>
<td>2022-01-04</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>On applique maintenant la fonction <code>apply()</code> au DataFrame afin de calculer une nouvelle variable qui est la somme des deux existantes.</p>
<div id="560ddcbb" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'sum_row'</span>] <span class="op">=</span> df.<span class="bu">apply</span>(<span class="kw">lambda</span> row: row[<span class="st">'var1'</span>] <span class="op">+</span> row[<span class="st">'var2'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th">sum_row</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>3</td>
<td>2022-01-01</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>7</td>
<td>2022-01-02</td>
<td>12</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9</td>
<td>11</td>
<td>2022-01-03</td>
<td>20</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>13</td>
<td>15</td>
<td>2022-01-04</td>
<td>28</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="Les fonctions lambda">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Les fonctions lambda
</div>
</div>
<div class="callout-body-container callout-body">
<p>Une fonction <code>lambda</code> est une petite fonction anonyme. Elle peut prendre n’importe quel nombre d’arguments, mais ne peut avoir qu’une seule expression. Dans l’exemple ci-dessus, la fonction <code>lambda</code> prend une ligne en argument et renvoie la somme des colonnes <code>var1</code> et <code>var2</code> pour cette ligne.</p>
<p>Les fonctions <code>lambda</code> permettent de définir simplement des fonctions “à la volée”, sans devoir leur donner un nom. Dans notre exemple, cela aurait été parfaitement équivalent au code suivant :</p>
<div id="6beb44f0" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sum_row(row):</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> row[<span class="st">'var1'</span>] <span class="op">+</span> row[<span class="st">'var2'</span>]</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'sum_row'</span>] <span class="op">=</span> df.<span class="bu">apply</span>(sum_row, axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
<p>Bien que <code>apply()</code> offre une grande flexibilité, elle n’est pas la méthode la plus efficiente, notamment pour de grands jeux de données. Les opérations vectorisées sont toujours préférables car elles traitent les données en bloc plutôt que ligne par ligne. Dans notre cas, il aurait été bien entendu préférable de créer notre variable en utilisant des opérations sur les colonnes.</p>
<div id="7edb05f5" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'sum_row_vect'</span>] <span class="op">=</span> df[<span class="st">'var1'</span>] <span class="op">+</span> df[<span class="st">'var2'</span>]</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="56">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th">sum_row</th>
<th data-quarto-table-cell-role="th">sum_row_vect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>3</td>
<td>2022-01-01</td>
<td>4</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>7</td>
<td>2022-01-02</td>
<td>12</td>
<td>12</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9</td>
<td>11</td>
<td>2022-01-03</td>
<td>20</td>
<td>20</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>13</td>
<td>15</td>
<td>2022-01-04</td>
<td>28</td>
<td>28</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Néanmoins, on peut se retrouver dans certains (rares) cas où une opération ne peut pas être facilement vectorisée ou où la logique est complexe. Supposons par exemple que l’on souhaite combiner les valeurs de plusieurs colonnes en fonction de certaines conditions.</p>
<div id="8055451b" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> combine_columns(row):</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> row[<span class="st">'var1'</span>] <span class="op">&gt;</span> <span class="dv">6</span>:</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">str</span>(row[<span class="st">'var2'</span>])</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">str</span>(row[<span class="st">'var2'</span>]) <span class="op">+</span> <span class="st">"_"</span> <span class="op">+</span> row[<span class="st">'date'</span>]</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'combined_column'</span>] <span class="op">=</span> df.<span class="bu">apply</span>(combine_columns, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th">sum_row</th>
<th data-quarto-table-cell-role="th">sum_row_vect</th>
<th data-quarto-table-cell-role="th">combined_column</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>3</td>
<td>2022-01-01</td>
<td>4</td>
<td>4</td>
<td>3_2022-01-01</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>7</td>
<td>2022-01-02</td>
<td>12</td>
<td>12</td>
<td>7_2022-01-02</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9</td>
<td>11</td>
<td>2022-01-03</td>
<td>20</td>
<td>20</td>
<td>11</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>13</td>
<td>15</td>
<td>2022-01-04</td>
<td>28</td>
<td>28</td>
<td>15</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
</section>
<section id="trier-les-valeurs" class="level3">
<h3 class="anchored" data-anchor-id="trier-les-valeurs">Trier les valeurs</h3>
<p>Le tri des données est particulièrement utile pour l’exploration et la visualisation de données. Avec Pandas, on utilise la méthode <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html">sort_values()</a> pour trier les valeurs d’un DataFrame selon une ou plusieurs colonnes.</p>
<div id="4e2762fd" class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">13</span>],</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: [<span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">11</span>, <span class="dv">15</span>],</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"date"</span>: [<span class="st">"2022-01-01"</span>, <span class="st">"2022-01-02"</span>, <span class="st">"2022-01-03"</span>, <span class="st">"2022-01-04"</span>],</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="58">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>3</td>
<td>2022-01-01</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>7</td>
<td>2022-01-02</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9</td>
<td>11</td>
<td>2022-01-03</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>13</td>
<td>15</td>
<td>2022-01-04</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Pour trier les valeurs selon une seule colonne, il suffit de passer le nom de la colonne en paramètre.</p>
<div id="d82328f0" class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>df.sort_values(by<span class="op">=</span><span class="st">'var1'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="59">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>3</td>
<td>2022-01-01</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>7</td>
<td>2022-01-02</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9</td>
<td>11</td>
<td>2022-01-03</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>13</td>
<td>15</td>
<td>2022-01-04</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Par défaut, le tri est effectué dans l’ordre croissant. Pour trier les valeurs dans un ordre décroissant, il suffit de paramétrer <code>ascending=False</code>.</p>
<div id="7dc020d1" class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>df.sort_values(by<span class="op">=</span><span class="st">'var1'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="60">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">3</td>
<td>13</td>
<td>15</td>
<td>2022-01-04</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2</td>
<td>9</td>
<td>11</td>
<td>2022-01-03</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>7</td>
<td>2022-01-02</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>3</td>
<td>2022-01-01</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Si on souhaite trier le DataFrame sur plusieurs colonnes, on peut fournir une liste de noms de colonnes. On peut également choisir de trier de manière croissante pour certaines colonnes et décroissante pour d’autres.</p>
</section>
<section id="agréger-des-données" class="level3">
<h3 class="anchored" data-anchor-id="agréger-des-données">Agréger des données</h3>
<p>L’agrégation des données est un processus dans lequel les données vont être ventilées en groupes selon certains critères, puis agrégées selon une fonction d’agrégation appliquée indépendamment à chaque groupe. Cette opération est courante lors de l’analyse exploratoire ou lors du prétraitement des données pour la visualisation ou la modélisation statistique.</p>
<div id="e370bb8d" class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="fl">1.3</span>, <span class="fl">5.6</span>, np.nan, np.nan, <span class="dv">0</span>, np.nan],</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: np.random.randint(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">6</span>),</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"experiment"</span>: [<span class="st">"test"</span>, <span class="st">"train"</span>, <span class="st">"test"</span>, <span class="st">"train"</span>, <span class="st">"train"</span>, <span class="st">"validation"</span>],</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"date"</span>: [<span class="st">"2022-01-01"</span>, <span class="st">"2022-01-02"</span>, <span class="st">"2022-01-03"</span>, <span class="st">"2022-01-04"</span>, <span class="st">"2022-01-05"</span>, <span class="st">"2022-01-06"</span>],</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"sample"</span>: <span class="st">"sample1"</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="61">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>-6</td>
<td>test</td>
<td>2022-01-01</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>-4</td>
<td>train</td>
<td>2022-01-02</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>3</td>
<td>test</td>
<td>2022-01-03</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>-1</td>
<td>train</td>
<td>2022-01-04</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>-2</td>
<td>train</td>
<td>2022-01-05</td>
<td>sample1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<section id="lopération-groupby" class="level4">
<h4 class="anchored" data-anchor-id="lopération-groupby">L’opération <code>groupBy</code></h4>
<p>La méthode <code>groupBy</code> de Pandas permet de diviser le DataFrame en sous-ensembles selon les valeurs d’une ou plusieurs colonnes, puis d’appliquer une fonction d’agrégation à chaque sous-ensemble. Elle renvoie un objet de type <code>DataFrameGroupBy</code> qui ne présente pas de grand intérêt en soi, mais constitue l’étape intermédiaire indispensable pour pouvoir ensuite appliquer une ou plusieurs fonction(s) d’agrégation aux différents groupes.</p>
<div id="5df6353b" class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'experiment'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="62">
<pre><code>&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x7f6a1c8eeb60&gt;</code></pre>
</div>
</div>
</section>
<section id="fonctions-dagrégation" class="level4">
<h4 class="anchored" data-anchor-id="fonctions-dagrégation">Fonctions d’agrégation</h4>
<p>Une fois les données groupées, on peut appliquer des fonctions d’agrégation pour obtenir un résumé statistique. Pandas intègre un certain nombre de ces fonctions, dont la liste complète est détaillée dans la <a href="https://pandas.pydata.org/docs/user_guide/groupby.html#built-in-aggregation-methods">documentation</a>. Voici quelques exemples d’utilisation de ces méthodes.</p>
<p>Par exemple, compter le nombre d’occurrences dans chaque groupe.</p>
<div id="0c16e102" class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'experiment'</span>).size()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="63">
<pre><code>experiment
test          2
train         3
validation    1
dtype: int64</code></pre>
</div>
</div>
<p>Calculer la somme d’une variable par groupe.</p>
<div id="c8c87c18" class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'experiment'</span>)[<span class="st">'var1'</span>].<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="64">
<pre><code>experiment
test          1.3
train         5.6
validation    0.0
Name: var1, dtype: float64</code></pre>
</div>
</div>
<p>Ou encore compter le nombre de valeurs unique d’une variable par groupe. Les possibilités sont nombreuses.</p>
<div id="e20657a8" class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Pour le nombre de valeurs uniques de 'var2' dans chaque groupe</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'experiment'</span>)[<span class="st">'var2'</span>].nunique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<pre><code>experiment
test          2
train         3
validation    1
Name: var2, dtype: int64</code></pre>
</div>
</div>
<p>Lorsqu’on souhaite appliquer plusieurs fonctions d’agrégation à la fois ou des fonctions personnalisées, on utilise la méthode <code>agg</code>. Cette méthode accepte une liste de fonctions ou un dictionnaire qui associe les noms des colonnes aux fonctions à appliquer. Cela permet d’appliquer plus finement les fonctions d’agrégation.</p>
<div id="6dca8a76" class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'experiment'</span>).agg({<span class="st">'var1'</span>: <span class="st">'mean'</span>, <span class="st">'var2'</span>: <span class="st">'count'</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="66">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">test</td>
<td>1.3</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">train</td>
<td>2.8</td>
<td>3</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">validation</td>
<td>NaN</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="Le chaînage de méthodes">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Le chaînage de méthodes
</div>
</div>
<div class="callout-body-container callout-body">
<p>Les exemples précédents illustrent un concept important en Pandas : le chaînage de méthodes. Ce terme désigne la possibilité d’enchaîner les transformations appliquées à un DataFrame en lui appliquant à la chaîne des méthodes. A chaque méthode appliquée, un DataFrame intermédiaire est créé (mais non assigné à une variable), qui devient l’input de la méthode suivante.</p>
<p>Le chaînage de méthodes permet de combiner plusieurs opérations en une seule expression de code. Cela peut améliorer l’efficacité en évitant les assignations intermédiaires et en rendant le code plus fluide et plus facile à lire. Cela favorise également un style de programmation fonctionnel où les données passent à travers une chaîne de transformations de manière fluide.</p>
</div>
</div>
</section>
<section id="effets-sur-lindex" class="level4">
<h4 class="anchored" data-anchor-id="effets-sur-lindex">Effets sur l’index</h4>
<p>Il est intéressant de noter les effets du processus d’agrégation sur l’index du DataFrame. Le dernier exemple ci-dessus l’illustre bien : les groupes, i.e.&nbsp;les modalités de la variable utilisée pour effectuer l’agrégation, deviennent les valeurs de l’index.</p>
<p>On peut vouloir réutiliser cette information dans des analyses ultérieures, et donc la vouloir comme une colonne. Il suffit pour cela de réinitialiser l’index avec la méthode <code>reset_index()</code>.</p>
<div id="54d500ed" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>df_agg <span class="op">=</span> df.groupby(<span class="st">'experiment'</span>).agg({<span class="st">'var1'</span>: <span class="st">'mean'</span>, <span class="st">'var2'</span>: <span class="st">'count'</span>})</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>df_agg.reset_index()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="67">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>test</td>
<td>1.3</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>train</td>
<td>2.8</td>
<td>3</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>validation</td>
<td>NaN</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
</section>
<section id="traiter-les-valeurs-manquantes" class="level3">
<h3 class="anchored" data-anchor-id="traiter-les-valeurs-manquantes">Traiter les valeurs manquantes</h3>
<p>Les valeurs manquantes sont une réalité courante dans le traitement des données réelles et peuvent survenir pour diverses raisons, telles que des non-réponses à un questionnaire, des erreurs de saisie, des pertes de données lors de la transmission ou simplement parce que l’information n’est pas applicable. Pandas offre plusieurs outils pour gérer les valeurs manquantes.</p>
<section id="représentation-des-valeurs-manquantes" class="level4">
<h4 class="anchored" data-anchor-id="représentation-des-valeurs-manquantes">Représentation des valeurs manquantes</h4>
<p>Dans Pandas, les valeurs manquantes sont généralement représentées par <code>np.nan</code>, qui est un marqueur spécial fourni par la bibliothèque <code>NumPy</code>. S’il est préférable d’utiliser cet objet pour dénoter les valeurs manquantes, notons que l’objet <code>None</code> de <code>Python</code> est également compris comme une valeur manquante par <code>Pandas</code>.</p>
<p>Vérifions cette propriété. Pour identifier où se trouvent les valeurs manquantes, on utilise la fonction <code>isna()</code> qui retourne un DataFrame booléen indiquant <code>True</code> là où les valeurs sont <code>NaN</code>.</p>
<div id="e13834fc" class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="fl">1.3</span>, <span class="fl">5.6</span>, np.nan, np.nan, <span class="dv">0</span>, np.nan],</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: np.random.randint(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">6</span>),</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"experiment"</span>: [<span class="st">"test"</span>, <span class="st">"train"</span>, <span class="st">"test"</span>, <span class="va">None</span>, <span class="st">"train"</span>, <span class="st">"validation"</span>],</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"sample"</span>: <span class="st">"sample1"</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>df.isna()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="68">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>False</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>True</td>
<td>False</td>
<td>True</td>
<td>False</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>False</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="calculs-sur-des-colonnes-contenant-des-valeurs-manquantes" class="level4">
<h4 class="anchored" data-anchor-id="calculs-sur-des-colonnes-contenant-des-valeurs-manquantes">Calculs sur des colonnes contenant des valeurs manquantes</h4>
<p>Lors de calculs statistiques, les valeurs manquantes sont généralement ignorées. Par exemple, la méthode <code>.mean()</code> calcule la moyenne des valeurs non manquantes.</p>
<div id="545e23cd" class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'var1'</span>].mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="69">
<pre><code>np.float64(2.3)</code></pre>
</div>
</div>
<p>En revanche, les calculs faisant intervenir plusieurs colonnes n’ignorent pas toujours les valeurs manquantes et peuvent souvent donner des résultats en <code>NaN</code>.</p>
<div id="94a2a252" class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'var3'</span>] <span class="op">=</span> df[<span class="st">'var1'</span>] <span class="op">+</span> df[<span class="st">'var2'</span>]</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="70">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
<th data-quarto-table-cell-role="th">var3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>-7</td>
<td>test</td>
<td>sample1</td>
<td>-5.7</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>-7</td>
<td>train</td>
<td>sample1</td>
<td>-1.4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>-6</td>
<td>test</td>
<td>sample1</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>6</td>
<td>None</td>
<td>sample1</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>-3</td>
<td>train</td>
<td>sample1</td>
<td>-3.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>NaN</td>
<td>3</td>
<td>validation</td>
<td>sample1</td>
<td>NaN</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="suppression-des-valeurs-manquantes" class="level4">
<h4 class="anchored" data-anchor-id="suppression-des-valeurs-manquantes">Suppression des valeurs manquantes</h4>
<p>La méthode <code>dropna()</code> permet de supprimer les lignes (<code>axis=0</code>) ou les colonnes (<code>axis=1</code>) contenant des valeurs manquantes. Par défaut, toute ligne contenant au moins une valeur manquante est supprimée.</p>
<div id="61480ecc" class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>df.dropna()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
<th data-quarto-table-cell-role="th">var3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>-7</td>
<td>test</td>
<td>sample1</td>
<td>-5.7</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>-7</td>
<td>train</td>
<td>sample1</td>
<td>-1.4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>-3</td>
<td>train</td>
<td>sample1</td>
<td>-3.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>En modifiant le paramètre <code>axis</code>, on peut demander à ce que toute colonne contenant au moins une valeur manquante soit supprimée.</p>
<div id="d9205869" class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>df.dropna(axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>-7</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>-7</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>-6</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>6</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>-3</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>3</td>
<td>sample1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Enfin, le paramètre <code>how</code> définit la modalité de supression. Par défaut, une ligne ou colonne est supprimée lorsqu’au moins une valeur est manquante (<code>how=any</code>), mais il est possible de ne supprimer la ligne/colonne que lorsque toutes les valeurs sont manquantes (<code>how=all</code>).</p>
</section>
<section id="remplacement-des-valeurs-manquantes" class="level4">
<h4 class="anchored" data-anchor-id="remplacement-des-valeurs-manquantes">Remplacement des valeurs manquantes</h4>
<p>Pour gérer les valeurs manquantes dans un DataFrame, une approche commune est l’imputation, qui consiste à remplacer les valeurs manquantes par d’autres valeurs. La méthode <code>fillna()</code> permet d’effectuer cette opération de différentes manières. Une première possibilité est le remplacement par une valeur constante.</p>
<div id="5dcb6570" class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'var1'</span>].fillna(value<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="73">
<pre><code>0    1.3
1    5.6
2    0.0
3    0.0
4    0.0
5    0.0
Name: var1, dtype: float64</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled" title="Changement de représentation des valeurs manquantes">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Changement de représentation des valeurs manquantes
</div>
</div>
<div class="callout-body-container callout-body">
<p>On peut parfois être tentant de changer la manifestation d’une valeur manquante pour des raisons de visibilité, par exemple en la remplaçant par une chaîne de caractères :</p>
<div id="337cc281" class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'var1'</span>].fillna(value<span class="op">=</span><span class="st">"MISSING"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="74">
<pre><code>0        1.3
1        5.6
2    MISSING
3    MISSING
4        0.0
5    MISSING
Name: var1, dtype: object</code></pre>
</div>
</div>
<p>En pratique, cette façon de faire n’est pas recommandée. Il est en effet préférable de conserver la convention standard de <code>Pandas</code> (l’utilisation des <code>np.nan</code>), d’abord pour des questions de standardisation des pratiques qui facilitent la lecture et la maintenance du code, mais également parce que la convention standard est optimisée pour la performance et les calculs à partir de données contenant des valeurs manquantes.</p>
</div>
</div>
<p>Une autre méthode d’imputation fréquente est d’utiliser une valeur statistique, comme la moyenne ou la médiane de la variable.</p>
<div id="c290ccd7" class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'var1'</span>].fillna(value<span class="op">=</span>df[<span class="st">'var1'</span>].mean())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="75">
<pre><code>0    1.3
1    5.6
2    2.3
3    2.3
4    0.0
5    2.3
Name: var1, dtype: float64</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled" title="Biais d'imputation">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Biais d’imputation
</div>
</div>
<div class="callout-body-container callout-body">
<p>Remplacer les valeurs manquantes par une valeur constante, telle que zéro, la moyenne ou la médiane, peut être problématique. Si les données ne sont pas manquantes au hasard (<em>Missing Not At Random</em> - <em>MNAR</em>), cela peut introduire un biais dans l’analyse. Les variables <em>MNAR</em> sont des variables dont la probabilité d’être manquantes est liée à leur propre valeur ou à d’autres variables dans les données. Dans de tels cas, une imputation plus sophistiquée peut être nécessaire pour minimiser les distorsions. Nous en verrons un exemple en exercice de fin de tutoriel.</p>
</div>
</div>
</section>
</section>
<section id="traiter-les-données-de-types-spécifiques" class="level3">
<h3 class="anchored" data-anchor-id="traiter-les-données-de-types-spécifiques">Traiter les données de types spécifiques</h3>
<section id="données-textuelles" class="level4">
<h4 class="anchored" data-anchor-id="données-textuelles">Données textuelles</h4>
<p>Les données textuelles nécessitent souvent un nettoyage et une préparation avant l’analyse. Pandas fournit via la librairie de méthodes <code>str</code> un ensemble d’opérations vectorisées qui rendent la préparation des données textuelles à la fois simple et très efficace. Là encore, les possibilités sont multiples et détaillées dans la <a href="https://pandas.pydata.org/docs/user_guide/text.html">documentation</a>. Nous présentons ici les méthodes les plus fréquemment utilisées dans l’analyse de données.</p>
<div id="c23111af" class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="fl">1.3</span>, <span class="fl">5.6</span>, np.nan, np.nan, <span class="dv">0</span>, np.nan],</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: np.random.randint(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">6</span>),</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"experiment"</span>: [<span class="st">"test"</span>, <span class="st">"train"</span>, <span class="st">"test"</span>, <span class="st">"test"</span>, <span class="st">"train"</span>, <span class="st">"validation"</span>],</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"sample"</span>: [<span class="st">"  sample1"</span>, <span class="st">"sample1"</span>, <span class="st">"sample2"</span>, <span class="st">"   sample2   "</span>, <span class="st">"sample2  "</span>, <span class="st">"sample1"</span>]</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="76">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>7</td>
<td>test</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>8</td>
<td>train</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>3</td>
<td>test</td>
<td>sample2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>6</td>
<td>test</td>
<td>sample2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>-6</td>
<td>train</td>
<td>sample2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>NaN</td>
<td>0</td>
<td>validation</td>
<td>sample1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Une première opération fréquente consiste à extraire certains caractères d’une chaîne. On utilise pour cela la fonction (à la syntaxe un peu particulière) <code>str[n:]</code> Par exemple, si l’on veut extraire le dernier caractère de la variable <code>sample</code> afin de ne retenir que le chiffre de l’échantillon.</p>
<div id="4c02fba6" class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"sample_n"</span>] <span class="op">=</span> df[<span class="st">"sample"</span>].<span class="bu">str</span>[<span class="op">-</span><span class="dv">1</span>:]</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="77">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
<th data-quarto-table-cell-role="th">sample_n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>7</td>
<td>test</td>
<td>sample1</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>8</td>
<td>train</td>
<td>sample1</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>3</td>
<td>test</td>
<td>sample2</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>6</td>
<td>test</td>
<td>sample2</td>
<td></td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>-6</td>
<td>train</td>
<td>sample2</td>
<td></td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>NaN</td>
<td>0</td>
<td>validation</td>
<td>sample1</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Le principe était le bon, mais la présence d’espaces superflus dans nos données textuelles (qui ne se voyaient pas à la visualisation du DataFrame !) a rendu l’opération plus difficile que prévue. C’est l’occasion d’introduire la famille de méthode <code>strip</code> (<code>.str.strip()</code>, <code>.str.lstrip()</code> et <code>.str.rstrip()</code>) qui respectivement retirent les espaces superflus des deux côtés ou d’un seul.</p>
<div id="7c51cebe" class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"sample"</span>] <span class="op">=</span> df[<span class="st">"sample"</span>].<span class="bu">str</span>.strip()</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"sample_n"</span>] <span class="op">=</span> df[<span class="st">"sample"</span>].<span class="bu">str</span>[<span class="op">-</span><span class="dv">1</span>:]</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="78">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
<th data-quarto-table-cell-role="th">sample_n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>7</td>
<td>test</td>
<td>sample1</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>8</td>
<td>train</td>
<td>sample1</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>3</td>
<td>test</td>
<td>sample2</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>6</td>
<td>test</td>
<td>sample2</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>-6</td>
<td>train</td>
<td>sample2</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>NaN</td>
<td>0</td>
<td>validation</td>
<td>sample1</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>On peut également vouloir filtrer un DataFrame en fonction de la présence ou non d’une certaine chaîne (ou sous-chaîne) de caractères. On utilise pour cela la méthode <code>.str.contains()</code>.</p>
<div id="4a40d6c1" class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>df[df[<span class="st">'experiment'</span>].<span class="bu">str</span>.contains(<span class="st">'test'</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="79">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
<th data-quarto-table-cell-role="th">sample_n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>7</td>
<td>test</td>
<td>sample1</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>3</td>
<td>test</td>
<td>sample2</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>6</td>
<td>test</td>
<td>sample2</td>
<td>2</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Enfin, on peut vouloir remplacer une chaîne (ou sous-chaîne) de caractères par une autre, ce que permet la méthode <code>str.replace()</code>.</p>
<div id="618de9db" class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'experiment'</span>] <span class="op">=</span> df[<span class="st">'experiment'</span>].<span class="bu">str</span>.replace(<span class="st">'validation'</span>, <span class="st">'val'</span>)</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="80">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
<th data-quarto-table-cell-role="th">sample</th>
<th data-quarto-table-cell-role="th">sample_n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>7</td>
<td>test</td>
<td>sample1</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>8</td>
<td>train</td>
<td>sample1</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>3</td>
<td>test</td>
<td>sample2</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>6</td>
<td>test</td>
<td>sample2</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>-6</td>
<td>train</td>
<td>sample2</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>NaN</td>
<td>0</td>
<td>val</td>
<td>sample1</td>
<td>1</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="données-catégorielles" class="level4">
<h4 class="anchored" data-anchor-id="données-catégorielles">Données catégorielles</h4>
<p>Les données catégorielles sont des variables qui contiennent un nombre restreint de modalités. A l’instar de <code>R</code> avec la notion de <code>factor</code>, Pandas a un type de données spécial, <code>category</code>, qui est utile pour représenter des données catégorielles de manière plus efficace et plus informative. Les données catégorielles sont en effet optimisées pour certains types de données et peuvent accélérer les opérations comme le groupement et le tri. Elles sont également utiles pour la visualisation, car elles permettent d’assurer que les catégories sont affichées dans un ordre cohérent et logique.</p>
<p>Pour convertir une variable au format <code>category</code>, on utilise la méthode <code>astype()</code>.</p>
<div id="ca694c53" class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="fl">1.3</span>, <span class="fl">5.6</span>, np.nan, np.nan, <span class="dv">0</span>, np.nan],</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: np.random.randint(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">6</span>),</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"experiment"</span>: [<span class="st">"test"</span>, <span class="st">"train"</span>, <span class="st">"test"</span>, <span class="va">None</span>, <span class="st">"train"</span>, <span class="st">"validation"</span>],</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.dtypes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>var1          float64
var2            int64
experiment     object
dtype: object</code></pre>
</div>
</div>
<div id="a8b9c168" class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'experiment'</span>] <span class="op">=</span> df[<span class="st">'experiment'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.dtypes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>var1           float64
var2             int64
experiment    category
dtype: object</code></pre>
</div>
</div>
<p>Cette conversion nous donne accès à quelques méthodes bien pratiques, spécifiques au traitement des variables catégorielles. Il peut par exemple être utile de renommer les catégories pour des raisons de clarté ou de standardisation.</p>
<div id="dee42aa5" class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'experiment'</span>] <span class="op">=</span> df[<span class="st">'experiment'</span>].cat.rename_categories({<span class="st">'test'</span>: <span class="st">'Test'</span>, <span class="st">'train'</span>: <span class="st">'Train'</span>, <span class="st">'validation'</span>: <span class="st">'Validation'</span>})</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="83">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">experiment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1.3</td>
<td>-5</td>
<td>Test</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.6</td>
<td>-4</td>
<td>Train</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>NaN</td>
<td>9</td>
<td>Test</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>NaN</td>
<td>-7</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.0</td>
<td>8</td>
<td>Train</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>NaN</td>
<td>-2</td>
<td>Validation</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Parfois, l’ordre des catégories est significatif, et on peut vouloir le modifier. En particulier dans le cadre de la visualisation, car les modalités seront par défaut affichées dans l’ordre spécifié.</p>
<div id="2ff07cdc" class="cell" data-execution_count="84">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>df_cat <span class="op">=</span> df[<span class="st">'experiment'</span>].cat.reorder_categories([<span class="st">'Test'</span>, <span class="st">'Train'</span>, <span class="st">'Validation'</span>], ordered<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">"experiment"</span>).mean().plot(kind<span class="op">=</span><span class="st">'bar'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_2709/419168969.py:2: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.
  df.groupby("experiment").mean().plot(kind='bar')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tutorial_files/figure-html/cell-85-output-2.png" width="569" height="484" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="données-temporelles" class="level4">
<h4 class="anchored" data-anchor-id="données-temporelles">Données temporelles</h4>
<p>Les données temporelles sont souvent présentes dans les données tabulaires afin d’identifier temporellement les observations recueillies. Pandas offre des fonctionnalités pour manipuler ces types de données, notamment grâce au type <code>datetime64</code> qui permet une manipulation précise des dates et des heures.</p>
<div id="3d572187" class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">13</span>],</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: [<span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">11</span>, <span class="dv">15</span>],</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"date"</span>: [<span class="st">"2022-01-01"</span>, <span class="st">"2022-01-02"</span>, <span class="st">"2023-01-01"</span>, <span class="st">"2023-01-02"</span>],</span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"sample"</span>: [<span class="st">"sample1"</span>, <span class="st">"sample1"</span>, <span class="st">"sample2"</span>, <span class="st">"sample2"</span>]</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>df.dtypes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="85">
<pre><code>var1       int64
var2       int64
date      object
sample    object
dtype: object</code></pre>
</div>
</div>
<p>Pour manipuler les données temporelles, il est nécessaire de convertir les chaînes de caractères en objets <code>datetime</code>. Pandas le fait via la fonction <code>to_datetime()</code>.</p>
<div id="f469f02e" class="cell" data-execution_count="86">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'date'</span>] <span class="op">=</span> pd.to_datetime(df[<span class="st">'date'</span>])</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>df.dtypes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="86">
<pre><code>var1               int64
var2               int64
date      datetime64[ns]
sample            object
dtype: object</code></pre>
</div>
</div>
<p>Une fois converties, les dates peuvent être formatées, comparées et utilisées dans des calculs. En particulier, Pandas comprend à présent l’“ordre” des dates présentes dans les données, et permet donc le filtrage sur des périodes données.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>df[(df[<span class="st">'date'</span>] <span class="op">&gt;=</span> <span class="st">"2022-01-01"</span>) <span class="op">&amp;</span> (df[<span class="st">'date'</span>] <span class="op">&lt;</span> <span class="st">"2022-01-03"</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On peut également vouloir réaliser des filtrages moins précis, faisant intervenir l’année ou le mois. Pandas permet d’extraire facilement des composants spécifiques de la date, comme l’année, le mois, le jour, l’heure, etc.</p>
<div id="adc2f535" class="cell" data-execution_count="87">
<div class="sourceCode cell-code" id="cb124"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'year'</span>] <span class="op">=</span> df[<span class="st">'date'</span>].dt.year</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'month'</span>] <span class="op">=</span> df[<span class="st">'date'</span>].dt.month</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'day'</span>] <span class="op">=</span> df[<span class="st">'date'</span>].dt.day</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>df[df[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2023</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="87">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th">sample</th>
<th data-quarto-table-cell-role="th">year</th>
<th data-quarto-table-cell-role="th">month</th>
<th data-quarto-table-cell-role="th">day</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9</td>
<td>11</td>
<td>2023-01-01</td>
<td>sample2</td>
<td>2023</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>13</td>
<td>15</td>
<td>2023-01-02</td>
<td>sample2</td>
<td>2023</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Enfin, les calculs faisant intervenir des dates deviennent possible. On peut ajouter ou soustraire des périodes temporelles à des dates, et les comparer entre elles. Les fonctions utilisées sont issues de <code>Pandas</code>, mais sont très semblables dans leur fonctionnement à celles du module <a href="https://docs.python.org/fr/3/library/time.html">time</a> de Python.</p>
<p>On peut par exemple ajouter des intervalles de temps, ou bien calculer des écarts à une date de référence.</p>
<div id="57dc6085" class="cell" data-execution_count="88">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'date_plus_one'</span>] <span class="op">=</span> df[<span class="st">'date'</span>] <span class="op">+</span> pd.Timedelta(days<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'date_diff'</span>] <span class="op">=</span> df[<span class="st">'date'</span>] <span class="op">-</span> pd.to_datetime(<span class="st">'2022-01-01'</span>)</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="88">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th">sample</th>
<th data-quarto-table-cell-role="th">year</th>
<th data-quarto-table-cell-role="th">month</th>
<th data-quarto-table-cell-role="th">day</th>
<th data-quarto-table-cell-role="th">date_plus_one</th>
<th data-quarto-table-cell-role="th">date_diff</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>3</td>
<td>2022-01-01</td>
<td>sample1</td>
<td>2022</td>
<td>1</td>
<td>1</td>
<td>2022-01-02</td>
<td>0 days</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>7</td>
<td>2022-01-02</td>
<td>sample1</td>
<td>2022</td>
<td>1</td>
<td>2</td>
<td>2022-01-03</td>
<td>1 days</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9</td>
<td>11</td>
<td>2023-01-01</td>
<td>sample2</td>
<td>2023</td>
<td>1</td>
<td>1</td>
<td>2023-01-02</td>
<td>365 days</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>13</td>
<td>15</td>
<td>2023-01-02</td>
<td>sample2</td>
<td>2023</td>
<td>1</td>
<td>2</td>
<td>2023-01-03</td>
<td>366 days</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
</section>
<section id="joindre-des-tables" class="level3">
<h3 class="anchored" data-anchor-id="joindre-des-tables">Joindre des tables</h3>
<p>Dans le cadre d’une analyse de données, il est courant de vouloir combiner différentes sources de données. Cette combinaison peut se faire verticalement (un DataFrame par dessus l’autre), par exemple lorsque l’on souhaite combiner deux millésimes d’une même enquête afin de les analyser conjointement. La combinaison peut également se faire horizontalement (côte à côte) selon une ou plusieurs clé(s) de jointure, souvent dans le but d’enrichir une source de données à partir d’une autre source portant sur les mêmes unités statistiques.</p>
<section id="concaténer-des-tables" class="level4">
<h4 class="anchored" data-anchor-id="concaténer-des-tables">Concaténer des tables</h4>
<p>La concaténation verticale de tables se fait à l’aide de la fonction <code>concat()</code> de Pandas.</p>
<div id="a4cfb43c" class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>df1 <span class="op">=</span> pd.DataFrame(</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="dv">1</span>, <span class="dv">5</span>],</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: [<span class="dv">3</span>, <span class="dv">7</span>],</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"date"</span>: [<span class="st">"2022-01-01"</span>, <span class="st">"2022-01-02"</span>],</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"sample"</span>: [<span class="st">"sample1"</span>, <span class="st">"sample1"</span>]</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a>df2 <span class="op">=</span> pd.DataFrame(</span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {</span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var1"</span>: [<span class="dv">9</span>, <span class="dv">13</span>],</span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">"date"</span>: [<span class="st">"2023-01-01"</span>, <span class="st">"2023-01-02"</span>],</span>
<span id="cb126-14"><a href="#cb126-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">"var2"</span>: [<span class="dv">11</span>, <span class="dv">15</span>],</span>
<span id="cb126-15"><a href="#cb126-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">"sample"</span>: [<span class="st">"sample2"</span>, <span class="st">"sample2"</span>]</span>
<span id="cb126-16"><a href="#cb126-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb126-17"><a href="#cb126-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb126-18"><a href="#cb126-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-19"><a href="#cb126-19" aria-hidden="true" tabindex="-1"></a>df_concat <span class="op">=</span> pd.concat([df1, df2])</span>
<span id="cb126-20"><a href="#cb126-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-21"><a href="#cb126-21" aria-hidden="true" tabindex="-1"></a>df_concat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="89">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>3</td>
<td>2022-01-01</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>7</td>
<td>2022-01-02</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>9</td>
<td>11</td>
<td>2023-01-01</td>
<td>sample2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>13</td>
<td>15</td>
<td>2023-01-02</td>
<td>sample2</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Notons que l’ordre des variables dans les deux DataFrames n’est pas important. Pandas ne juxtapose pas “bêtement” les deux DataFrames, il fait une correspondance des schémas pour faire correspondre les variables par nom. Si deux variables ont le même nom mais pas le même type - par exemple dans le cas où une variable numérique aurait été interprétée comme des strings - Pandas va résoudre le problème en prenant le dénominateur commun, c’est à dire en général convertir en strings (type <code>object</code>).</p>
<p>Par contre, la concaténation précédente laisse apparaître un problème de répétition au niveau de l’index. C’est logique : on n’a pas spécifié d’index pour nos deux DataFrames initiaux, qui ont donc le même index de position ([0, 1]). Dans ce cas (où l’index n’est pas important), on peut passer le paramètre <code>ignore_index=True</code> pour reconstruire de zéro l’index final.</p>
<div id="777f1323" class="cell" data-execution_count="90">
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>df_concat <span class="op">=</span> pd.concat([df1, df2], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>df_concat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="90">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">var1</th>
<th data-quarto-table-cell-role="th">var2</th>
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th">sample</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>3</td>
<td>2022-01-01</td>
<td>sample1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5</td>
<td>7</td>
<td>2022-01-02</td>
<td>sample1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9</td>
<td>11</td>
<td>2023-01-01</td>
<td>sample2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>13</td>
<td>15</td>
<td>2023-01-02</td>
<td>sample2</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled" title="Construction itérative d'un DataFrame">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Construction itérative d’un DataFrame
</div>
</div>
<div class="callout-body-container callout-body">
<p>On pourrait avoir l’idée d’utiliser <code>pd.concat()</code> pour construire un DataFrame de manière itérative, en ajoutant à chaque itération d’une boucle une nouvelle ligne au DataFrame existant. Ce n’est néanmoins pas une bonne idée : comme nous l’avons vu, un DataFrame est représenté dans la mémoire commme une juxtaposition de Series. Ainsi, ajouter une colonne à un DataFrame est peu coûteux, mais ajouter une ligne implique de modifier chaque élément constituant du DataFrame. Pour construire un DataFrame, il est donc plutôt conseillé de stocker les lignes dans une liste de listes (une par colonne) ou un dictionnaire, puis d’appeler <code>pd.DataFrame()</code> pour construire le DataFrame, comme nous l’avons fait au début de ce tutoriel.</p>
</div>
</div>
</section>
<section id="fusionner-des-tables" class="level4">
<h4 class="anchored" data-anchor-id="fusionner-des-tables">Fusionner des tables</h4>
<p>La fusion de tables est une opération qui permet d’associer des lignes de deux DataFrames différents en se basant sur une ou plusieurs clés communes, similaire aux jointures dans les bases de données SQL. Différents types de jointure sont possible selon les données que l’on souhaite conserver, dont les principaux sont représentés sur le graphique suivant.</p>
<p><img src="img/joins.png" class="img-fluid"></p>
<p>Source : <a href="https://medium.com/swlh/merging-dataframes-with-pandas-pd-merge-7764c7e2d46d">lien</a></p>
<p>En Pandas, les jointures se font avec la fonction <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html">merge()</a>. Pour réaliser une jointure, on doit spécifier (au minimum) deux informations :</p>
<ul>
<li><p>le type de jointure : par défaut, Pandas effectue une jointure de type <code>inner</code>. Le paramètre <code>how</code> permet de spécifier d’autres types de jointure ;</p></li>
<li><p>la clé de jointure. Par défaut, Pandas essaie de joindre les deux DataFrames à partir de leurs index. En pratique, on spécifie souvent une variable présente dans le DataFrames comme clé de jointure (paramètre <code>on</code> si la variable porte le même nom dans les deux DataFrame, ou <code>left_on</code> et <code>right_on</code> sinon).</p></li>
</ul>
<p>Analysons la différence entre les différents types de jointure à travers des exemples.</p>
<div id="b86db658" class="cell" data-execution_count="91">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>df_a <span class="op">=</span> pd.DataFrame({</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">'key'</span>: [<span class="st">'K0'</span>, <span class="st">'K1'</span>, <span class="st">'K2'</span>, <span class="st">'K3'</span>, <span class="st">'K4'</span>],</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'A'</span>: [<span class="st">'A0'</span>, <span class="st">'A1'</span>, <span class="st">'A2'</span>, <span class="st">'A3'</span>, <span class="st">'A4'</span>],</span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'B'</span>: [<span class="st">'B0'</span>, <span class="st">'B1'</span>, <span class="st">'B2'</span>, <span class="st">'B3'</span>, <span class="st">'A4'</span>]</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>df_b <span class="op">=</span> pd.DataFrame({</span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'key'</span>: [<span class="st">'K0'</span>, <span class="st">'K1'</span>, <span class="st">'K2'</span>, <span class="st">'K5'</span>, <span class="st">'K6'</span>],</span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'C'</span>: [<span class="st">'C0'</span>, <span class="st">'C1'</span>, <span class="st">'C2'</span>, <span class="st">'C5'</span>, <span class="st">'C6'</span>],</span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'D'</span>: [<span class="st">'D0'</span>, <span class="st">'D1'</span>, <span class="st">'D2'</span>, <span class="st">'D5'</span>, <span class="st">'D6'</span>]</span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>display(df_a)</span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>display(df_b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">key</th>
<th data-quarto-table-cell-role="th">A</th>
<th data-quarto-table-cell-role="th">B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>K0</td>
<td>A0</td>
<td>B0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>K1</td>
<td>A1</td>
<td>B1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>K2</td>
<td>A2</td>
<td>B2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>K3</td>
<td>A3</td>
<td>B3</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>K4</td>
<td>A4</td>
<td>A4</td>
</tr>
</tbody>
</table>

</div>
</div>
<div class="cell-output cell-output-display">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">key</th>
<th data-quarto-table-cell-role="th">C</th>
<th data-quarto-table-cell-role="th">D</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>K0</td>
<td>C0</td>
<td>D0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>K1</td>
<td>C1</td>
<td>D1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>K2</td>
<td>C2</td>
<td>D2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>K5</td>
<td>C5</td>
<td>D5</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>K6</td>
<td>C6</td>
<td>D6</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>La jointure de type <code>inner</code> conserve les observations dont la clé est présente dans les deux DataFrame.</p>
<div id="c1a55590" class="cell" data-execution_count="92">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>df_merged_inner <span class="op">=</span> pd.merge(df_a, df_b, on<span class="op">=</span><span class="st">'key'</span>)</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>df_merged_inner</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="92">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">key</th>
<th data-quarto-table-cell-role="th">A</th>
<th data-quarto-table-cell-role="th">B</th>
<th data-quarto-table-cell-role="th">C</th>
<th data-quarto-table-cell-role="th">D</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>K0</td>
<td>A0</td>
<td>B0</td>
<td>C0</td>
<td>D0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>K1</td>
<td>A1</td>
<td>B1</td>
<td>C1</td>
<td>D1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>K2</td>
<td>A2</td>
<td>B2</td>
<td>C2</td>
<td>D2</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled" title="Jointures inner">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Jointures inner
</div>
</div>
<div class="callout-body-container callout-body">
<p>La jointure de type <code>inner</code> est la plus intuitive : elle ne crée généralement pas de valeurs manquantes et permet donc de travailler directement sur la table fusionnée. Mais attention : si beaucoup de clés ne sont pas présentes dans les deux DataFrames à la fois, une jointure <code>inner</code> peut aboutit à des pertes importantes de données, et donc à des résultats finaux biaisés. Dans ce cas, il vaut mieux choisir une jointure à gauche ou à droite, selon la source que l’on cherche à enrichir et pour laquelle il est donc le plus important de limiter les pertes de données.</p>
</div>
</div>
<p>Une jointure de type <code>left</code> conserve toutes les observations contenues dans le DataFrame de gauche (premier DataFrame spécifié dans <code>pd.merge()</code>). Par conséquent, si des clés sont présentes dans le DataFrame de gauche mais pas dans celui de droite, le DataFrame final contient des valeurs manquantes au niveau de ces observations (pour les variables du DataFrame de droite).</p>
<div id="50769d19" class="cell" data-execution_count="93">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>df_merged_left <span class="op">=</span> pd.merge(df_a, df_b, how<span class="op">=</span><span class="st">"left"</span>, on<span class="op">=</span><span class="st">'key'</span>)</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>df_merged_left</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="93">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">key</th>
<th data-quarto-table-cell-role="th">A</th>
<th data-quarto-table-cell-role="th">B</th>
<th data-quarto-table-cell-role="th">C</th>
<th data-quarto-table-cell-role="th">D</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>K0</td>
<td>A0</td>
<td>B0</td>
<td>C0</td>
<td>D0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>K1</td>
<td>A1</td>
<td>B1</td>
<td>C1</td>
<td>D1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>K2</td>
<td>A2</td>
<td>B2</td>
<td>C2</td>
<td>D2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>K3</td>
<td>A3</td>
<td>B3</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>K4</td>
<td>A4</td>
<td>A4</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>La jointure de type <code>outer</code> contient toutes les observations et variables contenues dans les deux DataFrame. Ainsi, l’information retenue est maximale, mais en contrepartie les valeurs manquantes peuvent être assez nombreuses. Il sera donc nécessaire de bien traiter les valeurs manquantes avant de procéder aux analyses.</p>
<div id="9080d197" class="cell" data-execution_count="94">
<div class="sourceCode cell-code" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>df_merged_outer <span class="op">=</span> pd.merge(df_a, df_b, how<span class="op">=</span><span class="st">"outer"</span>, on<span class="op">=</span><span class="st">'key'</span>)</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>df_merged_outer</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="94">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">key</th>
<th data-quarto-table-cell-role="th">A</th>
<th data-quarto-table-cell-role="th">B</th>
<th data-quarto-table-cell-role="th">C</th>
<th data-quarto-table-cell-role="th">D</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>K0</td>
<td>A0</td>
<td>B0</td>
<td>C0</td>
<td>D0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>K1</td>
<td>A1</td>
<td>B1</td>
<td>C1</td>
<td>D1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>K2</td>
<td>A2</td>
<td>B2</td>
<td>C2</td>
<td>D2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>K3</td>
<td>A3</td>
<td>B3</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>K4</td>
<td>A4</td>
<td>A4</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>K5</td>
<td>NaN</td>
<td>NaN</td>
<td>C5</td>
<td>D5</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>K6</td>
<td>NaN</td>
<td>NaN</td>
<td>C6</td>
<td>D6</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
</section>
</section>
<section id="exercices" class="level2">
<h2 class="anchored" data-anchor-id="exercices">Exercices</h2>
<section id="questions-de-compréhension" class="level3">
<h3 class="anchored" data-anchor-id="questions-de-compréhension">Questions de compréhension</h3>
<ul>
<li><p>1/ Qu’est-ce qu’un DataFrame dans le contexte de Pandas et à quel type de structure de données peut-on le comparer dans le langage Python ?</p></li>
<li><p>2/ Quelle est la différence fondamentale entre un array Numpy et une Pandas Series ?</p></li>
<li><p>3/ Quel est le lien entre Series et DataFrame dans Pandas ?</p></li>
<li><p>4/ Comment sont structurées les données dans un DataFrame Pandas ?</p></li>
<li><p>5/ Quel est le rôle de l’index dans un DataFrame Pandas et comment peut-il être utilisé lors de la manipulation des données ?</p></li>
<li><p>6/ Quelles méthodes pouvez-vous utiliser pour explorer un DataFrame inconnu et en apprendre davantage sur son contenu et sa structure ?</p></li>
<li><p>7/ Dans Pandas, quelle est la différence entre assigner le résultat d’une opération à une nouvelle variable et utiliser une méthode avec l’argument <code>inplace=True</code> ?</p></li>
<li><p>8/ Comment s’applique le principe de la vectorisation dans Pandas et pourquoi est-ce avantageux pour manipuler les données ?</p></li>
<li><p>9/ Comment Pandas représente-t-il les valeurs manquantes et quel impact cela a-t-il sur les calculs et les transformations de données ?</p></li>
<li><p>10/ Quelle est la différence entre concaténer deux DataFrames et les joindre via une jointure, et quand utiliseriez-vous l’une plutôt que l’autre ?</p></li>
</ul>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<ul>
<li><p>1/ Un DataFrame dans Pandas est une structure de données bidimensionnelle, comparable à un tableau ou une feuille de calcul Excel. Dans le contexte Python, on peut le comparer à un dictionnaire d’arrays NumPy, où les clés sont les noms des colonnes et les valeurs sont les colonnes elles-mêmes.</p></li>
<li><p>2/ La différence principale entre un array NumPy et une Series Pandas est que la Series peut contenir des données étiquetées, c’est-à-dire qu’elle a un index qui lui est associé, permettant des accès et des manipulations par label.</p></li>
<li><p>3/ Un DataFrame est essentiellement une collection de Series. Chaque colonne d’un DataFrame est une Series, et toutes ces Series partagent le même index, qui correspond aux étiquettes des lignes du DataFrame.</p></li>
<li><p>4/ Les données dans un DataFrame Pandas sont structurées en colonnes et en lignes. Chaque colonne peut contenir un type de données différent (numérique, chaîne de caractères, booléen, etc.), et chaque ligne représente une observation.</p></li>
<li><p>5/ L’index dans un DataFrame Pandas sert à identifier de manière unique chaque ligne du DataFrame. Il permet d’accéder rapidement aux lignes, de réaliser des jointures, de trier les données et de faciliter les opérations de regroupement.</p></li>
<li><p>6/ Pour explorer un DataFrame inconnu, on peut utiliser df.head() pour voir les premières lignes, df.tail() pour les dernières, df.info() pour obtenir un résumé des types de données et des valeurs manquantes, et df.describe() pour des statistiques descriptives.</p></li>
<li><p>7/ Assigner le résultat d’une opération à une nouvelle variable crée une copie du DataFrame avec les modifications appliquées. Utiliser une méthode avec inplace=True modifie le DataFrame original sans créer de copie, ce qui peut être plus efficace en termes de mémoire.</p></li>
<li><p>8/ Pandas représente les valeurs manquantes avec l’objet <code>nan</code> (Not a Number) de <code>Numpy</code> pour les données numériques et avec None ou pd.NaT pour les dates/temps. Ces valeurs manquantes sont généralement ignorées dans les calculs de fonctions statistiques, ce qui peut affecter les résultats si elles ne sont pas traitées correctement.</p></li>
<li><p>9/ Concaténer consiste à assembler des DataFrames en les empilant verticalement ou en les alignant horizontalement, principalement utilisé lorsque les DataFrames ont le même schéma ou lorsque vous souhaitez empiler les données. Les jointures, inspirées des opérations JOIN en SQL, combinent les DataFrames sur la base de valeurs de clés communes et sont utilisées pour enrichir un ensemble de données avec des informations d’un autre ensemble.</p></li>
</ul>
</details>
</div>
</section>
<section id="plusieurs-manières-de-créer-un-dataframe" class="level3">
<h3 class="anchored" data-anchor-id="plusieurs-manières-de-créer-un-dataframe">Plusieurs manières de créer un DataFrame</h3>
<p>Dans la cellule suivante, nous avons récupéré des données de caisses sur les ventes de différentes enseignes. Les données sont cependant présentées de deux manières différentes, dans un cas sous forme d’observations (chaque liste contient les données d’une ligne), dans l’autre sous forme de variables (chaque liste contient les données d’une colonne).</p>
<div id="80f95f4d" class="cell" data-execution_count="95">
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>data_list1 <span class="op">=</span> [</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Carrefour'</span>, <span class="st">'01.1.1'</span>, <span class="dv">3</span>, <span class="fl">1.50</span>],</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Casino'</span>, <span class="st">'02.1.1'</span>, <span class="dv">2</span>, <span class="fl">2.30</span>],</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Lidl'</span>, <span class="st">'01.1.1'</span>, <span class="dv">7</span>, <span class="fl">0.99</span>],</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Carrefour'</span>, <span class="st">'03.1.1'</span>, <span class="dv">5</span>, <span class="fl">5.00</span>],</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Casino'</span>, <span class="st">'01.1.1'</span>, <span class="dv">10</span>, <span class="fl">1.20</span>],</span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Lidl'</span>, <span class="st">'02.1.1'</span>, <span class="dv">1</span>, <span class="fl">3.10</span>]</span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>data_list2 <span class="op">=</span> [</span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Carrefour'</span>, <span class="st">'Casino'</span>, <span class="st">'Lidl'</span>, <span class="st">'Carrefour'</span>, <span class="st">'Casino'</span>, <span class="st">'Lidl'</span>],</span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'01.1.1'</span>, <span class="st">'02.1.1'</span>, <span class="st">'01.1.1'</span>, <span class="st">'03.1.1'</span>, <span class="st">'01.1.1'</span>, <span class="st">'02.1.1'</span>],</span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">1</span>],</span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.50</span>, <span class="fl">2.30</span>, <span class="fl">0.99</span>, <span class="fl">5.00</span>, <span class="fl">1.20</span>, <span class="fl">3.10</span>]</span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>L’objectif est de construire dans les deux cas un même DataFrame qui contient chacune des 6 observations et des 4 variables, avec les mêmes noms dans les deux DataFrame. A chaque cas va correspondre une structure de données plus adaptée en entrée, dictionnaire ou liste de listes… faîtes le bon choix ! On vérifiera que les deux DataFrames sont identiques à l’aide de la méthode <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.equals.html">equals()</a>.</p>
<div id="5c1dad48" class="cell" data-execution_count="96">
<div class="sourceCode cell-code" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>data_list1 <span class="op">=</span> [</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Carrefour'</span>, <span class="st">'Casino'</span>, <span class="st">'Lidl'</span>, <span class="st">'Carrefour'</span>, <span class="st">'Casino'</span>, <span class="st">'Lidl'</span>],</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'01.1.1'</span>, <span class="st">'02.1.1'</span>, <span class="st">'01.1.1'</span>, <span class="st">'03.1.1'</span>, <span class="st">'01.1.1'</span>, <span class="st">'02.1.1'</span>],</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">1</span>],</span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.50</span>, <span class="fl">2.30</span>, <span class="fl">0.99</span>, <span class="fl">5.00</span>, <span class="fl">1.20</span>, <span class="fl">3.10</span>]</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>data_list2 <span class="op">=</span> [</span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Carrefour'</span>, <span class="st">'01.1.1'</span>, <span class="dv">3</span>, <span class="fl">1.50</span>],</span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Casino'</span>, <span class="st">'02.1.1'</span>, <span class="dv">2</span>, <span class="fl">2.30</span>],</span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Lidl'</span>, <span class="st">'01.1.1'</span>, <span class="dv">7</span>, <span class="fl">0.99</span>],</span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Carrefour'</span>, <span class="st">'03.1.1'</span>, <span class="dv">5</span>, <span class="fl">5.00</span>],</span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Casino'</span>, <span class="st">'01.1.1'</span>, <span class="dv">10</span>, <span class="fl">1.20</span>],</span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'Lidl'</span>, <span class="st">'02.1.1'</span>, <span class="dv">1</span>, <span class="fl">3.10</span>]</span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Si les données sont sous forme de colonnes : à partir d'un dictionnaire</span></span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>data_dict <span class="op">=</span> {</span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">'enseigne'</span>: data_list1[<span class="dv">0</span>],</span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">'produit'</span>: data_list1[<span class="dv">1</span>],</span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quantite'</span>: data_list1[<span class="dv">2</span>],</span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a>    <span class="st">'prix'</span>: data_list1[<span class="dv">3</span>]</span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true" tabindex="-1"></a>df_from_dict <span class="op">=</span> pd.DataFrame(data_dict)</span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-27"><a href="#cb134-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Si les données sont sous forme de lignes : à partir d'une liste de listes</span></span>
<span id="cb134-28"><a href="#cb134-28" aria-hidden="true" tabindex="-1"></a>columns <span class="op">=</span> [<span class="st">'enseigne'</span>, <span class="st">'produit'</span>, <span class="st">'quantite'</span>, <span class="st">'prix'</span>]</span>
<span id="cb134-29"><a href="#cb134-29" aria-hidden="true" tabindex="-1"></a>df_from_list <span class="op">=</span> pd.DataFrame(data_list2, columns<span class="op">=</span>columns)</span>
<span id="cb134-30"><a href="#cb134-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-31"><a href="#cb134-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Vérification</span></span>
<span id="cb134-32"><a href="#cb134-32" aria-hidden="true" tabindex="-1"></a>df_from_dict.equals(df_from_list)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sélection-de-données-dans-un-dataframe" class="level3">
<h3 class="anchored" data-anchor-id="sélection-de-données-dans-un-dataframe">Sélection de données dans un DataFrame</h3>
<p>Un DataFrame Pandas est créé avec des données de caisse (mêmes données que l’exercice précédent).</p>
<div id="ce1569d5" class="cell" data-execution_count="97">
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">'enseigne'</span>: [<span class="st">'Carrefour'</span>, <span class="st">'Casino'</span>, <span class="st">'Lidl'</span>, <span class="st">'Carrefour'</span>, <span class="st">'Casino'</span>, <span class="st">'Lidl'</span>],</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'produit'</span>: [<span class="st">'01.1.1'</span>, <span class="st">'02.1.1'</span>, <span class="st">'01.1.1'</span>, <span class="st">'03.1.1'</span>, <span class="st">'01.1.1'</span>, <span class="st">'02.1.1'</span>],</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quantite'</span>: [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">1</span>],</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'prix'</span>: [<span class="fl">1.50</span>, <span class="fl">2.30</span>, <span class="fl">0.99</span>, <span class="fl">5.00</span>, <span class="fl">1.20</span>, <span class="fl">3.10</span>],</span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'date_heure'</span>: pd.to_datetime([<span class="st">"2022-01-01 14:05"</span>, <span class="st">"2022-01-02 09:30"</span>, </span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a>                                  <span class="st">"2022-01-03 17:45"</span>, <span class="st">"2022-01-04 08:20"</span>, </span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a>                                  <span class="st">"2022-01-05 19:00"</span>, <span class="st">"2022-01-06 16:30"</span>])</span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Utilisez les méthodes <code>loc</code> et <code>iloc</code> pour sélectionner des données spécifiques :</p>
<ul>
<li>Sélectionner les données de la première ligne.</li>
</ul>
<div id="797950b9" class="cell" data-execution_count="98">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.iloc[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Sélectionner toutes les données de la colonne “prix”.</li>
</ul>
<div id="de0749eb" class="cell" data-execution_count="99">
<div class="sourceCode cell-code" id="cb138"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb139"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.loc[:, <span class="st">'prix'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Sélectionner les lignes correspondant à l’enseigne “Carrefour” uniquement.</li>
</ul>
<div id="db5368fd" class="cell" data-execution_count="100">
<div class="sourceCode cell-code" id="cb140"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.loc[df[<span class="st">'enseigne'</span>] <span class="op">==</span> <span class="st">'Carrefour'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Sélectionner les quantités achetées pour les produits classifiés “01.1.1” (Pain).</li>
</ul>
<div id="19c52129" class="cell" data-execution_count="101">
<div class="sourceCode cell-code" id="cb142"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb143"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.loc[df[<span class="st">'produit'</span>] <span class="op">==</span> <span class="st">'01.1.1'</span>, <span class="st">'quantite'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Sélectionner les données des colonnes “enseigne” et “prix” pour toutes les lignes.</li>
</ul>
<div id="39d3eb00" class="cell" data-execution_count="102">
<div class="sourceCode cell-code" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb145"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.loc[:, [<span class="st">'enseigne'</span>, <span class="st">'prix'</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Sélectionner les lignes où la quantité achetée est supérieure à 5.</li>
</ul>
<div id="c7b684f6" class="cell" data-execution_count="103">
<div class="sourceCode cell-code" id="cb146"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb147"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.loc[df[<span class="st">'quantite'</span>] <span class="op">&gt;</span> <span class="dv">5</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Filtrer pour sélectionner toutes les transactions qui ont eu lieu après 15h.</li>
</ul>
<div id="412eebbc" class="cell" data-execution_count="104">
<div class="sourceCode cell-code" id="cb148"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb149"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.loc[df[<span class="st">'date_heure'</span>].dt.hour <span class="op">&gt;</span> <span class="dv">15</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Sélectionner les transactions qui ont eu lieu le “2022-01-03”.</li>
</ul>
<div id="beb13cbf" class="cell" data-execution_count="105">
<div class="sourceCode cell-code" id="cb150"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb151"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.loc[df[<span class="st">'date_heure'</span>].dt.date <span class="op">==</span> pd.to_datetime(<span class="st">'2022-01-03'</span>).date()])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="exploration-du-fichier-des-prénoms" class="level3">
<h3 class="anchored" data-anchor-id="exploration-du-fichier-des-prénoms">Exploration du fichier des prénoms</h3>
<p>Le fichier des prénoms contient des données sur les prénoms attribués aux enfants nés en France entre 1900 et 2021. Ces données sont disponibles au niveau France, par département et par région, à l’adresse suivante : <a href="https://www.insee.fr/fr/statistiques/2540004?sommaire=4767262">https://www.insee.fr/fr/statistiques/2540004?sommaire=4767262</a>. L’objectif de ce tutoriel est de proposer une analyse de ce fichier, du nettoyage des données au statistiques sur les prénoms.</p>
<section id="partie-1-import-et-exploration-des-données" class="level4">
<h4 class="anchored" data-anchor-id="partie-1-import-et-exploration-des-données">Partie 1 : Import et exploration des données</h4>
<ul>
<li>Importez les données dans un DataFrame en utilisant cette <a href="https://www.insee.fr/fr/statistiques/fichier/2540004/nat2021_csv.zip">URL</a>.</li>
<li>Visualisez un échantillon des données. Repérez-vous d’éventuelles anomalies ?</li>
<li>Affichez les principales informations du DataFrame. Repérez d’éventuelles variables dont le type serait incorrect, ou bien d’éventuelles valeurs manquantes.</li>
</ul>
<div id="5245b5e1" class="cell" data-execution_count="106">
<div class="sourceCode cell-code" id="cb152"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb153"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://www.insee.fr/fr/statistiques/fichier/2540004/nat2021_csv.zip"</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>df_prenoms <span class="op">=</span> pd.read_csv(url, sep<span class="op">=</span><span class="st">";"</span>)</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>df_prenoms.head(<span class="dv">10</span>)</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>df_prenoms.sample(n<span class="op">=</span><span class="dv">50</span>)</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>df_prenoms.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="partie-2-nettoyage-des-données" class="level4">
<h4 class="anchored" data-anchor-id="partie-2-nettoyage-des-données">Partie 2 : Nettoyage des données</h4>
<ul>
<li>L’output de la méthode <code>info()</code> suggère des valeurs manquantes dans la colonne des prénoms. Affichez ces lignes. Vérifiez que ces valeurs manquantes sont correctement spécifiées.</li>
<li>L’output de méthode <code>head()</code> montre une modalité récurrente “_PRENOMS_RARES” dans la colonne des prénoms. Quelle proportion des individus de la base cela concerne-t-il ? Convertir ces valeurs en <code>np.nan</code>.</li>
</ul>
<div id="4c42777b" class="cell" data-execution_count="107">
<div class="sourceCode cell-code" id="cb154"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb155"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_prenoms[df_prenoms[<span class="st">"preusuel"</span>].isna()])</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>prop_rares <span class="op">=</span> df_prenoms.groupby(<span class="st">"preusuel"</span>)[<span class="st">"nombre"</span>].<span class="bu">sum</span>()[<span class="st">"_PRENOMS_RARES"</span>] <span class="op">/</span> df_prenoms[<span class="st">"nombre"</span>].<span class="bu">sum</span>()</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(prop_rares)  <span class="co"># ~ 2 % de la base</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>df_prenoms <span class="op">=</span> df_prenoms.replace(<span class="st">'_PRENOMS_RARES'</span>, np.nan)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>On remarque que les prénoms de personnes dont l’année de naissance n’est pas connue sont regroupés sous la modalité <code>XXXX</code>. Quelle proportion des individus de la base cela concerne-t-il ? Convertir ces valeurs en <code>np.nan</code>.</li>
</ul>
<div id="58ec8186" class="cell" data-execution_count="108">
<div class="sourceCode cell-code" id="cb156"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb157"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>prop_xxxx <span class="op">=</span> df_prenoms.groupby(<span class="st">"annais"</span>)[<span class="st">"nombre"</span>].<span class="bu">sum</span>()[<span class="st">"XXXX"</span>] <span class="op">/</span> df_prenoms[<span class="st">"nombre"</span>].<span class="bu">sum</span>()</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(prop_xxxx)  <span class="co"># ~ 1 % de la base</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>df_prenoms <span class="op">=</span> df_prenoms.replace(<span class="st">'XXXX'</span>, np.nan)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Supprimer les lignes contenant des valeurs manquantes de l’échantillon.</li>
</ul>
<div id="a1245544" class="cell" data-execution_count="109">
<div class="sourceCode cell-code" id="cb158"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb159"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>df_prenoms <span class="op">=</span> df_prenoms.dropna()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Convertissez la colonne <code>annais</code> en type numérique et la colonne <code>sexe</code> en type catégoriel.</li>
</ul>
<div id="ebdea13a" class="cell" data-execution_count="110">
<div class="sourceCode cell-code" id="cb160"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb161"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>df_prenoms[<span class="st">'annais'</span>] <span class="op">=</span> pd.to_numeric(df_prenoms[<span class="st">'annais'</span>])</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>df_prenoms[<span class="st">'sexe'</span>] <span class="op">=</span> df_prenoms[<span class="st">'sexe'</span>].astype(<span class="st">'category'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Vérifiez avec la méthode <code>info()</code> que le nettoyage a été correctement appliqué.</li>
</ul>
<div id="28377c64" class="cell" data-execution_count="111">
<div class="sourceCode cell-code" id="cb162"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb163"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>df_prenoms.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="partie-3-statistiques-descriptives-sur-les-naissances" class="level4">
<h4 class="anchored" data-anchor-id="partie-3-statistiques-descriptives-sur-les-naissances">Partie 3 : Statistiques descriptives sur les naissances</h4>
<ul>
<li>La <a href="https://www.insee.fr/fr/statistiques/2540004?sommaire=4767262#documentation">documentation</a> du fichier nous informe qu’on peut considérer les données comme quasi-exhaustives à partir de 1946. Pour cette partie seulement, filtrer les données pour ne conserver que les données ultérieures.</li>
</ul>
<div id="fbfd0277" class="cell" data-execution_count="112">
<div class="sourceCode cell-code" id="cb164"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>df_prenoms_post_1946 <span class="op">=</span> df_prenoms[df_prenoms[<span class="st">"annais"</span>] <span class="op">&gt;=</span> <span class="dv">1946</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Calculez le nombre total de naissances par sexe.</li>
</ul>
<div id="6e8b6e75" class="cell" data-execution_count="113">
<div class="sourceCode cell-code" id="cb166"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb167"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>births_per_sex <span class="op">=</span> df_prenoms_post_1946.groupby(<span class="st">'sexe'</span>)[<span class="st">'nombre'</span>].<span class="bu">sum</span>()</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(births_per_sex)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Identifiez les cinq années ayant le plus grand nombre de naissances.</li>
</ul>
<div id="9a626ce9" class="cell" data-execution_count="114">
<div class="sourceCode cell-code" id="cb168"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb169"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>top5_years <span class="op">=</span> df_prenoms_post_1946.groupby(<span class="st">'annais'</span>)[<span class="st">'nombre'</span>].<span class="bu">sum</span>().nlargest(<span class="dv">5</span>)</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(top5_years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="partie-4-analyse-des-prénoms" class="level4">
<h4 class="anchored" data-anchor-id="partie-4-analyse-des-prénoms">Partie 4 : Analyse des prénoms</h4>
<ul>
<li>Identifiez le nombre total de prénoms uniques dans le DataFrame.</li>
</ul>
<div id="ca6bba18" class="cell" data-execution_count="115">
<div class="sourceCode cell-code" id="cb170"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb171"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>total_unique_names <span class="op">=</span> df_prenoms[<span class="st">'preusuel'</span>].nunique()</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(total_unique_names)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Compter le nombre de personnes possédant un prénom d’une seule lettre.</li>
</ul>
<div id="8dc6940d" class="cell" data-execution_count="116">
<div class="sourceCode cell-code" id="cb172"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb173"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>single_letter_names <span class="op">=</span> df_prenoms[df_prenoms[<span class="st">'preusuel'</span>].<span class="bu">str</span>.<span class="bu">len</span>() <span class="op">==</span> <span class="dv">1</span>][<span class="st">'nombre'</span>].<span class="bu">sum</span>()</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(single_letter_names)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Créez une “fonction de popularité” qui, pour un prénom donné, affiche l’année où il a été le plus donné ainsi que le nombre de fois où il a été donné cette année-là.</li>
</ul>
<div id="aef73c89" class="cell" data-execution_count="117">
<div class="sourceCode cell-code" id="cb174"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb175"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> popularite_par_annee(df, prenom):</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filtrer le DataFrame pour ne garder que les lignes correspondant au prénom donné</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>    df_prenom <span class="op">=</span> df[df[<span class="st">'preusuel'</span>] <span class="op">==</span> prenom]</span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Grouper par année, sommer les naissances et identifier l'année avec le maximum de naissances</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>    df_agg <span class="op">=</span> df_prenom.groupby(<span class="st">'annais'</span>)[<span class="st">'nombre'</span>].<span class="bu">sum</span>()</span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>    annee_max <span class="op">=</span> df_agg.idxmax()</span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a>    n_max <span class="op">=</span> df_agg[annee_max]</span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Le prénom '</span><span class="sc">{</span>prenom<span class="sc">}</span><span class="ss">' a été le plus donné en </span><span class="sc">{</span>annee_max<span class="sc">}</span><span class="ss">, avec </span><span class="sc">{</span>n_max<span class="sc">}</span><span class="ss"> naissances."</span>)</span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Test de la fonction avec un exemple</span></span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a>popularite_par_annee(df_prenoms, <span class="st">'ALFRED'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Créez une fonction qui, pour un sexe donné, renvoie un DataFrame contenant le prénom le plus donné pour chaque décennie.</li>
</ul>
<div id="7c0912a3" class="cell" data-execution_count="118">
<div class="sourceCode cell-code" id="cb176"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb177"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> popularite_par_decennie(df, sexe):</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filtrage sur le sexe</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>    df_sub <span class="op">=</span> df[df[<span class="st">"sexe"</span>] <span class="op">==</span> sexe]</span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul de la variable décennie</span></span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>    df_sub[<span class="st">"decennie"</span>] <span class="op">=</span> (df_sub[<span class="st">"annais"</span>] <span class="op">//</span> <span class="dv">10</span>) <span class="op">*</span> <span class="dv">10</span></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculer la somme des naissances pour chaque prénom et chaque décennie</span></span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a>    df_counts_decennie <span class="op">=</span> df_sub.groupby([<span class="st">"preusuel"</span>, <span class="st">"decennie"</span>])[<span class="st">"nombre"</span>].<span class="bu">sum</span>().reset_index()</span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Trouver l'indice du prénom le plus fréquent pour chaque décennie</span></span>
<span id="cb177-12"><a href="#cb177-12" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> df_counts_decennie.groupby(<span class="st">"decennie"</span>)[<span class="st">"nombre"</span>].idxmax()</span>
<span id="cb177-13"><a href="#cb177-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-14"><a href="#cb177-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Utiliser l'indice pour obtenir les lignes correspondantes du DataFrame df_counts_decennie</span></span>
<span id="cb177-15"><a href="#cb177-15" aria-hidden="true" tabindex="-1"></a>    df_popularite_decennie <span class="op">=</span> df_counts_decennie.loc[idx].set_index(<span class="st">"decennie"</span>)</span>
<span id="cb177-16"><a href="#cb177-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-17"><a href="#cb177-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df_popularite_decennie</span>
<span id="cb177-18"><a href="#cb177-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-19"><a href="#cb177-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Test de la fonction avec un exemple</span></span>
<span id="cb177-20"><a href="#cb177-20" aria-hidden="true" tabindex="-1"></a>popularite_par_decennie(df_prenoms, sexe<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="calcul-dune-empreinte-carbone-par-habitant-au-niveau-communal" class="level3">
<h3 class="anchored" data-anchor-id="calcul-dune-empreinte-carbone-par-habitant-au-niveau-communal">Calcul d’une empreinte carbone par habitant au niveau communal</h3>
<p>L’objectif de cet exercice est de calculer une empreinte carbone par habitant au niveau communal. Pour cela, il va falloir combiner deux sources de données :</p>
<ul>
<li><p>les populations légales au niveau des communes, issues du recensement de la population (<a href="https://www.insee.fr/fr/statistiques/6683037">source</a>)</p></li>
<li><p>les émissions de gaz à effet de serre estimées au niveau communal par l’ADEME (<a href="https://www.data.gouv.fr/fr/datasets/inventaire-de-gaz-a-effet-de-serre-territorialise/#_">source</a>)</p></li>
</ul>
<p>Cet exercice constitue une version simplifiée d’un <a href="https://pythonds.linogaliana.fr/content/manipulation/02b_pandas_TP.html#importer-les-donn%C3%A9es">TP complet pour la pratique de Pandas</a> proposé par Lino Galiana dans son <a href="https://pythonds.linogaliana.fr/">cours à l’ENSAE</a>.</p>
<section id="partie-1-exploration-des-données-sur-les-populations-légales-communales" class="level4">
<h4 class="anchored" data-anchor-id="partie-1-exploration-des-données-sur-les-populations-légales-communales">Partie 1 : Exploration des données sur les populations légales communales</h4>
<ul>
<li>Importez le fichier CSV <code>communes.csv</code>.</li>
<li>Utilisez les méthodes <code>.sample()</code>, <code>.info()</code> et <code>.describe()</code> pour obtenir un aperçu des données.</li>
</ul>
<div id="d8d71f42" class="cell" data-execution_count="119">
<div class="sourceCode cell-code" id="cb178"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb179"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>df_pop_communes <span class="op">=</span> pd.read_csv(<span class="st">"data/communes.csv"</span>, sep<span class="op">=</span><span class="st">";"</span>)</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>df_pop_communes.sample(<span class="dv">10</span>)</span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>df_pop_communes.info()</span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>df_pop_communes.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Identifiez et retirez les lignes correspondant aux communes sans population.</li>
<li>Supprimez les colonnes “PMUN” et “PCAP”, non pertinentes pour l’analyse.</li>
</ul>
<div id="410a89fa" class="cell" data-execution_count="120">
<div class="sourceCode cell-code" id="cb180"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb181"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>n_communes_0_pop <span class="op">=</span> df_pop_communes[df_pop_communes[<span class="st">"PTOT"</span>] <span class="op">==</span> <span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(n_communes_0_pop)</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>df_pop_communes <span class="op">=</span> df_pop_communes[df_pop_communes[<span class="st">"PTOT"</span>] <span class="op">&gt;</span> <span class="dv">0</span>]</span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>df_pop_communes <span class="op">=</span> df_pop_communes.drop(columns<span class="op">=</span>[<span class="st">"PMUN"</span>, <span class="st">"PCAP"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Les communes qui ont les noms les plus longs sont-elles aussi les communes les moins peuplées ? Pour le savoir : - Créez une nouvelle variable qui contient le nombre de caractères de chaque commune à l’aide de la méthode <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.str.len.html">str.len()</a> - Calculez la corrélation entre cette variable et la population totale avec la méthode <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.corr.html">corr()</a></p>
<div id="bb0124ff" class="cell" data-execution_count="121">
<div class="sourceCode cell-code" id="cb182"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb183"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>df_pop_communes_stats <span class="op">=</span> df_pop_communes.copy()</span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>df_pop_communes_stats[<span class="st">'longueur'</span>] <span class="op">=</span> df_pop_communes_stats[<span class="st">'COM'</span>].<span class="bu">str</span>.<span class="bu">len</span>()</span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>df_pop_communes_stats[<span class="st">'longueur'</span>].corr(df_pop_communes_stats[<span class="st">'PTOT'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="partie-2-exploration-des-données-sur-les-émissions-communales" class="level4">
<h4 class="anchored" data-anchor-id="partie-2-exploration-des-données-sur-les-émissions-communales">Partie 2 : Exploration des données sur les émissions communales</h4>
<ul>
<li>Importez les données d’émission depuis cette <a href="https://data.ademe.fr/data-fair/api/v1/datasets/igt-pouvoir-de-rechauffement-global/data-files/IGT%20-%20Pouvoir%20de%20r%C3%A9chauffement%20global.csv">URL</a></li>
<li>Utilisez les méthodes <code>.sample()</code>, <code>.info()</code> et <code>.describe()</code> pour obtenir un aperçu des données.</li>
</ul>
<div id="72adee3d" class="cell" data-execution_count="122">
<div class="sourceCode cell-code" id="cb184"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb185"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a>url_ademe <span class="op">=</span> <span class="st">"https://data.ademe.fr/data-fair/api/v1/datasets/igt-pouvoir-de-rechauffement-global/data-files/IGT%20-%20Pouvoir</span><span class="sc">%20d</span><span class="st">e</span><span class="sc">%20r</span><span class="st">%C3%A9chauffement</span><span class="sc">%20g</span><span class="st">lobal.csv"</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a>df_emissions <span class="op">=</span> pd.read_csv(url_ademe)</span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>df_emissions.sample(<span class="dv">10</span>)</span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>df_emissions.info()</span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a>df_emissions.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Y a-t-il des lignes avec des valeurs manquantes pour toutes les colonnes d’émission ? Vérifiez-le à l’aide des méthodes <a href="https://pandas.pydata.org/docs/reference/api/pandas.isnull.html">isnull()</a> et <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.all.html">all()</a>.</li>
</ul>
<div id="b59b6042" class="cell" data-execution_count="123">
<div class="sourceCode cell-code" id="cb186"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb187"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a>df_emissions_num <span class="op">=</span> df_emissions.select_dtypes([<span class="st">'number'</span>])</span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>only_nan <span class="op">=</span> df_emissions_num[df_emissions_num.isnull().<span class="bu">all</span>(axis<span class="op">=</span><span class="dv">1</span>)]</span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>only_nan.shape[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Créez une nouvelle colonne qui donne les émissions totales par commune</li>
<li>Afficher les 10 communes les plus émettrices. Qu’observez-vous dans les résultats ?</li>
</ul>
<div id="d84b34ce" class="cell" data-execution_count="124">
<div class="sourceCode cell-code" id="cb188"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb189"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>df_emissions[<span class="st">'emissions_totales'</span>] <span class="op">=</span> df_emissions.<span class="bu">sum</span>(axis <span class="op">=</span> <span class="dv">1</span>, numeric_only <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>df_emissions.sort_values(by<span class="op">=</span><span class="st">"emissions_totales"</span>, ascending<span class="op">=</span><span class="va">False</span>).head(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Il semble que les postes majeurs d’émissions soient “Industrie hors-énergie” et “Autres transports international”. Pour vérifier si cette conjecture tient, calculer la corrélation entre les émissions totales et les postes sectoriels d’émissions à l’aide de la méthode <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.corrwith.html">corrwith()</a>.</li>
</ul>
<div id="b6fa7259" class="cell" data-execution_count="125">
<div class="sourceCode cell-code" id="cb190"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb191"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>df_emissions.corrwith(df_emissions[<span class="st">"emissions_totales"</span>], numeric_only<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Extraire du code commune le numéro de département dans une nouvelle variable</li>
<li>Calculer les émissions totales par département</li>
<li>Afficher les 10 principaux départements émetteurs. Les résultats sont-ils logiques par rapport à l’analyse au niveau communal ?</li>
</ul>
<div id="bf8212dc" class="cell" data-execution_count="126">
<div class="sourceCode cell-code" id="cb192"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb193"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a>df_emissions[<span class="st">"dep"</span>] <span class="op">=</span> df_emissions[<span class="st">"INSEE commune"</span>].<span class="bu">str</span>[:<span class="dv">2</span>]</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>df_emissions.groupby(<span class="st">"dep"</span>).agg({<span class="st">"emissions_totales"</span>: <span class="st">"sum"</span>}).sort_values(by<span class="op">=</span><span class="st">"emissions_totales"</span>, ascending<span class="op">=</span><span class="va">False</span>).head(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="partie-3-vérifications-préalables-pour-la-jointure-des-sources-de-données" class="level4">
<h4 class="anchored" data-anchor-id="partie-3-vérifications-préalables-pour-la-jointure-des-sources-de-données">Partie 3 : Vérifications préalables pour la jointure des sources de données</h4>
<p>Pour effectuer une jointure, il est toujours préférable d’avoir une clé de jointure, i.e.&nbsp;une colonne commune aux deux sources, qui identifie uniquement les unités statistiques. L’objet de cette partie est de trouver la clé de jointure pertinente.</p>
<ul>
<li>Vérifiez si la variable contenant les noms de commune contient des doublons</li>
</ul>
<div id="ddf86430" class="cell" data-execution_count="127">
<div class="sourceCode cell-code" id="cb194"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb195"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>doublons <span class="op">=</span> df_pop_communes.groupby(<span class="st">'COM'</span>).count()[<span class="st">'DEPCOM'</span>]</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>doublons <span class="op">=</span> doublons[doublons<span class="op">&gt;</span><span class="dv">1</span>]</span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>doublons <span class="op">=</span> doublons.reset_index()</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>doublons</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Filtrez dans le DataFrame initial les communes dont le nom est dupliqué, et triez-le par code commune. Les doublons semblent-ils problématiques ?</li>
</ul>
<div id="32ccea82" class="cell" data-execution_count="128">
<div class="sourceCode cell-code" id="cb196"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb197"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>df_pop_communes_doublons <span class="op">=</span> df_pop_communes[df_pop_communes[<span class="st">"COM"</span>].isin(doublons[<span class="st">"COM"</span>])]</span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>df_pop_communes_doublons.sort_values(<span class="st">'COM'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Vérifiez que les codes commune identifient de manière unique la commune associée</li>
</ul>
<div id="da777c69" class="cell" data-execution_count="129">
<div class="sourceCode cell-code" id="cb198"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb199"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>(df_pop_communes_doublons.groupby(<span class="st">"DEPCOM"</span>)[<span class="st">"COM"</span>].nunique() <span class="op">!=</span> <span class="dv">1</span>).<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Affichez les communes présentes dans les données communales mais pas dans les données d’émissions, et inversement. Qu’en concluez-vous ?</li>
</ul>
<div id="75518158" class="cell" data-execution_count="130">
<div class="sourceCode cell-code" id="cb200"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb201"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Observations qui sont dans les pop légales mais pas dans les données d'émissions</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>df_pop_communes[<span class="op">~</span>df_pop_communes[<span class="st">"DEPCOM"</span>].isin(df_emissions[<span class="st">"INSEE commune"</span>])]</span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Observations qui sont dans les données d'émissions mais pas dans les pop légales</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>df_emissions[<span class="op">~</span>df_emissions[<span class="st">"INSEE commune"</span>].isin(df_pop_communes[<span class="st">"DEPCOM"</span>])]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="partie-4-calcul-dune-empreinte-carbone-par-habitant-pour-chaque-commune" class="level4">
<h4 class="anchored" data-anchor-id="partie-4-calcul-dune-empreinte-carbone-par-habitant-pour-chaque-commune">Partie 4 : Calcul d’une empreinte carbone par habitant pour chaque commune</h4>
<ul>
<li>Joindre les deux DataFrames à l’aide de la fonction à partir du code commune. Attention : les variables ne s’appellent pas de la même manière des deux côtés !</li>
</ul>
<div id="bffdf1c0" class="cell" data-execution_count="131">
<div class="sourceCode cell-code" id="cb202"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb203"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a>df_emissions_pop <span class="op">=</span> pd.merge(df_pop_communes, df_emissions, how<span class="op">=</span><span class="st">"inner"</span>, left_on<span class="op">=</span><span class="st">"DEPCOM"</span>, right_on<span class="op">=</span><span class="st">"INSEE commune"</span>)</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>df_emissions_pop</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li>Calculer une empreinte carbone pour chaque commune, correspondant aux émissions totales de la commune divisées par sa population totale.</li>
<li>Affichez les 10 communes avec les empreintes carbones les plus élevées.</li>
<li>Les résultats sont-ils identiques à ceux avec les émissions totales ? Qu’en concluez-vous ?</li>
</ul>
<div id="ddb4dc45" class="cell" data-execution_count="132">
<div class="sourceCode cell-code" id="cb204"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb205"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>df_emissions_pop[<span class="st">"empreinte_carbone"</span>] <span class="op">=</span> df_emissions_pop[<span class="st">"emissions_totales"</span>] <span class="op">/</span> df_emissions_pop[<span class="st">"PTOT"</span>]</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a>df_emissions_pop.sort_values(<span class="st">"empreinte_carbone"</span>, ascending<span class="op">=</span><span class="va">False</span>).head(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="analyse-de-lévolution-dun-indice-de-production" class="level3">
<h3 class="anchored" data-anchor-id="analyse-de-lévolution-dun-indice-de-production">Analyse de l’évolution d’un indice de production</h3>
<p>Vous avez à disposition dans le dossier <code>data/</code> deux jeux de données CSV : - <code>serie_glaces_valeurs.csv</code> contient les valeurs mensuelles de l’indice de prix de production de l’industrie française des glaces et sorbets - <code>serie_glaces_metadonnees.csv</code> contient les métadonnées associées, notamment les codes indiquant le statut des données.</p>
<p>L’objectif est d’utiliser <code>Pandas</code> pour calculer : - l’évolution de l’indice entre chaque période (mois) - l’évolution de l’indice en glissement annuel (entre un mois donné et le même mois l’année suivante).</p>
<section id="partie-1-import-des-données" class="level4">
<h4 class="anchored" data-anchor-id="partie-1-import-des-données">Partie 1 : Import des données</h4>
<ul>
<li>Importez les deux fichiers CSV dans des DataFrames. Attention, dans les deux cas, il y a des lignes superflues avant les données, qu’il faudra sauter à l’aide du paramètre <code>skiprows</code> de la fonction <a href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html">read_csv()</a>.</li>
<li>Donnez des noms simples et pertinents aux différentes variables.</li>
</ul>
<div id="ad2e649b" class="cell" data-execution_count="133">
<div class="sourceCode cell-code" id="cb206"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb207"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>df_valeurs <span class="op">=</span> pd.read_csv(<span class="st">'data/serie_glaces_valeurs.csv'</span>, delimiter<span class="op">=</span><span class="st">';'</span>,</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>                         skiprows<span class="op">=</span><span class="dv">4</span>, names<span class="op">=</span>[<span class="st">"periode"</span>, <span class="st">"indice"</span>, <span class="st">"code"</span>])</span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>df_metadata <span class="op">=</span> pd.read_csv(<span class="st">'data/serie_glaces_metadonnees.csv'</span>, delimiter<span class="op">=</span><span class="st">';'</span>,</span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>                          skiprows<span class="op">=</span><span class="dv">5</span>, names<span class="op">=</span>[<span class="st">"code"</span>, <span class="st">"signification"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="partie-2-filtrage-des-données-pertinentes" class="level4">
<h4 class="anchored" data-anchor-id="partie-2-filtrage-des-données-pertinentes">Partie 2 : Filtrage des données pertinentes</h4>
<ul>
<li>Fusionner les deux DataFrames afin de récupérer la signification des codes présents dans les données.</li>
<li>Filtrer les données de sorte à ne conserver que les données de type “Valeur normale”.</li>
<li>Supprimer les colonnes liées aux codes, dont nous n’avons plus besoin pour la suite.</li>
</ul>
<div id="6f066c5a" class="cell" data-execution_count="134">
<div class="sourceCode cell-code" id="cb208"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb209"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>df_merged <span class="op">=</span> pd.merge(df_valeurs, df_metadata, how<span class="op">=</span><span class="st">'left'</span>, on<span class="op">=</span><span class="st">'code'</span>)</span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a>df_clean <span class="op">=</span> df_merged[df_merged[<span class="st">'code'</span>] <span class="op">==</span> <span class="st">"A"</span>]</span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a>df_clean <span class="op">=</span> df_clean[[<span class="st">"periode"</span>, <span class="st">"indice"</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="partie-3-pré-traitement-des-données" class="level4">
<h4 class="anchored" data-anchor-id="partie-3-pré-traitement-des-données">Partie 3 : Pré-traitement des données</h4>
<p>Vérifiez si les types des variables sont pertinents selon leur nature. Sinon, convertissez-les avec les fonctions idoines.</p>
<div id="64626174" class="cell" data-execution_count="135">
<div class="sourceCode cell-code" id="cb210"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb211"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a>df_clean.info()</span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a>df_clean[<span class="st">'periode'</span>] <span class="op">=</span> pd.to_datetime(df_clean[<span class="st">'periode'</span>])</span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a>df_clean[<span class="st">'indice'</span>] <span class="op">=</span> pd.to_numeric(df_clean[<span class="st">'indice'</span>])</span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a>df_clean.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="partie-4-calcul-de-lévolution-périodique" class="level4">
<h4 class="anchored" data-anchor-id="partie-4-calcul-de-lévolution-périodique">Partie 4 : Calcul de l’évolution périodique</h4>
<ul>
<li>Utilisez la méthode <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.shift.html">shift()</a> pour créer une nouvelle colonne qui contiendra l’indice du trimestre précédent</li>
<li>Calculez la différence entre l’indice actuel et l’indice décalé pour obtenir l’évolution (en pourcentage) d’un trimestre à l’autre</li>
</ul>
<div id="03de60c8" class="cell" data-execution_count="136">
<div class="sourceCode cell-code" id="cb212"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb213"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a>df_clean[<span class="st">'indice_prec'</span>] <span class="op">=</span> df_clean[<span class="st">'indice'</span>].shift(<span class="dv">1</span>)</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a>df_clean[<span class="st">'evo'</span>] <span class="op">=</span> ((df_clean[<span class="st">'indice'</span>] <span class="op">-</span> df_clean[<span class="st">'indice_prec'</span>]) <span class="op">/</span> df_clean[<span class="st">'indice_prec'</span>]) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Méthode alternative</span></span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a>df_clean[<span class="st">'evo_alt'</span>] <span class="op">=</span> df_clean[<span class="st">'indice'</span>].pct_change(periods<span class="op">=</span><span class="dv">1</span>) <span class="op">*</span> <span class="dv">100</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="partie-5-calcul-de-lévolution-glissante-sur-12-mois" class="level4">
<h4 class="anchored" data-anchor-id="partie-5-calcul-de-lévolution-glissante-sur-12-mois">Partie 5 : Calcul de l’évolution glissante sur 12 mois</h4>
<p>Comme vous avez pu le voir dans la solution de l’exercice précédent, la méthode <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pct_change.html">pct_change()</a> permet précisément de calculer une évolution entre deux périodes. Utiliser cette méthode pour calculer une évolution (en pourcentage) en glissement annuel pour chaque mois.</p>
<div id="5ffe2858" class="cell" data-execution_count="137">
<div class="sourceCode cell-code" id="cb214"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell markdown">
<details>
<summary>
Afficher la solution
</summary>
<div class="sourceCode" id="cb215"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a>df_clean[<span class="st">"evo_glissement_annuel"</span>] <span class="op">=</span> df_clean[<span class="st">'indice'</span>].pct_change(periods<span class="op">=</span><span class="dv">12</span>) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>df_clean.head(<span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
      for (let i=0; i<annoteTargets.length; i++) {
        const annoteTarget = annoteTargets[i];
        const targetCell = annoteTarget.getAttribute("data-target-cell");
        const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
        const contentFn = () => {
          const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          if (content) {
            const tipContent = content.cloneNode(true);
            tipContent.classList.add("code-annotation-tip-content");
            return tipContent.outerHTML;
          }
        }
        const config = {
          allowHTML: true,
          content: contentFn,
          onShow: (instance) => {
            selectCodeLines(instance.reference);
            instance.reference.classList.add('code-annotation-active');
            window.tippy.hideAll();
          },
          onHide: (instance) => {
            unselectCodeLines();
            instance.reference.classList.remove('code-annotation-active');
          },
          maxWidth: 300,
          delay: [50, 0],
          duration: [200, 0],
          offset: [5, 10],
          arrow: true,
          appendTo: function(el) {
            return el.parentElement.parentElement.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'right',
          popperOptions: {
            modifiers: [
            {
              name: 'flip',
              options: {
                flipVariations: false, // true by default
                allowedAutoPlacements: ['right'],
                fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
              },
            },
            {
              name: 'preventOverflow',
              options: {
                mainAxis: false,
                altAxis: false
              }
            }
            ]        
          }      
        };
        window.tippy(annoteTarget, config); 
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>