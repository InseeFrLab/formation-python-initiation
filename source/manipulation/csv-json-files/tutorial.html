<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Travailler avec des fichiers CSV et JSON</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Travailler avec des fichiers CSV et JSON</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Dans le précédent tutoriel, nous avons vu comment utiliser des fonctions provenant de modules, ainsi que comment lire et écrire des fichiers texte. Dans ce tutoriel, nous allons mettre à profit ces nouvelles compétences en nous intéressant à <strong>deux types de fichiers texte très fréquemment utilisés pour stocker et diffuser des données : les fichiers CSV et les fichiers JSON</strong>. Nous allons apprendre à manipuler ces deux types de fichiers grâce aux modules Python dédiés à leur traitement respectif : <strong>le module <code>csv</code> et le module <code>json</code></strong>.</p>
<section id="manipuler-des-fichiers-csv" class="level2">
<h2 class="anchored" data-anchor-id="manipuler-des-fichiers-csv">Manipuler des fichiers CSV</h2>
<section id="les-fichiers-csv" class="level3">
<h3 class="anchored" data-anchor-id="les-fichiers-csv">Les fichiers CSV</h3>
<p>CSV signifie <strong><em>comma-separated values</em></strong>, soit en bon français “valeurs séparées par des virgules”. Les fichiers CSV visent à reproduire la <strong>structure des données issues de tableurs</strong> type Excel de Microsoft ou Calc de LibreOffice, réduite à la stricte donnée textuelle (plus de formatage, plus de types de colonne, etc.).</p>
<p>Nous allons prendre pour exemple le fichier CSV qui contient la liste des départements en 2021, issue du Code Officiel Géographique (COG). Regardons les premières lignes de ce fichier à l’aide d’une commande <code>shell</code> pour avoir bien en tête la structure d’un tel fichier.</p>
<div id="62a0d205" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>head <span class="op">-</span>n <span class="dv">5</span> departement2021.csv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Pour reprendre l’analogie avec un fichier issu d’un tableur, chaque ligne du fichier représente une ligne du tableur, et les cellules d’une ligne sont séparées par des virgules. La première ligne peut contenir un <code>header</code> (en-tête), c’est à dire le nom des colonnes, mais ce n’est pas toujours le cas.</p>
<p>Les principaux avantages des fichiers CSV sont :</p>
<ul>
<li><p>leur <strong>simplicité</strong> : ils contiennent des données textuelles brutes, donc très légères et qui peuvent être éditées facilement via n’importe quel éditeur de texte ou langage de programmation</p></li>
<li><p>leur <strong>universalité</strong> : ils sont très largement utilisés comme un format standard d’échanges de données</p></li>
</ul>
</section>
<section id="le-module-csv" class="level3">
<h3 class="anchored" data-anchor-id="le-module-csv">Le module <code>csv</code></h3>
<p>Les données contenues dans un CSV étant des données textuelles, on peut se demander pourquoi l’on a besoin d’un module particulier pour les manipuler, et pourquoi les outils que l’on a vus dans le tutoriel précédent ne seraient pas suffisants. La raison principale est que les fichiers CSV ont tout de même quelques subtilités et normes, souvent invisibles à l’utilisateur, mais très importantes en pratique. Par exemple : si l’on veut séparer les différentes données selon les virgules, que se passe-t-il si les données textuelles elles-même contiennent des virgules ?</p>
<p>C’est pour cette raison qu’on utilise le <strong>module <code>csv</code></strong> pour interagir avec ce type de fichiers, afin de capitaliser sur le fait que d’autres se sont posés toutes ces questions, et donc de ne pas avoir à réinventer la roue à chaque import de fichier CSV.</p>
<p>Notons qu’en pratique, on a plutôt tendance à manipuler ce type de données sous la forme de DataFrames (comme en <code>R</code>), afin de tirer parti de leur <strong>structure tabulaire</strong>. On étudiera dans un prochain tutoriel le <strong><em>package</em> <code>Pandas</code></strong> qui permet précisément de faire cela en Python. Néanmoins, il est toujours utile de savoir bien manipuler les données d’un CSV comme des données textuelles, et donc de connaître le module <code>csv</code>.</p>
</section>
<section id="lecture" class="level3">
<h3 class="anchored" data-anchor-id="lecture">Lecture</h3>
<div id="5bbd5333" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> csv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La syntaxe permettant de lire et manipuler des fichiers CSV en Python est très proche de celle pour les fichiers texte simples. La seule différence est que l’on doit créer un objet <code>reader</code> à partir de l’objet fichier pour pouvoir itérer sur les lignes.</p>
<div id="b370946f" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>rows <span class="op">=</span> []</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"departement2021.csv"</span>) <span class="im">as</span> file_in:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    csv_reader <span class="op">=</span> csv.reader(file_in)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> row <span class="kw">in</span> csv_reader:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        rows.append(row)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>rows[:<span class="dv">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>On retrouve bien la même syntaxe que pour les fichiers texte simples : une fois le <code>reader</code> créé, on peut itérer sur les lignes et réaliser des opérations avec celles-ci ; par exemple, les stocker dans une liste comme ci-dessus.</p>
<p>Lorsqu’on a un fichier CSV avec des noms de colonne comme dans notre cas, il est intéressant de les utiliser pour manipuler la donnée nommée, plutôt que par position en utilisant une liste simple. On utilise pour cela un <code>DictReader</code> au lieu du <code>reader</code>. A présent, lorsqu’on itère sur l’objet <code>DictReader</code> créé, chaque ligne est un dictionnaire, donc la clé est le nom de la colonne et la valeur la donnée de la cellule.</p>
<p>Pour illustrer son intérêt, affichons les noms des départements donc le numéro de département est compris entre 20 et 29.</p>
<div id="2addcebd" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"departement2021.csv"</span>) <span class="im">as</span> file_in:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    dict_reader <span class="op">=</span> csv.DictReader(file_in)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> row <span class="kw">in</span> dict_reader:</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> row[<span class="st">"DEP"</span>].startswith(<span class="st">"2"</span>):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(row[<span class="st">"LIBELLE"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Le code est beaucoup plus lisible : on comprend facilement quelles données sont manipulées et de quelle manière.</p>
</section>
<section id="écriture" class="level3">
<h3 class="anchored" data-anchor-id="écriture">Écriture</h3>
<p>La syntaxe pour l’écriture est là encore assez proche de celle pour les fichiers texte. La différence est que l’on traite des données en 2D (ligne x colonne), on ne peut donc plus passer seulement une chaîne de caractère à l’écriture, il faut <strong>passer une liste d’éléments</strong>.</p>
<div id="1132ad72" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>header <span class="op">=</span> [<span class="st">"nom"</span>, <span class="st">"classe"</span>, <span class="st">"age"</span>]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>row1 <span class="op">=</span> [<span class="st">"Maurice"</span>, <span class="st">"5èmeB"</span>, <span class="dv">12</span>]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>row2 <span class="op">=</span> [<span class="st">"Manuela"</span>, <span class="st">"6èmeA"</span>, <span class="dv">11</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"test.csv"</span>, <span class="st">"w"</span>) <span class="im">as</span> file_out:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    csv_writer <span class="op">=</span> csv.writer(file_out)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    csv_writer.writerow(header)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    csv_writer.writerow(row1)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    csv_writer.writerow(row2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Vérifions que notre fichier CSV brut ressemble bien à ce que nous attendions.</p>
<div id="ef788edd" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Commande shell pour afficher le contenu d'un fichier</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>cat test.csv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="le-header" class="level3">
<h3 class="anchored" data-anchor-id="le-header">Le <em>header</em></h3>
<p>Comme dans un document de type tableur, la première ligne d’un fichier CSV contient généralement les <strong>noms des variables</strong> (colonnes). On appelle cette ligne le <strong><em>header</em></strong>. Cette ligne n’est pas obligatoire en théorie, mais elle est quand même bien pratique pour comprendre rapidement la nature des données qui se trouvent dans un fichier CSV. C’est donc une bonne pratique d’inclure un <em>header</em> lorsqu’on génère un fichier CSV.</p>
<p>Nous avons vu dans l’exemple précédent que l’écriture du <em>header</em> se faisait comme celle de n’importe quelle autre ligne de donnée. C’est lors de la lecture que les choses se compliquent, puisqu’il faut récupérer le <em>header</em> séparément des autres données si le fichier CSV en contient un. Utilisons le CSV généré à l’étape précédente pour illustrer cela.</p>
<div id="b083f394" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> []</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"test.csv"</span>, <span class="st">"r"</span>) <span class="im">as</span> file_in:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    csv_reader <span class="op">=</span> csv.reader(file_in)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    header <span class="op">=</span> <span class="bu">next</span>(csv_reader)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> row <span class="kw">in</span> csv_reader:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        data.append(row)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1c502c1e" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(header)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6c11d73a" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Pour récupérer le <em>header</em>, on utilise la fonction <code>next</code>. C’est une fonction <em>built-in</em> qui va appeler la méthode <code>__next__</code> de l’objet <code>reader</code>, qui permet d’itérer d’un pas sur le <code>reader</code>. Le premier appel à la fonction <code>next</code> renvoie donc la première ligne du document. Si un <em>header</em> est présent dans le fichier (ce dont il faut s’assurer), l’élément renvoyé est le <em>header</em>. On récupère ensuite classiquement le reste des données via une boucle sur l’objet <code>reader</code>, que l’on stocke dans une liste de listes (une liste par ligne).</p>
</section>
<section id="importance-du-délimiteur" class="level3">
<h3 class="anchored" data-anchor-id="importance-du-délimiteur">Importance du délimiteur</h3>
<p>Le <strong>délimiteur</strong> correspond au caractère qui est utilisé pour délimiter les valeurs successives d’une ligne dans un fichier CSV.</p>
<p>Le standard CSV utilise — comme son nom l’indique — la virgule comme délimiteur, mais cela est modifiable, et <strong>il n’est pas rare de tomber sur des fichiers CSV qui ont un autre délimiteur</strong>. Il faut dans ce cas aller regarder directement dans le texte brut quel est le délimiteur utilisé. On trouve par exemple souvent une délimitation par des <code>tabs</code> (le caractère est <code>\t</code>), i.e.&nbsp;un nombre d’espaces donné, auquel cas le fichier peut avoir pour extension <code>.tsv</code> pour <em>tab-separated value</em>. Il faut alors spécifier le délimiteur avec le paramètre <code>delimiter</code> lorsqu’on crée le <code>reader</code>.</p>
<p>En pratique, comme pour l’encodage d’un fichier texte, <strong>il y a peu de raison valable pour changer de délimiteur</strong>. Même si des virgules apparaissent dans des valeurs du fichier — par exemple, dans une adresse — ces valeurs sont alors entourées par des guillemets, ce qui permet à la séparation des valeurs de se faire correctement dans la grande majorité des cas.</p>
</section>
</section>
<section id="manipuler-des-fichiers-json" class="level2">
<h2 class="anchored" data-anchor-id="manipuler-des-fichiers-json">Manipuler des fichiers JSON</h2>
<section id="les-fichiers-json" class="level3">
<h3 class="anchored" data-anchor-id="les-fichiers-json">Les fichiers JSON</h3>
<p>Le JSON (<em>JavaScript Object Notation</em>) est un format de fichier très populaire pour écrire et échanger de la donnée sous la forme d’une chaîne de caractères unique et lisible par l’humain (<em>human-readable</em>) — du moins en théorie.</p>
<p>Comme son nom le suggère, le JSON est lié au langage <em>JavaScript</em> dans la mesure où il constitue un dérivé de la notation des objets dans ce langage. Le format est cependant désormais indépendant de tout langage de programmation, mais est très fréquemment utilisé dans différents langages.</p>
<p>Le format JSON est particulièrement important pour les statisticiens et data scientists car il constitue le <strong>format quasi-standard de réponse des <a href="https://fr.wikipedia.org/wiki/Interface_de_programmation">API</a></strong>. Le dialogue avec les API va au delà du programme de ce cours d’introduction. Cependant, les API tendant à se généraliser comme mode de communication standard pour l’échange de données, il est important de maîtriser les bases du format JSON afin de manipuler les réponses des API lorsqu’on doit interagir avec celles-ci.</p>
<p>Le JSON stockant les objets sous forme de <strong>paires clé-valeur</strong> et où les valeurs peuvent être des <strong><em>arrays</em></strong> — un concept assez large en informatique qui inclut notamment les listes que nous connaissons — il ressemble fortement aux dictionnaires Python. Il constitue ainsi un format de fichier assez naturel pour <strong><em>sérialiser</em></strong> ces derniers, c’est à dire passer d’une structure de données en mémoire (ici, un dictionnaire) à une séquence d’octets qui peut être universellement lue par tout ordinateur. Regardons à titre d’exemple la représentation JSON d’un dictionnaire Python.</p>
<div id="b31fec21" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>cv <span class="op">=</span> {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"marc"</span>: {<span class="st">"poste"</span>: <span class="st">"manager"</span>, <span class="st">"experience"</span>: <span class="dv">7</span>, <span class="st">"hobbies"</span>: [<span class="st">"couture"</span>, <span class="st">"frisbee"</span>]},</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"miranda"</span>: {<span class="st">"poste"</span>: <span class="st">"ingénieure"</span>, <span class="st">"experience"</span>: <span class="dv">5</span>, <span class="st">"hobbies"</span>: [<span class="st">"trekking"</span>]}</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cv)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b036b694" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(json.dumps(cv))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>On le voit : la représentation JSON est assez proche de celle du dictionnaire Python, avec <strong>quelques particularités</strong>. Dans ce cas par exemple, les caractères spéciaux comme les accents sont automatiquement encodés en <em>Unicode</em>.</p>
</section>
<section id="le-module-json" class="level3">
<h3 class="anchored" data-anchor-id="le-module-json">Le module <code>json</code></h3>
<p>Le module <code>json</code> gère l’import de fichiers JSON et l’export d’objets Python au format JSON. Il s’occupe notamment de gérer les contraintes de conversion en JSON évoquées précédemment, comme celle des accents.</p>
<p>En particulier, <strong>le JSON peut stocker la majorité des types d’objets <em>built-in</em> de Python</strong> que nous avons vus jusqu’à présent (<em>strings</em>, valeurs numériques, Booléens, listes, dictionnaires, <code>NoneType</code>) et bien d’autres, mais il ne peut pas représenter des objets Python créés manuellement via des classes par exemple.</p>
</section>
<section id="écriture-1" class="level3">
<h3 class="anchored" data-anchor-id="écriture-1">Écriture</h3>
<p>Commençons cette fois par l’écriture. Comme nous l’avons vu dans l’exemple précédent, la fonction <code>dumps</code> (pour <em>dump string</em>) convertit une valeur Python <strong>sérialisable</strong> en sa représentation JSON sous forme de chaîne de caractères.</p>
<div id="c5fac1b6" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="st">"test"</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>json.dumps(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="14475b1c" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>json.dumps(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ecrire un fichier JSON à partir de Python revient simplement à écrire cette représentation dans un fichier texte, auquel on donnera l’extension <code>.json</code> pour bien marquer qu’il s’agit d’un fichier texte particulier. Comme cette opération est très fréquente, il existe une fonction très proche, <code>dump</code>, qui effectue à la fois la conversion et l’écriture.</p>
<div id="cbfb5e4f" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"cv.json"</span>, <span class="st">"w"</span>) <span class="im">as</span> file_out:</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    json.dump(cv, file_out)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b5f8ddde" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>cat cv.json</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En une seule opération, on a sérialisé un dictionnaire Python (l’objet <code>cv</code>) dans un fichier JSON.</p>
</section>
<section id="lecture-1" class="level3">
<h3 class="anchored" data-anchor-id="lecture-1">Lecture</h3>
<p>Le module <code>json</code> propose les fonctions <code>load</code> et <code>loads</code>, qui réalisent respectivement les opérations opposées des fonctions <code>dump</code> et <code>dumps</code> :</p>
<ul>
<li><p>la fonction <code>load</code> permet d’importer du contenu JSON présent dans un fichier texte et de le convertir en un dictionnaire</p></li>
<li><p>la fonction <code>loads</code> permet de convertir du contenu JSON présent dans une chaîne de caractères en un dictionnaire</p></li>
</ul>
<p>Reprenons le CV que nous avons sérialisé précédemment au format JSON pour illustrer la lecture à partir d’un fichier.</p>
<div id="7b95b526" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"cv.json"</span>, <span class="st">"r"</span>) <span class="im">as</span> file_in:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> json.load(file_in)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Nous allons illustrer la lecture de contenu JSON à partir d’une chaîne de caractères à partir d’un exemple réaliste : celui du requêtage d’une API. Pour l’exemple, nous allons requêter la Base Adresse Nationale (BAN), qui permet de géolocaliser n’importe quelle adresse nationale.</p>
<p>Le requêtage d’API en Python se fait très simplement grâce à la librairie <code>requests</code>. Regardons par exemple comment l’on peut récupérer en seulement deux lignes de code les informations géographiques sur toutes les voies qui contiennent le nom “comédie” en France.</p>
<div id="e8faa7b8" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d3f7bcae" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>response <span class="op">=</span> requests.get(<span class="st">"https://api-adresse.data.gouv.fr/search/?q=comedie&amp;type=street"</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>r_text <span class="op">=</span> response.text</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(r_text[:<span class="dv">150</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>L’API nous renvoie une réponse, dont on extrait le contenu textuel. Comme pour la très grande majorité des API, ce contenu est du JSON. On peut alors l’importer dans un dictionnaire Python via la fonction <code>loads</code> (pour <em>load string</em>) pour pouvoir manipuler la donnée qu’il contient.</p>
<div id="88908388" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>r_dict <span class="op">=</span> json.loads(r_text)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f81ae672" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>r_dict.keys()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="de3efd6f" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(r_dict[<span class="st">"features"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Les résultats qui nous intéressent sont contenues dans la valeur du dictionnaire associée à la clé <code>features</code>, qui est une liste de dictionnaires, un par résultat.</p>
<div id="39e7e692" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>r_dict[<span class="st">"features"</span>][<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="4609301d" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>r_dict[<span class="st">"features"</span>][<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="exercices" class="level2">
<h2 class="anchored" data-anchor-id="exercices">Exercices</h2>
<section id="questions-de-compréhension" class="level3">
<h3 class="anchored" data-anchor-id="questions-de-compréhension">Questions de compréhension</h3>
<ul>
<li><p>1/ Qu’est ce qu’un fichier CSV ?</p></li>
<li><p>2/ Quel sont les avantages du format CSV ?</p></li>
<li><p>3/ Pourquoi utilise-t-on le module <code>csv</code> pour lire et écrire des fichiers CSV ?</p></li>
<li><p>4/ Les données d’un fichier CSV sont-elles forcément séparées par des virgules ?</p></li>
<li><p>5/ Qu’est-ce que le <em>header</em> d’un fichier CSV ? Existe-t-il nécessairement ?</p></li>
<li><p>6/ Pourquoi le format JSON est très utilisé dans la manipulation de données ?</p></li>
<li><p>7/ A quel objet Python ressemble du contenu au format JSON ?</p></li>
<li><p>8/ Quels types d’objets Python peuvent être convertis en JSON ?</p></li>
<li><p>9/ Qu’est ce que la sérialisation d’un objet Python ?</p></li>
<li><p>10/ Quel est le principal point commun entre les fichiers CSV et les fichiers JSON ?</p></li>
<li><p>11/ Un fichier dont l’extension est .json contient-il nécessairement du JSON ?</p></li>
</ul>
<div id="2750df69" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1a941a6a" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter cette cellule pour afficher la solution</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load <span class="op">-</span>r <span class="dv">3</span><span class="op">-</span><span class="dv">39</span> solutions.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="exercice-trier-les-clés-lors-de-lécriture-dun-json" class="level3">
<h3 class="anchored" data-anchor-id="exercice-trier-les-clés-lors-de-lécriture-dun-json">Exercice : trier les clés lors de l’écriture d’un JSON</h3>
<p>La cellule suivante contient un dictionnaire. Le but de l’exercice est d’écrire ces données dans un fichier JSON, en triant les clés du dictionnaire par ordre alphabétique.</p>
<p>Indice : la fonction <code>dump</code> du module <code>json</code> contient un paramètre permettant de trier les clés. Lisez la <a href="https://docs.python.org/fr/3/library/json.html#json.dump">documentation de la fonction</a> pour le déterminer.</p>
<div id="9408f986" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {<span class="st">"id"</span>: <span class="dv">1</span>, <span class="st">"nom"</span>: <span class="st">"Isidore"</span>, <span class="st">"age"</span>: <span class="dv">29</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="5bb2a06f" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d4e97adc" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter cette cellule pour afficher la solution</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load <span class="op">-</span>r <span class="dv">43</span><span class="op">-</span><span class="dv">48</span> solutions.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="exercice-convertir-un-objet-non-sérialisable-en-json" class="level3">
<h3 class="anchored" data-anchor-id="exercice-convertir-un-objet-non-sérialisable-en-json">Exercice : convertir un objet non-sérialisable en JSON</h3>
<p>Nous avons vu que les objets que l’on crée manuellement via des classes ne sont généralement pas sérialisables. La cellule suivante en montre un exemple avec notre objet <code>Citron</code> utilisé dans le tutoriel sur la POO. Essayer de convertir directement l’objet en JSON renvoie une erreur.</p>
<p>Vous devez modifier le code suivant afin de pouvoir sérialiser l’objet. Pour cela, vous devez :</p>
<ul>
<li><p>convertir l’instance <code>mon_citron</code> en utilisant la méthode <em>built-in</em> <code>__dict__</code> que possèdent tous les objets Python</p></li>
<li><p>convertir le dictionnaire obtenu en JSON sous forme de chaîne de caractères</p></li>
</ul>
<div id="986b2b49" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Citron:</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, couleur, qte_jus):</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.saveur <span class="op">=</span> <span class="st">"acide"</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.couleur <span class="op">=</span> couleur</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.jus <span class="op">=</span> qte_jus</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>mon_citron <span class="op">=</span> Citron(couleur<span class="op">=</span><span class="st">"jaune"</span>, qte_jus<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>json.dumps(mon_citron)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ce7796cf" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b42e8203" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter cette cellule pour afficher la solution</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load <span class="op">-</span>r <span class="dv">52</span><span class="op">-</span><span class="dv">64</span> solutions.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="exercice-changer-le-délimiteur-dun-fichier-csv" class="level3">
<h3 class="anchored" data-anchor-id="exercice-changer-le-délimiteur-dun-fichier-csv">Exercice : changer le délimiteur d’un fichier CSV</h3>
<p>Votre répertoire courant contient le fichier <code>nat2020.csv</code>. Il s’agit du fichier des prénoms diffusé par l’Insee : il contient des données sur les prénoms attribués aux enfants nés en France entre 1900 et 2020.</p>
<p>Problème : contrairement au standard CSV, le délimiteur utilisé n’est pas la virgule. Vous devez donc :</p>
<ul>
<li><p>trouver le séparateur utilisé (via l’éditeur de texte Jupyter, via une commande shell, en testant avec le module <code>csv</code> en Python..) pour lire correctement le fichier</p></li>
<li><p>générer un nouveau fichier CSV <code>nat2020_corr.csv</code> contenant les mêmes données, mais cette fois avec la virgule comme séparateur.</p></li>
</ul>
<div id="604ae82b" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="72e0ef34" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter cette cellule pour afficher la solution</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load <span class="op">-</span>r <span class="dv">68</span><span class="op">-</span><span class="dv">81</span> solutions.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="exercice-extraire-et-sauvegarder-des-données-issues-dune-api" class="level3">
<h3 class="anchored" data-anchor-id="exercice-extraire-et-sauvegarder-des-données-issues-dune-api">Exercice : extraire et sauvegarder des données issues d’une API</h3>
<p>L’exercice consiste à effectuer une requête à l’API de la Base Adresse Nationale, et sauvegarder les résultats dans un fichier CSV. Voici les étapes à implémenter :</p>
<ul>
<li><p>effectuer une requête de nom de rue avec un mot clé comme dans le tutoriel (si vous souhaitez faire une requête plus complexe, vous pouvez regarder la <a href="https://adresse.data.gouv.fr/api-doc/adresse">documentation de l’API</a>) et stocker les résultats dans un dictionnaire</p></li>
<li><p>créer un fichier CSV <code>resultats_ban.csv</code> dans lequel on va stocker les informations suivantes : ‘nom’, ‘ville’, ‘code_commune’, ‘longitude’, ‘latitude’</p></li>
<li><p>à l’aide d’un objet <code>writer</code> et d’une boucle sur les résultats renvoyés par l’API, écrivez chaque ligne dans le CSV</p></li>
</ul>
<p>Par exemple, pour la requête de voie contenant le mot “comedie”, voici le CSV à obtenir :</p>
<pre><code>nom,ville,code_commune,longitude,latitude
Rue de la Vieille Comedie,Lille,59350,3.063832,50.635192
Place de la Comédie,Montpellier,34172,3.879638,43.608525
Rue de la Comédie,Cherbourg-en-Cotentin,50129,-1.629732,49.641574
Allee de la Comedie,Villeneuve-d'Ascq,59009,3.162808,50.64628
Rue de l’Ancienne Comedie,Poitiers,86194,0.342649,46.580457</code></pre>
<div id="1f4bd8db" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="bd723721" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter cette cellule pour afficher la solution</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load <span class="op">-</span>r <span class="dv">85</span><span class="op">-</span><span class="dv">99</span> solutions.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="exercice-découper-la-base-des-départements-par-régions" class="level3">
<h3 class="anchored" data-anchor-id="exercice-découper-la-base-des-départements-par-régions">Exercice : découper la base des départements par régions</h3>
<p>L’objectif de cet exercice est de découper le fichier CSV des départements que nous avons utilisé dans le tutoriel en plusieurs petits CSV, un par région. Ce type d’opération peut être utile par exemple lorsqu’on travaille avec un fichier de très grande taille, qui ne passe pas en mémoire ; le découper en plusieurs fichiers que l’on traite indépendamment, lorsque cela est possible, permet de réduire la volumétrie.</p>
<p>Voici la liste des opérations à effectuer :</p>
<ul>
<li><p>créer un dossier <code>dep</code> dans le répertoire courant à l’aide du module <code>pathlib</code> (cf.&nbsp;tutoriel précédent)</p></li>
<li><p>avec un objet <code>reader</code> du module <code>csv</code>, faire une boucle sur les lignes du fichier CSV des départements. Attention à ne pas inclure le <em>header</em>, en utilisant la fonction <code>next</code> pour passer la première ligne. Pour chaque ligne suivante :</p>
<ul>
<li><p>récupérer le code région (variable <code>REG</code>)</p></li>
<li><p>générer le chemin du fichier CSV <code>dep/{REG}.csv</code> où {REG} est à remplacer par le code région de la ligne</p></li>
<li><p>ouvrir ce fichier CSV en mode <code>append</code> pour écrire la ligne à la fin du fichier</p></li>
</ul></li>
</ul>
<div id="5c885a66" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f55cb096" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter cette cellule pour afficher la solution</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load <span class="op">-</span>r <span class="dv">103</span><span class="op">-</span><span class="dv">117</span> solutions.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="exercice-rajouter-des-headers-manquants" class="level3">
<h3 class="anchored" data-anchor-id="exercice-rajouter-des-headers-manquants">Exercice : rajouter des <em>headers</em> manquants</h3>
<p>Dans l’exercice précédent, nous avons découpé le fichier CSV des départements français en plusieurs fichiers CSV, un par région. Mais nous n’avons pas inclus dans les différents fichiers le <em>header</em>, i.e.&nbsp;la première ligne qui contient les noms de colonnes. On va donc l’ajouter manuellement à chacun des fichiers CSV créés lors de l’exercice précédent.</p>
<p>Voici la liste des opérations à effectuer :</p>
<ul>
<li><p>lire le fichier des départements complet et récupérer le <code>header</code> dans une liste avec la fonction <code>next</code></p></li>
<li><p>enregistrer dans une liste les chemins des différents fichiers CSV contenus dans le dossier <code>dep</code> avec la méthode <code>glob</code> de <code>pathlib</code> (cf.&nbsp;tutoriel précédent)</p></li>
<li><p>pour chaque chemin :</p>
<ul>
<li><p>ouvrir le fichier CSV déjà existant, et récupérer les données sous forme d’une liste de listes (une liste par ligne)</p></li>
<li><p>ouvrir le fichier CSV en écriture pour le réinitialiser, écrire le header en premier lieu, puis écrire les données que l’on a au préalable sauvegardées dans une liste de liste</p></li>
</ul></li>
</ul>
<div id="755a61df" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testez votre réponse dans cette cellule</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f4fc8876" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter cette cellule pour afficher la solution</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>load <span class="op">-</span>r <span class="dv">121</span><span class="op">-</span><span class="dv">141</span> solutions.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>