::: {.content-visible when-profile="fr"}
# Types de base et variables

Dans ce premier TP, nous allons découvrir les objets les plus fondamentaux de Python : les **nombres** et les **chaînes de caractère**. Nous allons également voir comment l'on peut assigner des objets à des **variables**, afin de réaliser des opérations avec ces objets.

## Nombres

### Types de nombres

Python propose différents objets de type numérique. Dans ce tutoriel, on va s'intéresser aux deux types principalement utilisés :

- les entiers (type `int` pour *integer*)

- les réels (type `float` pour nombres à virgule flottante)

De manière générale, on utilise la fonction `type` pour imprimer le type d'un objet Python.


```{python}
type(3)
```


```{python}
type(3.14)
```

Les fonctions `float` et `int` peuvent être utilisées pour passer d'un type à l'autre.


```{python}
# Conversion en float
float(3)
```


```{python}
# Conversion en float
type(float(3))
```


```{python}
# Conversion en int
int(3.79)
```

Attention à la conversion *float* -> *int*, qui tronque la partie décimale.

Les *floats* peuvent par ailleurs être écrits en notation scientifique :


```{python}
2e3
```


```{python}
type(2e3)
```

### Opérations arithmétiques de base


```{python}
# Addition
8 + 9
```


```{python}
# Soustraction
5 - 2
```


```{python}
# Multiplication
2 * 6
```


```{python}
# Division
9 / 4
```


```{python}
# Division par 0
3 / 0
```

La division par 0 produit une erreur. C'était bien sûr prévisible. Mais il n'est pas rare d'avoir de telles erreurs dans le cadre de calculs statistiques, notamment avec *NumPy* ou *Pandas*, produisant une erreur similaire qu'il faut alors débugger.

::: {.callout-tip title="Debugger une erreur"}
Les erreurs de code sont un passage obligatoire et en réalité nécessaire de l'apprentissage d'un langage : c'est en debuggant les erreurs que notre code produit que l'on apprend à les éviter à l'avenir ! Pour ce faire, il est nécessaire de bien les comprendre en premier lieu.

L'erreur ci-dessus, liée à la division par 0, a produit un `Traceback`, i.e. un log détaillé précisant à quelle étape des différentes opérations effectuées par Python s'est produite l'erreur, ainsi que le nom de l'erreur (`ZeroDivisionError`) et un descriptif ("division by zero"). En l'occurence, l'erreur est simple, le message permet donc de comprendre directement le problème. Pour des opérations plus compliquées, les noms et messages peuvent être moins évidents... mais néanmoins utiles pour comprendre la source de l'erreur - en les indiquant dans un moteur de recherche par exemple.
:::

```{python}
# Division euclidienne : quotient
9 // 4
```


```{python}
# Division euclidienne : reste
9 % 4
```


```{python}
# Puissance
2 ** 5
```


```{python}
# Racine carrée
5 ** 0.5
```


```{python}
# Ordre des opérations : convention usuelle
2 + 5 * (10 - 4)
```

## Chaînes de charactères

Les chaînes de caractères (ou *strings*) sont utilisées pour stocker de l'information textuelle. Plus précisément, elles peuvent stocker tout caractère de type [Unicode](https://fr.wikipedia.org/wiki/Unicode), ce qui inclut les lettres des différentes langues, mais également la ponctuation, les chiffres, les smileys, etc.

Un *string* se définit en mettant l'information entre apostrophes ou entre guillemets (anglais). 

### Définition


```{python}
# Première manière 
'mot'
```


```{python}
# Deuxième manière
"ça fonctionne aussi"
```


```{python}
# Mais attention au mélange des deux !
'l'apostrophe, quelle catastrophe'
```

Erreur de syntaxe : la seconde apostrophe est comprise comme la fin du *string*, et Python ne sait pas interpréter le reste de la séquence.

::: {.callout-note title="Erreurs de syntaxe et exception"}
Depuis le début du TP, on a vu plusieurs erreurs produites par le code. En pratique, il est important de distinguer deux types d'erreurs :

- les **erreurs de syntaxe**: le code ne respecte pas les règles de syntaxe de Python, comme l'erreur ci-dessus. Le `Traceback` (message d'erreur) indique avec des flèches pointant vers le haut la ligne et le moment où à commencé le problème

- les **exceptions**: le code est syntaxiquement correct mais produit une erreur lors de son exécution, comme la division par zéro effectuée plus haut. 

Pourquoi alors est-il important de distinguer ces deux types d'erreur ? Car là où une syntaxe incorrecte génère nécessairement une `SyntaxError` et arrête l'exécution du code, une exception peut être gérée dans le code. Par exemple, dans le cadre d'un code où l'on réaliserait de multiples divisions avec des paramètres multiples, on pourrait vouloir faire en sorte qu'une division par zéro ne renvoie pas une erreur qui interrompe l'exécution du code, mais une valeur arbitraire (infini, valeur manquante...).
:::

Pour éviter l'erreur de syntaxe, il faut varier les caractères en cas de besoin :


```{python}
"l'apostrophe, aucun problème"
```

Même chose en sens inverse :

```{python}
'les guillemets, "aucun problème"'
```

### La fonction `print`

Le travail avec les *strings* est l'occasion de découvrir la très pratique et très utilisée fonction `print`. Elle affiche simplement l'argument qu'on lui passe entre parenthèses **et** un retour à la ligne par défaut.

```{python}
# Affichage de la chaîne "moi"
"moi"
```

```{python}
# Affichage de la chaîne "moi" avec print
print("moi")
```

On a vu jusqu'à maintenant que l'on pouvait simplement exécuter une cellule pour afficher le contenu d'un *string*. Mais est-ce cela marche avec plusieurs *strings* ?


```{python}
# Qui va être affiché ?
"moi"
"non moi"
```

On voit là un comportement caractéristique des notebooks Jupyter : seule la dernière valeur renvoyée dans une cellule est affichée. La fonction `print` permet de s'affranchir de cette limite.


```{python}
# Et cette fois ?
print("moi")
print("moi aussi")
```

### Longueur d'une chaîne

La fonction `len` permet de compter le nombre de caractères d'un *string*, tous caractères inclus (lettres, chiffres, espaces, ponctuation...).


```{python}
len("J'ai 19 charactères")
```

Le type "caractère" n'existe pas en Python : un caractère seul est défini comme un *string* de taille 1.


```{python}
print(type("a"))
print(len("a"))
```

### Indexation

En Python, un *string* est une **séquence**, c'est à dire une suite de caractères dans un ordre spécifique. Par conséquent, chaque caractère d'un *string* est indexé (Python connaît sa position), et l'on peut utiliser cet index pour extraire des caractères particuliers, des sous-chaînes de caractères, etc.

En Python, on utilise les crochets `[]` pour appeler l'index d'une séquence. Plus précisément, l'index fonctionne sur le modèle suivant : `x[a:b:c]` renvoie un *sub-string* du *string* `x` où `a` est la position du caractère de départ, `b` la position du caractère d'arrivée plus 1, et `c` le pas de l'indexation. Tout cela sera plus clair avec les exemples suivants.

Note importante : **l'indexation commence à 0 en Python**.


```{python}
"une séquence que l'on va indexer"
```


```{python}
# Premier élémént
"une séquence que l'on va indexer"[0]
```


```{python}
# Deuxième élémént
"une séquence que l'on va indexer"[1]
```


```{python}
# Dernier élémént
"une séquence que l'on va indexer"[-1]
```


```{python}
# Extraire tout à partir d'un certain caractère
"une séquence que l'on va indexer"[4:]
```


```{python}
# Extraire tout jusqu'à un certain caractère
"une séquence que l'on va indexer"[:12]
```


```{python}
# Extraire un sub-string
"une séquence que l'on va indexer"[4:12]
```


```{python}
# Extraire tous les 2 caractères, à partir de la 4 ème position
"une séquence que l'on va indexer"[4::2]
```


```{python}
# Inverser une séquence
"une séquence que l'on va indexer"[::-1]
```

A retenir : c'est bien parce qu'un *string* est considéré comme une séquence par Python que l'on peut l'indexer. Par exemple, indexer un nombre n'a pas de sens, et renvoie donc une erreur.


```{python}
2[3]
```

### Quelques propriétés utiles


```{python}
# Concaténation de strings
"mon adresse est : " + "10 rue des Peupliers"
```


```{python}
# Répétition
"echo - " * 5
```

### Quelques méthodes utiles

Les différents objets Python ont généralement des **méthodes** dites *built-in* (standard), qui permettent d'effectuer des opérations de base à partir de l'objet. 

Nous verrons dans un prochain chapitre en quoi consistent précisément les méthodes en Python. Pour le moment, on peut retenir que les méthodes s'utilisent selon le format `objet.methode(parametres)` où les paramètres sont optionnels.


```{python}
# Mettre en majuscules
"sequence 850".upper()
```


```{python}
# Mettre en minuscules
"sequence 850".lower()
```


```{python}
# Séparer les mots selon les espaces
"une séquence    à séparer".split()
```


```{python}
# Séparer les mots selon un caractère arbitraire
"pratique pour faire des sous-séquences".split("-")
```


```{python}
# Utiliser les strings comme templates
"mon adresse est : {}".format("10 rue des Peupliers")
```

### Pour aller plus loin avec les *strings*

Tout ceci n'est qu'un aperçu des innombrables opérations possibles sur les *strings*. La [documentation officielle](https://docs.python.org/3/library/stdtypes.html#string-methods) liste l'ensemble des méthodes *built-in* disponibles. Les exercices du chapitre et les mini-projets de fin de partie seront l'occasion de découvrir d'autres utilisations.

## Variables

Jusqu'ici, nous avons dû définir à chaque fois notre objet avant de pouvoir lui appliquer une transformation. Comment faire si l'on veut réutiliser un objet et lui appliquer plusieurs transformations ? Ou faire des opérations à partir de différents objets ?

Pour cela, on va assigner les objets à des variables.

### Assignation et opérations

L'assignation se fait suivant le format : `nom_de_la_variable = objet`. Cela permet ensuite de réaliser des opérations à partir de ces variables.


```{python}
x = 5
x
```


```{python}
type(x)
```


```{python}
x + 5
```


```{python}
y = x + 2*x
y
```

Contrairement à d'autres langages de programmation, Python est dit *dynamiquement* typé : il est possible de réassigner une variable à un objet de type différent. Cela facilite la lecture et le développement, mais peut parfois générer des problèmes difficiles à débugger... Il faut donc toujours bien faire attention que le type de la variable est bien celui que l'on s'imagine manipuler.


```{python}
x = 3
x = "blabla"
type(x)
```

Il y a naturellement certaines contraintes sur les opérations selon les types des objets.


```{python}
x = "test"
y = 3
x + y
```

Il est par contre possible d'harmoniser les types en amont :

```{python}
x = "test"
y = 3
z = str(y)
x + z
```

### Incrémentation

Il est fréquent d'utiliser une variable comme un compteur, en l'incrémentant à chaque fois qu'un évènement donné apparaît par exemple.


```{python}
a = 0
print(a)
a = a +1
print(a)
```

Cette pratique est tellement fréquente qu'il existe des opérateurs spéciaux pour les opérations arithmétiques courantes.


```{python}
a = 0
a += 1
a
```


```{python}
b = 5
b *= 3
b
```

## Exercices

### Questions de compréhension

- Quels sont les différents types de base de Python vus dans ce tutoriel ?

- Comment convertir un entier en réel et inversement ?

- Comment définit-on une chaîne de caractères en Python ?

- Qu'est ce qu'un *Traceback* ?

- Quelle est la différence entre une erreur de syntaxe et une exception ?

- A quoi sert la fonction `print` ?

- Comment afficher plusieurs valeurs dans une cellule de notebook Jupyter ?

- A quoi sert la fonction `len` ?

- Qu'est-ce qu'une méthode *built-in* et comment la reconnaître ?

- A quoi servent les variables ?

- Pourquoi dit-on que Python est "*dynamiquement* typé" ?

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

- 1/ Les types de base en Python vus dans ce tutoriel sont les types numériques, notamment les entiers (`int`) et les réels (nombres à virgule flottante, `float`), et les chaînes de caractères (`str`), qui stockent de l'information textuelle.

- 2/ Pour convertir un entier en réel, on utilise la fonction `float()`. Pour convertir un réel en entier, on utilise la fonction `int()`.

- 3/ Une chaîne de caractères est définie en mettant l'information entre apostrophes (') ou entre guillemets (").

- 4/ Un `Traceback` est un rapport d'erreur qui montre la séquence d'opérations qui ont conduit à une exception. Il aide à identifier l'origine de l'erreur dans le code.

- 5/ Une erreur de syntaxe survient lorsque le code Python ne respecte pas les règles de syntaxe du langage, rendant le script non exécutable. Une exception est une erreur détectée pendant l'exécution, même si le code a une syntaxe correcte. Les exceptions peuvent être gérées dans le code, alors que les erreurs de syntaxe produisent conduisent nécessairement à l'arrêt de l'exécution du code.

- 6/ La fonction `print` affiche le contenu de l'argument qu'on lui passe entre parenthèses sur la console Python ou dans une cellule de notebook Jupyter.

- 7/ Par défaut, l'exécution d'une cellule Jupyter affiche la dernière valeur renvoyée par le code exécuté dans cette cellule. Si deux lignes de code renvoient quelque chose, seul le dernier sera donc affiché. Pour pouvoir afficher plusieurs éléments dans une même cellule, on utilise la fonction `print` pour chaque opération dont on souhaite afficher le résultat.

- 8/ La fonction `len` renvoie le nombre d'éléments d'un objet. Par exemple, le nombre de caractères dans une chaîne de caractères. Cette fonction n'a de sens que pour les objets de type séquence.

- 9/ Une méthode *built-in* est une fonction intégrée à un type d'objet en Python qui permet d'effectuer des opérations spécifiques sur cet objet. On la reconnaît car elle est appelée directement sur l'objet avec la syntaxe `objet.methode()`.

- 10/ Les variables servent à stocker des valeurs ou des objets pour pouvoir les réutiliser et les manipuler plus facilement dans le code. Elles permettent égalemetn de donner un nom aux données pour les rendre plus lisibles et faciliter leur manipulation.

- 11/ Python est dit *dynamiquement typé* parce que le type des variables est déterminé au moment de l'exécution et peut changer au cours de l'exécution. Ainsi, une variable initialement définie comme chaîne de caractère peut tout à fait devenir une variable numérique au cours de l'exécution du code, ce qui est impossible dans les langages de programmation basés sur un *typage statique*.

</details>

:::

### Affichage de types de base

Afficher le type de x lorsque : 


- x = 3


- x = "test"


- x = 3.5

```{python}
# Tapez votre réponse dans cette cellule

```

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

```python
x = 3
print(type(x))

x = "test"
print(type(x))

x = 3.5
print(type(x))
```
</details>

:::

### Longueurs de chaînes



Calculer la somme des longueurs des trois chaînes de caractères suivantes : 

- "une première chaîne"

- "et une deuxième"

- "jamais deux sans trois"

```{python}
# Tapez votre réponse dans cette cellule

```

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

```python
a = "une première chaîne"
b = "et une deuxième"
c = "jamais deux sans trois"

len(a) + len(b) + len(c)
```
</details>

:::

### Formattage des codes postaux

Quel est le type adapté pour définir un code postal ?

Essayer de définir les codes postaux suivants au format `int` et au format `string` :

- 92120

- 02350

Que concluez-vous ?

```{python}
# Tapez votre réponse dans cette cellule

```

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

```python
cp1_int = 92120
cp1_str = "92120"

print(cp1_int, cp1_str) # Pas de problème

cp2_int = 02350 
```

Erreur : Python n'accepte pas de définir un entier qui commence par un 0. Il faut donc définir les codes postaux comme des strings.

</details>

:::

### Comptage de lettres

Compter le nombre de fois où la lettre e est présente dans la chaîne suivante :
"Je fais un comptage des e."

**Indice** : on peut utiliser la méthode *built-in* [count](https://docs.python.org/fr/3/library/stdtypes.html#str.count).

```{python}
# Tapez votre réponse dans cette cellule

```

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

```python
a = "Je fais un comptage des e."
a.count('e')
```
</details>

:::

### Détection de lettres

Repérer la première position où la lettre e est présente dans la chaîne suivante : "Je fais un comptage des e."

**Indice** : on peut utiliser la méthode *built-in* [find](https://docs.python.org/fr/3/library/stdtypes.html#str.find).

```{python}
# Tapez votre réponse dans cette cellule

```

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

```python
a = "Je fais un comptage des e."
a.find('e')
```
</details>

:::

### Suppression d'espaces dans une chaîne

Supprimer les espaces superflus au début et à la fin de la chaîne suivante :

**Indice** : on peut utiliser la méthode *built-in* [strip](https://docs.python.org/fr/3/library/stdtypes.html#str.strip).

```{python}
# Tapez votre réponse dans cette cellule
a = "    Un string très mal formatté.         "
```

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

```python
a = "    Un string très mal formatté.         "
a.strip()
```
</details>

:::

### Echappement de caractères

Le caractère `\` permet d'échapper (neutraliser) un caractère spécial au sein d'une chaîne de caractères. Trouvez comment ce caractère permet de résoudre le problème lié à l'utilisation de guillemets (ou d'apostrophes) dans une chaîne définie par des guillemets (apostrophe).

**Indice** : des exemples d'utilisation sont disponibles dans la [documentation officielle](https://docs.python.org/fr/3.8/reference/lexical_analysis.html#literals).

```{python}
# Tapez votre réponse dans cette cellule

```

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

```python
"juste un \"petit\" test"
```
</details>

:::

### Un premier algorithme

Réaliser la suite d'opérations suivantes à l'aide des opérateurs d'incrémentation, et imprimer la valeur finale :

- initialiser une variable à 1

- lui soustraire 5

- la multiplier par 4

- lui ajouter 22

```{python}
# Tapez votre réponse dans cette cellule

```

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

```python
a = 1
a -= 5
a *= 4
a += 22
print(a)
```
</details>

:::

### Composition de chaînes de caractères

Considérons les deux séquences suivantes :

- "nous sommes en"

- "2024"

Trouvez à partir du tutoriel deux manières différentes de les utiliser pour composer la séquence "nous sommes en 2024".

**Indice** : l'une des deux méthodes implique de modifier (légèrement) une des deux séquences.

```{python}
# Tapez votre réponse dans cette cellule

```

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

```python
a1 = "nous sommes en"
a2 = "nous sommes en {}"
b = "2024"

print(a1 + " " + b)
print(a2.format(b))
```
</details>

:::

### Les `f-strings`

Les `f-strings` sont une forme de *strings* un peu particulière mais très pratique, qui ont été ajoutés dans la version 3.6 de `Python`. Pour comprendre leur intérêt, repartons de la solution de l'exercice précédent, qui illustrait deux manières de composer la chaîne "nous sommes en 2024".

```{python}
a1 = "nous sommes en"
a2 = "nous sommes en {}"
b = "2024"

print(a1 + " " + b)
print(a2.format(b))
```

Ces deux méthodes fonctionnent mais présentent des limites. Réfléchissez à ce qui se passerait dans les cas suivants, et n'hésitez pas à faire des tests pour vous en convaincre :

- si l'on souhaite injecter via la méthode `format()` une variable qui n'est pas un *string* (ex : si "2024" était un entier et non un *string*) ?

- si l'on souhaite concaténer plusieurs *strings* ensemble ?

- si l'on souhaite concaténer plusieurs *strings* ensemble et qu'en plus on souhaite injecter les valeurs d'autres variables dans chaque partie ?

En vous inspirant de la [documentation officielle](https://docs.python.org/fr/3/tutorial/inputoutput.html#formatted-string-literals), utilisez les `f-strings` pour résoudre ces différents problèmes.

```{python}
# Tapez votre réponse dans cette cellule

```

::: {.cell .markdown}

<details>
<summary>Afficher la solution</summary>

Premier problème : composition de strings avec des valeurs numériques.

```python
a1 = "nous sommes en"
b = 2024

# print(a1 + " " + b)  # Erreur
print(a1 + " " + str(b))
```
La concaténation directe renvoie une erreur -> il faut au préalable convertir la valeur numérique en string.

Deuxième problème : juxtaposition de multiples chaînes de caractères.

```python
a = "nous sommes en"
b = "2024"
c = "et je m'appelle"
d = "Miranda"

print(a + " " + b + " " + c + " " + d)
```

La syntaxe devient vite illisible, car il faut ajouter les séparateurs (espace) manuellement entre chaque partie.

Troisième problème : composition de chaînes de caractères avec injection de variables.

```python
a = "nous sommes en {}"
b = "2024"
c = "et je m'appelle {}"
d = "Miranda"

print(a.format(b) + " " + c.format(d))
```

La syntaxe reste peu lisibile, car il faut injecter les valeurs dans chaque chaîne.

Solution : avec les f-strings.

```python
annee = 2024
prenom = "Miranda"

print(f"nous sommes en {annee} et je m'appelle {prenom}")
```

Beaucoup plus lisible !
</details>

:::

:::










::: {.content-visible when-profile="en"}

# Basic types and variables

In this first practical session, we will discover the most fundamental objects in Python: **numbers** and **strings**. We will also see how we can assign objects to **variables** to perform operations with these objects.

## Numbers

### Types of numbers

Python offers different types of numerical objects. In this tutorial, we will focus on the two most commonly used types:

- integers (type `int` for integer)
- floating-point numbers (type `float` for decimal numbers)

In general, we use the `type` function to print the type of a Python object.

```{python}
type(3)
```

```{python}
type(3.14)
```

The `float` and `int` functions can be used to convert from one type to another.

```{python}
# Convert to float
float(3)
```

```{python}
# Convert to float
type(float(3))
```

```{python}
# Convert to int
int(3.79)
```

Be cautious with float to int conversion, which truncates the decimal part.

Floats can also be written in scientific notation :

```{python}
2e3
```

```{python}
type(2e3)
```

### Basic arithmetic operations

```{python}
# Addition
8 + 9
```

```{python}
# Subtraction
5 - 2
```

```{python}
# Multiplication
2 * 6
```

```{python}
# Division
9 / 4
```

```{python}
# Division by 0
3 / 0
```

Division by 0 produces an error. This was, of course, predictable. But it is not uncommon to have such errors in statistical calculations, especially with *NumPy* or *Pandas*, producing a similar error that needs to be debugged.

::: {.callout-tip title="Debugging an error"}
Code errors are a necessary and actually essential part of learning a language: debugging the errors our code produces helps us learn to avoid them in the future! To do this, it is necessary to understand them well in the first place.

The error above, related to division by 0, produced a `Traceback`, i.e., a detailed log indicating at which step of the various operations performed by Python the error occurred, as well as the name of the error (`ZeroDivisionError`) and a description ("division by zero"). In this case, the error is simple, so the message allows us to understand the problem directly. For more complicated operations, the names and messages may be less obvious... but still useful to understand the source of the error - by indicating them in a search engine, for example.
:::

```{python}
# Euclidean division: quotient
9 // 4
```

```{python}
# Euclidean division: remainder
9 % 4
```

```{python}
# Power
2 ** 5
```

```{python}
# Square root
5 ** 0.5
```

```{python}
# Order of operations: usual convention
2 + 5 * (10 - 4)
```

## Strings

Strings are used to store textual information. More precisely, they can store any character of type [Unicode](https://en.wikipedia.org/wiki/Unicode), which includes letters from different languages, punctuation, numbers, emojis, etc.

A *string* is defined by enclosing the information in single or double quotes.

### Definition

```{python}
# First way
'word'
```

```{python}
# Second way
"this also works"
```

```{python}
# But be careful with mixing the two!
'it's a disaster'
```

Syntax error: the second apostrophe is understood as the end of the string, and Python cannot interpret the rest of the sequence.

::: {.callout-note title="Syntax errors and exceptions"}
Since the beginning of the session, we have seen several errors produced by the code. In practice, it is important to distinguish between two types of errors:

- **syntax errors**: the code does not comply with Python's syntax rules, such as the error above. The `Traceback` (error message) indicates with arrows pointing upwards the line and the moment where the problem started.
- **exceptions**: the code is syntactically correct but produces an error during its execution, such as the division by zero performed earlier.

Why is it important to distinguish between these two types of errors? Because while incorrect syntax necessarily generates a `SyntaxError` and stops code execution, an exception can be handled in the code. For example, in a code where multiple divisions are performed with various parameters, one might want to ensure that a division by zero does not return an error that interrupts code execution but an arbitrary value (infinity, missing value...).
:::

To avoid the syntax error, vary the characters when needed:

```{python}
"it's fine"
```

Same in the reverse:

```{python}
'no problem with "quotes"'
```

### The `print` function

Working with strings is an opportunity to discover the very practical and widely used `print` function. It simply displays the argument passed to it within parentheses **and** a newline by default.

```{python}
# Display the string "me"
"me"
```

```{python}
# Display the string "me" with print
print("me")
```

So far, we have seen that we can simply execute a cell to display the contents of a string. But does it work with multiple strings?

```{python}
# Who will be displayed?
"me"
"not me"
```

Here we see a characteristic behavior of Jupyter notebooks: only the last value returned in a cell is displayed. The `print` function allows us to overcome this limitation.

```{python}
# And this time?
print("me")
print("me too")
```

### Length of a string

The `len` function counts the number of characters in a string, all characters included (letters, numbers, spaces, punctuation...).

```{python}
len("I have 19 characters")
```

The "character" type does not exist in Python: a single character is defined as a string of length 1.

```{python}
print(type("a"))
print(len("a"))
```

### Indexing

In Python, a string is a **sequence**, meaning a series of characters in a specific order. Therefore, each character in a string is indexed (Python knows its position), and we can use this index to extract specific characters, substrings, etc.

In Python, we use brackets `[]` to call the index of a sequence. More precisely, the index works as follows: `x[a:b:c]` returns a substring of the string `x` where `a` is the starting character's position, `b` is the position of the ending character plus 1, and `c` is the indexing step. This will be clearer with the following examples.

Important note: **indexing starts at 0 in Python**.

```{python}
"a sequence that we will index"
```

```{python}
# First element
"a sequence that we will index"[0]
```

```{python}
# Second element
"a sequence that we will index"[1]
```

```{python}
# Last element
"a sequence that we will index"[-1]
```

```{python}
# Extract everything from a certain character
"a sequence that we will index"[4:]
```

```{python}
# Extract everything up to a certain character
"a sequence that we will index"[:12]
```

```{python}
# Extract a substring
"a sequence that we will index"[4:12]
```

```{python}
# Extract every 2 characters, starting from the 4th position
"a sequence that we will index"[4::2]
```

```{python}
# Reverse a sequence
"a sequence that we will index"[::-1]
```

To remember: it is because a string is considered a sequence by Python that we can index it. For example, indexing a number does not make sense and therefore returns an error.

```{python}
2[3]
```

### Some useful properties

```{python}
# String concatenation
"my address is: " + "10 Maple Street"
```

```{python}
# Repetition
"echo - " * 5
```

### Some useful methods

Different Python objects generally have **built-in methods** that allow performing basic operations on the object.

We will see in a future chapter what methods in Python precisely consist of. For now, you can remember that methods are used in the format `object.method(parameters)` where the parameters are optional.

```{python}
# Convert to uppercase
"sequence 850".upper()
```

```{python}
# Convert to lowercase
"sequence 850".lower()
```

```{python}
# Split words by spaces
"a sequence    to split".split()
```

```{python}
# Split words by an arbitrary character
"useful for making sub-sequences".split("-")
```

```{python}
# Use strings as templates
"my address is: {}".format("10 Maple Street")
```

### Going further with strings

This is just a glimpse of the countless operations possible on strings. The [official documentation](https://docs.python.org/3/library/stdtypes.html#string-methods) lists all the available built-in methods. The chapter exercises and the mini-projects at the end of the section will be an opportunity to discover other uses.

## Variables

So far, we have had to define our object each time before we could apply a transformation to it. What if we want to reuse an object and apply multiple transformations to it? Or perform operations with different objects?

To do this, we will assign objects to variables.

### Assignment and operations

Assignment is done in the format: `variable_name = object`. This allows us to perform operations with these variables.

```{python}
x = 5
x


```

```{python}
type(x)
```

```{python}
x + 5
```

```{python}
y = x + 2*x
y
```

Unlike other programming languages, Python is said to be *dynamically* typed: it is possible to reassign a variable to an object of a different type. This makes reading and developing easier, but it can sometimes create problems that are difficult to debug... Therefore, always make sure that the type of the variable is the one you think you are handling.

```{python}
x = 3
x = "blabla"
type(x)
```

Naturally, there are certain constraints on operations depending on the types of objects.

```{python}
x = "test"
y = 3
x + y
```

However, it is possible to harmonize the types beforehand:

```{python}
x = "test"
y = 3
z = str(y)
x + z
```

### Incrementation

It is common to use a variable as a counter, incrementing it each time a given event occurs, for example.

```{python}
a = 0
print(a)
a = a +1
print(a)
```

This practice is so common that there are special operators for common arithmetic operations.

```{python}
a = 0
a += 1
a
```

```{python}
b = 5
b *= 3
b
```

## Exercises

### Comprehension questions

- What are the different basic types of Python seen in this tutorial?
- How to convert an integer to a float and vice versa?
- How do you define a string in Python?
- What is a *Traceback*?
- What is the difference between a syntax error and an exception?
- What is the purpose of the `print` function?
- How to display multiple values in a Jupyter notebook cell?
- What is the purpose of the `len` function?
- What is a built-in method and how to recognize it?
- What are variables for?
- Why is Python said to be "*dynamically* typed"?

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

- 1/ The basic types in Python seen in this tutorial are numerical types, including integers (`int`) and floats (decimal numbers, `float`), and strings (`str`), which store textual information.

- 2/ To convert an integer to a float, we use the `float()` function. To convert a float to an integer, we use the `int()` function.

- 3/ A string is defined by enclosing the information in single (') or double (") quotes.

- 4/ A `Traceback` is an error report that shows the sequence of operations that led to an exception. It helps identify the origin of the error in the code.

- 5/ A syntax error occurs when Python code does not comply with the language's syntax rules, making the script unexecutable. An exception is an error detected during execution, even if the code has correct syntax. Exceptions can be handled in the code, whereas syntax errors necessarily lead to code execution stopping.

- 6/ The `print` function displays the content of the argument passed to it within parentheses on the Python console or in a Jupyter notebook cell.

- 7/ By default, executing a Jupyter cell displays the last value returned by the code executed in that cell. If two lines of code return something, only the last one will be displayed. To display multiple elements in the same cell, we use the `print` function for each operation whose result we want to display.

- 8/ The `len` function returns the number of elements in an object. For example, the number of characters in a string. This function only makes sense for sequence-type objects.

- 9/ A built-in method is a function integrated into a Python object type that allows performing specific operations on that object. It is recognized because it is called directly on the object with the syntax `object.method()`.

- 10/ Variables are used to store values or objects to reuse and manipulate them more easily in the code. They also give a name to the data to make it more readable and easier to manipulate.

- 11/ Python is said to be *dynamically typed* because the type of variables is determined at runtime and can change during execution. Thus, a variable initially defined as a string can become a numeric variable during code execution, which is impossible in programming languages based on *static typing*.

</details>

:::

### Displaying basic types

Display the type of x when:

- x = 3
- x = "test"
- x = 3.5

```{python}
# Type your answer in this cell
```

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

```{python}
x = 3
print(type(x))

x = "test"
print(type(x))

x = 3.5
print(type(x))
```
</details>

:::

### String lengths

Calculate the sum of the lengths of the following three strings:

- "a first string"
- "and a second"
- "never two without three"

```{python}
# Type your answer in this cell
```

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

```{python}
a = "a first string"
b = "and a second"
c = "never two without three"

len(a) + len(b) + len(c)
```
</details>

:::

### Formatting postal codes

What is the appropriate type to define a postal code?

Try defining the following postal codes in both `int` and `string` format:

- 92120
- 02350

What do you conclude?

```{python}
# Type your answer in this cell
```

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

```{python}
cp1_int = 92120
cp1_str = "92120"

print(cp1_int, cp1_str) # No problem

cp2_int = 02350 
```

Error: Python does not accept defining an integer that starts with a 0. Postal codes must therefore be defined as strings.

</details>

:::

### Counting letters

Count the number of times the letter e appears in the following string:
"I am counting the e's."

**Hint**: you can use the built-in method [count](https://docs.python.org/3/library/stdtypes.html#str.count).

```{python}
# Type your answer in this cell
```

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

```{python}
a = "I am counting the e's."
a.count('e')
```
</details>

:::

### Detecting letters

Find the first position where the letter e appears in the following string: "I am counting the e's."

**Hint**: you can use the built-in method [find](https://docs.python.org/3/library/stdtypes.html#str.find).

```{python}
# Type your answer in this cell
```

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

```{python}
a = "I am counting the e's."
a.find('e')
```
</details>

:::

### Removing spaces in a string

Remove the extra spaces at the beginning and end of the following string:

**Hint**: you can use the built-in method [strip](https://docs.python.org/3/library/stdtypes.html#str.strip).

```{python}
# Type your answer in this cell
a = "    A poorly formatted string.         "
```

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

```{python}
a = "    A poorly formatted string.         "
a.strip()
```
</details>

:::

### Escaping characters

The `\` character allows escaping (neutralizing) a special character within a string. Find how this character solves the problem of using quotes (or apostrophes) within a string defined by quotes (apostrophes).

**Hint**: examples of usage are available in the [official documentation](https://docs.python.org/3/reference/lexical_analysis.html#literals).

```{python}
# Type your answer in this cell
```

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

```{python}
"just a \"small\" test"
```
</details>

:::

### A first algorithm

Perform the following sequence of operations using increment operators, and print the final value:

- initialize a variable to 1
- subtract 5 from it
- multiply it by 4
- add 22 to it

```{python}
# Type your answer in this cell
```

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

```{python}
a = 1
a -= 5
a *= 4
a += 22
print(a)
```
</details>

:::

### Composing strings

Consider the following two sequences:

- "we are in"
- "2024"

Find two different ways from the tutorial to compose the sequence "we are in 2024".

**Hint**: one of the two methods involves modifying (slightly) one of the two sequences.

```{python}
# Type your answer in this cell
```

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

```{python}
a1 = "we are in"
a2 = "we are in {}"
b = "2024"

print(a1 + " " + b)
print(a2.format(b))
```
</details>

:::

### `f-strings`

`f-strings` are a somewhat special but very practical form of strings, added in Python version 3.6. To understand their interest, let's go back to the solution of the previous exercise, which illustrated two ways to compose the string "we are in 2024".

```{python}
a1 = "we are in"
a2 = "we are in {}"
b = "2024"

print(a1 + " " + b)
print(a2.format(b))
```

These two methods work but have limitations. Think about what would happen in the following cases, and feel free to run tests to convince yourself:

- if you want to inject a variable that is not a string using the `format()` method (e.g., if "2024" were an integer and not a string)?
- if you want to concatenate several strings together?
- if you want to concatenate several strings together and also inject the values of other variables in each part?

Using the [official documentation](https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals) as inspiration, use `f-strings` to solve these various problems.

```{python}
# Type your answer in this cell
```

::: {.cell .markdown}

<details>
<summary>Show solution</summary>

First problem: composing strings with numeric values.

```{python}
a1 = "we are in"
b = 2024

# print(a1 + " " + b)  # Error
print(a1 + " " + str(b))
```

Direct concatenation returns an error -> you must convert the numeric value to a string first.

Second problem: juxtaposition of multiple strings.

```{python}
a = "we are in"
b = "2024"
c = "and my name is"
d = "Miranda"

print(a + " " + b + " " + c + " " + d)
```

The syntax quickly becomes unreadable, as you must manually add separators (space) between each part.

Third problem: composing strings with variable injection.

```{python}
a = "we are in {}"
b = "2024"
c = "and my name is {}"
d = "Miranda"

print(a.format(b) + " " + c.format(d))
```

The syntax remains unreadable, as you must inject values into each string.

Solution: using f-strings.

```{python}
year = 2024
name = "Miranda"

print(f"we are in {year} and my name is {name}")
```

Much more readable!
</details>

:::


:::